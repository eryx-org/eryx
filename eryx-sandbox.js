"use jco";import { invoke, listCallbacks, reportTrace } from './shims/callbacks.js';
import { tcp, tls } from './shims/net.js';
import { instanceNetwork as instanceNetwork$1, ipNameLookup, network, tcp as tcp$1, tcpCreateSocket, udp, udpCreateSocket } from './shims/sockets.js';
import { environment, exit as exit$1, stderr, stdin, stdout, terminalInput, terminalOutput, terminalStderr, terminalStdin, terminalStdout } from '@bytecodealliance/preview2-shim/cli';
import { monotonicClock, wallClock } from '@bytecodealliance/preview2-shim/clocks';
import { preopens, types } from '@bytecodealliance/preview2-shim/filesystem';
import { error, poll as poll$1, streams } from '@bytecodealliance/preview2-shim/io';
import { insecure, insecureSeed as insecureSeed$1, random } from '@bytecodealliance/preview2-shim/random';
const { close,
  connect,
  read,
  write } = tcp;
close._isHostProvided = true;

if (close=== undefined) {
  const err = new Error("unexpectedly undefined local import 'close', was 'close' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

connect._isHostProvided = true;

if (connect=== undefined) {
  const err = new Error("unexpectedly undefined local import 'connect', was 'connect' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

read._isHostProvided = true;

if (read=== undefined) {
  const err = new Error("unexpectedly undefined local import 'read', was 'read' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

write._isHostProvided = true;

if (write=== undefined) {
  const err = new Error("unexpectedly undefined local import 'write', was 'write' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { close: close$1,
  read: read$1,
  upgrade,
  write: write$1 } = tls;
close$1._isHostProvided = true;

if (close$1=== undefined) {
  const err = new Error("unexpectedly undefined local import 'close$1', was 'close' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

read$1._isHostProvided = true;

if (read$1=== undefined) {
  const err = new Error("unexpectedly undefined local import 'read$1', was 'read' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

upgrade._isHostProvided = true;

if (upgrade=== undefined) {
  const err = new Error("unexpectedly undefined local import 'upgrade', was 'upgrade' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

write$1._isHostProvided = true;

if (write$1=== undefined) {
  const err = new Error("unexpectedly undefined local import 'write$1', was 'write' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { instanceNetwork } = instanceNetwork$1;
instanceNetwork._isHostProvided = true;

if (instanceNetwork=== undefined) {
  const err = new Error("unexpectedly undefined local import 'instanceNetwork', was 'instanceNetwork' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { ResolveAddressStream,
  resolveAddresses } = ipNameLookup;
ResolveAddressStream._isHostProvided = true;

if (ResolveAddressStream=== undefined) {
  const err = new Error("unexpectedly undefined local import 'ResolveAddressStream', was 'ResolveAddressStream' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

resolveAddresses._isHostProvided = true;

if (resolveAddresses=== undefined) {
  const err = new Error("unexpectedly undefined local import 'resolveAddresses', was 'resolveAddresses' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { Network } = network;
Network._isHostProvided = true;

if (Network=== undefined) {
  const err = new Error("unexpectedly undefined local import 'Network', was 'Network' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { TcpSocket } = tcp$1;
TcpSocket._isHostProvided = true;

if (TcpSocket=== undefined) {
  const err = new Error("unexpectedly undefined local import 'TcpSocket', was 'TcpSocket' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { createTcpSocket } = tcpCreateSocket;
createTcpSocket._isHostProvided = true;

if (createTcpSocket=== undefined) {
  const err = new Error("unexpectedly undefined local import 'createTcpSocket', was 'createTcpSocket' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { IncomingDatagramStream,
  OutgoingDatagramStream,
  UdpSocket } = udp;
IncomingDatagramStream._isHostProvided = true;

if (IncomingDatagramStream=== undefined) {
  const err = new Error("unexpectedly undefined local import 'IncomingDatagramStream', was 'IncomingDatagramStream' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

OutgoingDatagramStream._isHostProvided = true;

if (OutgoingDatagramStream=== undefined) {
  const err = new Error("unexpectedly undefined local import 'OutgoingDatagramStream', was 'OutgoingDatagramStream' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

UdpSocket._isHostProvided = true;

if (UdpSocket=== undefined) {
  const err = new Error("unexpectedly undefined local import 'UdpSocket', was 'UdpSocket' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { createUdpSocket } = udpCreateSocket;
createUdpSocket._isHostProvided = true;

if (createUdpSocket=== undefined) {
  const err = new Error("unexpectedly undefined local import 'createUdpSocket', was 'createUdpSocket' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { getArguments,
  getEnvironment,
  initialCwd } = environment;
getArguments._isHostProvided = true;

if (getArguments=== undefined) {
  const err = new Error("unexpectedly undefined local import 'getArguments', was 'getArguments' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

getEnvironment._isHostProvided = true;

if (getEnvironment=== undefined) {
  const err = new Error("unexpectedly undefined local import 'getEnvironment', was 'getEnvironment' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

initialCwd._isHostProvided = true;

if (initialCwd=== undefined) {
  const err = new Error("unexpectedly undefined local import 'initialCwd', was 'initialCwd' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { exit } = exit$1;
exit._isHostProvided = true;

if (exit=== undefined) {
  const err = new Error("unexpectedly undefined local import 'exit', was 'exit' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { getStderr } = stderr;
getStderr._isHostProvided = true;

if (getStderr=== undefined) {
  const err = new Error("unexpectedly undefined local import 'getStderr', was 'getStderr' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { getStdin } = stdin;
getStdin._isHostProvided = true;

if (getStdin=== undefined) {
  const err = new Error("unexpectedly undefined local import 'getStdin', was 'getStdin' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { getStdout } = stdout;
getStdout._isHostProvided = true;

if (getStdout=== undefined) {
  const err = new Error("unexpectedly undefined local import 'getStdout', was 'getStdout' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { TerminalInput } = terminalInput;
TerminalInput._isHostProvided = true;

if (TerminalInput=== undefined) {
  const err = new Error("unexpectedly undefined local import 'TerminalInput', was 'TerminalInput' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { TerminalOutput } = terminalOutput;
TerminalOutput._isHostProvided = true;

if (TerminalOutput=== undefined) {
  const err = new Error("unexpectedly undefined local import 'TerminalOutput', was 'TerminalOutput' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { getTerminalStderr } = terminalStderr;
getTerminalStderr._isHostProvided = true;

if (getTerminalStderr=== undefined) {
  const err = new Error("unexpectedly undefined local import 'getTerminalStderr', was 'getTerminalStderr' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { getTerminalStdin } = terminalStdin;
getTerminalStdin._isHostProvided = true;

if (getTerminalStdin=== undefined) {
  const err = new Error("unexpectedly undefined local import 'getTerminalStdin', was 'getTerminalStdin' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { getTerminalStdout } = terminalStdout;
getTerminalStdout._isHostProvided = true;

if (getTerminalStdout=== undefined) {
  const err = new Error("unexpectedly undefined local import 'getTerminalStdout', was 'getTerminalStdout' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { now,
  resolution,
  subscribeDuration,
  subscribeInstant } = monotonicClock;
now._isHostProvided = true;

if (now=== undefined) {
  const err = new Error("unexpectedly undefined local import 'now', was 'now' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

resolution._isHostProvided = true;

if (resolution=== undefined) {
  const err = new Error("unexpectedly undefined local import 'resolution', was 'resolution' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

subscribeDuration._isHostProvided = true;

if (subscribeDuration=== undefined) {
  const err = new Error("unexpectedly undefined local import 'subscribeDuration', was 'subscribeDuration' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

subscribeInstant._isHostProvided = true;

if (subscribeInstant=== undefined) {
  const err = new Error("unexpectedly undefined local import 'subscribeInstant', was 'subscribeInstant' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { now: now$1,
  resolution: resolution$1 } = wallClock;
now$1._isHostProvided = true;

if (now$1=== undefined) {
  const err = new Error("unexpectedly undefined local import 'now$1', was 'now' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

resolution$1._isHostProvided = true;

if (resolution$1=== undefined) {
  const err = new Error("unexpectedly undefined local import 'resolution$1', was 'resolution' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { getDirectories } = preopens;
getDirectories._isHostProvided = true;

if (getDirectories=== undefined) {
  const err = new Error("unexpectedly undefined local import 'getDirectories', was 'getDirectories' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { Descriptor,
  DirectoryEntryStream,
  filesystemErrorCode } = types;
Descriptor._isHostProvided = true;

if (Descriptor=== undefined) {
  const err = new Error("unexpectedly undefined local import 'Descriptor', was 'Descriptor' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

DirectoryEntryStream._isHostProvided = true;

if (DirectoryEntryStream=== undefined) {
  const err = new Error("unexpectedly undefined local import 'DirectoryEntryStream', was 'DirectoryEntryStream' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

filesystemErrorCode._isHostProvided = true;

if (filesystemErrorCode=== undefined) {
  const err = new Error("unexpectedly undefined local import 'filesystemErrorCode', was 'filesystemErrorCode' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { Error: Error$1 } = error;
Error$1._isHostProvided = true;

if (Error$1=== undefined) {
  const err = new Error("unexpectedly undefined local import 'Error$1', was 'Error' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { Pollable,
  poll } = poll$1;
Pollable._isHostProvided = true;

if (Pollable=== undefined) {
  const err = new Error("unexpectedly undefined local import 'Pollable', was 'Pollable' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

poll._isHostProvided = true;

if (poll=== undefined) {
  const err = new Error("unexpectedly undefined local import 'poll', was 'poll' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { InputStream,
  OutputStream } = streams;
InputStream._isHostProvided = true;

if (InputStream=== undefined) {
  const err = new Error("unexpectedly undefined local import 'InputStream', was 'InputStream' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

OutputStream._isHostProvided = true;

if (OutputStream=== undefined) {
  const err = new Error("unexpectedly undefined local import 'OutputStream', was 'OutputStream' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { getInsecureRandomBytes,
  getInsecureRandomU64 } = insecure;
getInsecureRandomBytes._isHostProvided = true;

if (getInsecureRandomBytes=== undefined) {
  const err = new Error("unexpectedly undefined local import 'getInsecureRandomBytes', was 'getInsecureRandomBytes' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

getInsecureRandomU64._isHostProvided = true;

if (getInsecureRandomU64=== undefined) {
  const err = new Error("unexpectedly undefined local import 'getInsecureRandomU64', was 'getInsecureRandomU64' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { insecureSeed } = insecureSeed$1;
insecureSeed._isHostProvided = true;

if (insecureSeed=== undefined) {
  const err = new Error("unexpectedly undefined local import 'insecureSeed', was 'insecureSeed' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

const { getRandomBytes,
  getRandomU64 } = random;
getRandomBytes._isHostProvided = true;

if (getRandomBytes=== undefined) {
  const err = new Error("unexpectedly undefined local import 'getRandomBytes', was 'getRandomBytes' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}

getRandomU64._isHostProvided = true;

if (getRandomU64=== undefined) {
  const err = new Error("unexpectedly undefined local import 'getRandomU64', was 'getRandomU64' available at instantiation?");
  console.error("ERROR:", err.toString());
  throw err;
}


let dv = new DataView(new ArrayBuffer());
const dataView = mem => dv.buffer === mem.buffer ? dv : dv = new DataView(mem.buffer);

const toUint64 = val => BigInt.asUintN(64, BigInt(val));

function toInt32(val) {
  return val >> 0;
}

function toUint16(val) {
  val >>>= 0;
  val %= 2 ** 16;
  return val;
}

function toUint32(val) {
  return val >>> 0;
}

function toUint8(val) {
  val >>>= 0;
  val %= 2 ** 8;
  return val;
}
const TEXT_DECODER_UTF8 = new TextDecoder();
const TEXT_ENCODER_UTF8 = new TextEncoder();

function _utf8AllocateAndEncode(s, realloc, memory) {
  if (typeof s !== 'string') {
    throw new TypeError('expected a string, received [' + typeof s + ']');
  }
  if (s.length === 0) { return { ptr: 1, len: 0 }; }
  let buf = TEXT_ENCODER_UTF8.encode(s);
  let ptr = realloc(0, 0, 1, buf.length);
  new Uint8Array(memory.buffer).set(buf, ptr);
  return { ptr, len: buf.length, codepoints: [...s].length };
}


const T_FLAG = 1 << 30;

function rscTableCreateOwn (table, rep) {
  const free = table[0] & ~T_FLAG;
  if (free === 0) {
    table.push(0);
    table.push(rep | T_FLAG);
    return (table.length >> 1) - 1;
  }
  table[0] = table[free << 1];
  table[free << 1] = 0;
  table[(free << 1) + 1] = rep | T_FLAG;
  return free;
}

function rscTableRemove (table, handle) {
  const scope = table[handle << 1];
  const val = table[(handle << 1) + 1];
  const own = (val & T_FLAG) !== 0;
  const rep = val & ~T_FLAG;
  if (val === 0 || (scope & T_FLAG) !== 0) throw new TypeError('Invalid handle');
  table[handle << 1] = table[0] | T_FLAG;
  table[0] = handle | T_FLAG;
  return { rep, scope, own };
}

let curResourceBorrows = [];

function contextSet(slot, value) {
  if (!(_typeCheckValidI32(value))) { throw new Error('invalid value for context set (not valid i32)'); }
  const taskMeta = getCurrentTask(ASYNC_CURRENT_COMPONENT_IDXS.at(-1), ASYNC_CURRENT_TASK_IDS.at(-1));
  if (!taskMeta) { throw new Error('failed to retrieve current task'); }
  let task = taskMeta.task;
  if (!task) { throw new Error('invalid/missing current task in metadata while setting context'); }
  
  // TODO(threads): context has been moved to be stored on the thread, not the task.
  // Until threads are implemented, we simulate a task with only one thread by storing
  // the thread state on the topmost task
  task = task.getRootTask();
  
  _debugLog('[contextSet()] args', {
    _globals: { ASYNC_CURRENT_COMPONENT_IDXS, ASYNC_CURRENT_TASK_IDS },
    slot,
    value,
    storage: task.storage,
    taskID: task.id(),
    componentIdx: task.componentIdx(),
  });
  
  if (slot < 0 || slot >= task.storage.length) { throw new Error('invalid slot for current task'); }
  task.storage[slot] = value;
}

function contextGet(slot) {
  const taskMeta = getCurrentTask(ASYNC_CURRENT_COMPONENT_IDXS.at(-1), ASYNC_CURRENT_TASK_IDS.at(-1));
  if (!taskMeta) { throw new Error('failed to retrieve current task metadata'); }
  let task = taskMeta.task;
  if (!task) { throw new Error('invalid/missing current task in metadata while getting context'); }
  
  // TODO(threads): context has been moved to be stored on the thread, not the task.
  // Until threads are implemented, we simulate a task with only one thread by storing
  // the thread state on the topmost task
  task = task.getRootTask();
  
  _debugLog('[contextGet()] args', {
    _globals: { ASYNC_CURRENT_COMPONENT_IDXS, ASYNC_CURRENT_TASK_IDS },
    slot,
    storage: task.storage,
    taskID: task.id(),
    componentIdx: task.componentIdx(),
  });
  
  if (slot < 0 || slot >= task.storage.length) { throw new Error('invalid slot for current task'); }
  
  return task.storage[slot];
}

function taskReturn(ctx) {
  const { componentIdx, useDirectParams, getMemoryFn, memoryIdx, callbackFnIdx, liftFns } = ctx;
  const params = [...arguments].slice(1);
  const memory = getMemoryFn();
  
  _debugLog('[taskReturn()] args', {
    componentIdx,
    callbackFnIdx,
    memoryIdx,
    liftFns,
    params,
  });
  
  const taskMeta = getCurrentTask(componentIdx);
  if (!taskMeta) { throw new Error('failed to retrieve current task metadata'); }
  
  const task = taskMeta.task;
  if (!taskMeta) { throw new Error('invalid/missing current task in metadata'); }
  
  const expectedMemoryIdx = task.getReturnMemoryIdx();
  if (expectedMemoryIdx !== null && memoryIdx !== null && expectedMemoryIdx !== memoryIdx) {
    _debugLog("[taskReturn()] mismatched memory indices", { expectedMemoryIdx, memoryIdx });
    throw new Error('task.return memory [' + memoryIdx + '] does not match task [' + expectedMemoryIdx + ']');
  }
  
  task.callbackFnIdx = callbackFnIdx;
  
  if (!memory && liftFns.length > 4) {
    throw new Error('memory must be present if more than max async flat lifts are performed');
  }
  
  let liftCtx = { memory, useDirectParams, params, componentIdx };
  if (!useDirectParams) {
    liftCtx.storagePtr = params[0];
    liftCtx.storageLen = params[1];
  }
  
  const results = [];
  _debugLog('[taskReturn()] lifting results out of memory', { liftCtx });
  for (const liftFn of liftFns) {
    if (liftCtx.storageLen !== undefined && liftCtx.storageLen <= 0) {
      throw new Error('ran out of storage while writing');
    }
    const [ val, newLiftCtx ] = liftFn(liftCtx);
    liftCtx = newLiftCtx;
    results.push(val);
  }
  
  // TODO(opt): during fused guest->guest calls, we have a helper fn for lift/lower
  // so this task.return could be reduced to ~no-op
  //
  // We perform a superfluous lift and resolve in this fn to keep consistent with
  // the task machinery as it is normally used.
  task.resolve(results);
  
  // If we are in a subtask, and have a fused helper function provided to use
  // via PrepareCall, we can use that function rather than performing lifting manually.
  //
  // See also documentation on `HostIntrinsic::PrepareCall`
  const returnFn = task.getParentSubtask()?.getCallMetadata()?.returnFn;
  if (returnFn) {
    const returnFnArgs = [...params];
    returnFn.apply(null, returnFnArgs);
    return;
  }
}

function subtaskDrop(componentInstanceID, subtaskID) {
  _debugLog('[subtaskDrop()] args', { componentInstanceID, subtaskID });
  const state = getOrCreateAsyncState(componentInstanceID);
  if (!state.mayLeave) { throw new Error('component is not marked as may leave, cannot be cancelled'); }
  
  const subtask =  state.subtasks.remove(subtaskID);
  if (!subtask) { throw new Error('missing/invalid subtask specified for drop in component instance'); }
  
  subtask.drop();
}

function getCurrentTask(componentIdx) {
  if (componentIdx === undefined || componentIdx === null) {
    throw new Error('missing/invalid component instance index [' + componentIdx + '] while getting current task');
  }
  const tasks = ASYNC_TASKS_BY_COMPONENT_IDX.get(componentIdx);
  if (tasks === undefined) { return undefined; }
  if (tasks.length === 0) { return undefined; }
  return tasks[tasks.length - 1];
}

function createNewCurrentTask(args) {
  _debugLog('[createNewCurrentTask()] args', args);
  const {
    componentIdx,
    isAsync,
    entryFnName,
    parentSubtaskID,
    callbackFnName,
    getCallbackFn,
    getParamsFn,
    stringEncoding,
    errHandling,
    getCalleeParamsFn,
    resultPtr,
    callingWasmExport,
  } = args;
  if (componentIdx === undefined || componentIdx === null) {
    throw new Error('missing/invalid component instance index while starting task');
  }
  const taskMetas = ASYNC_TASKS_BY_COMPONENT_IDX.get(componentIdx);
  const callbackFn = getCallbackFn ? getCallbackFn() : null;
  
  const newTask = new AsyncTask({
    componentIdx,
    isAsync,
    entryFnName,
    callbackFn,
    callbackFnName,
    stringEncoding,
    getCalleeParamsFn,
    resultPtr,
    errHandling,
  });
  
  const newTaskID = newTask.id();
  const newTaskMeta = { id: newTaskID, componentIdx, task: newTask };
  
  ASYNC_CURRENT_TASK_IDS.push(newTaskID);
  ASYNC_CURRENT_COMPONENT_IDXS.push(componentIdx);
  
  if (!taskMetas) {
    ASYNC_TASKS_BY_COMPONENT_IDX.set(componentIdx, [newTaskMeta]);
  } else {
    taskMetas.push(newTaskMeta);
  }
  
  return [newTask, newTaskID];
}

function endCurrentTask(componentIdx, taskID) {
  componentIdx ??= ASYNC_CURRENT_COMPONENT_IDXS.at(-1);
  taskID ??= ASYNC_CURRENT_TASK_IDS.at(-1);
  _debugLog('[endCurrentTask()] args', { componentIdx, taskID });
  
  if (componentIdx === undefined || componentIdx === null) {
    throw new Error('missing/invalid component instance index while ending current task');
  }
  
  const tasks = ASYNC_TASKS_BY_COMPONENT_IDX.get(componentIdx);
  if (!tasks || !Array.isArray(tasks)) {
    throw new Error('missing/invalid tasks for component instance while ending task');
  }
  if (tasks.length == 0) {
    throw new Error('no current task(s) for component instance while ending task');
  }
  
  if (taskID) {
    const last = tasks[tasks.length - 1];
    if (last.id !== taskID) {
      // throw new Error('current task does not match expected task ID');
      return;
    }
  }
  
  ASYNC_CURRENT_TASK_IDS.pop();
  ASYNC_CURRENT_COMPONENT_IDXS.pop();
  
  const taskMeta = tasks.pop();
  return taskMeta.task;
}
const ASYNC_TASKS_BY_COMPONENT_IDX = new Map();
const ASYNC_CURRENT_TASK_IDS = [];
const ASYNC_CURRENT_COMPONENT_IDXS = [];

class AsyncTask {
  static _ID = 0n;
  
  static State = {
    INITIAL: 'initial',
    CANCELLED: 'cancelled',
    CANCEL_PENDING: 'cancel-pending',
    CANCEL_DELIVERED: 'cancel-delivered',
    RESOLVED: 'resolved',
  }
  
  static BlockResult = {
    CANCELLED: 'block.cancelled',
    NOT_CANCELLED: 'block.not-cancelled',
  }
  
  #id;
  #componentIdx;
  #state;
  #isAsync;
  #entryFnName = null;
  #subtasks = [];
  
  #onResolveHandlers = [];
  #completionPromise = null;
  
  #memoryIdx = null;
  
  #callbackFn = null;
  #callbackFnName = null;
  
  #postReturnFn = null;
  
  #getCalleeParamsFn = null;
  
  #stringEncoding = null;
  
  #parentSubtask = null;
  
  #needsExclusiveLock = false;
  
  #errHandling;
  
  #backpressurePromise;
  #backpressureWaiters = 0n;
  
  #returnLowerFns = null;
  
  cancelled = false;
  requested = false;
  alwaysTaskReturn = false;
  
  returnCalls =  0;
  storage = [0, 0];
  borrowedHandles = {};
  
  awaitableResume = null;
  awaitableCancel = null;
  
  constructor(opts) {
    this.#id = ++AsyncTask._ID;
    
    if (opts?.componentIdx === undefined) {
      throw new TypeError('missing component id during task creation');
    }
    this.#componentIdx = opts.componentIdx;
    
    this.#state = AsyncTask.State.INITIAL;
    this.#isAsync = opts?.isAsync ?? false;
    this.#entryFnName = opts.entryFnName;
    
    const {
      promise: completionPromise,
      resolve: resolveCompletionPromise,
      reject: rejectCompletionPromise,
    } = promiseWithResolvers();
    this.#completionPromise = completionPromise;
    
    this.#onResolveHandlers.push((results) => {
      resolveCompletionPromise(results);
    })
    
    if (opts.callbackFn) { this.#callbackFn = opts.callbackFn; }
    if (opts.callbackFnName) { this.#callbackFnName = opts.callbackFnName; }
    
    if (opts.getCalleeParamsFn) { this.#getCalleeParamsFn = opts.getCalleeParamsFn; }
    
    if (opts.stringEncoding) { this.#stringEncoding = opts.stringEncoding; }
    
    if (opts.parentSubtask) { this.#parentSubtask = opts.parentSubtask; }
    
    this.#needsExclusiveLock = this.isSync() || !this.hasCallback();
    
    if (opts.errHandling) { this.#errHandling = opts.errHandling; }
  }
  
  taskState() { return this.#state; }
  id() { return this.#id; }
  componentIdx() { return this.#componentIdx; }
  isAsync() { return this.#isAsync; }
  entryFnName() { return this.#entryFnName; }
  completionPromise() { return this.#completionPromise; }
  
  isAsync() { return this.#isAsync; }
  isSync() { return !this.isAsync(); }
  
  getErrHandling() { return this.#errHandling; }
  
  hasCallback() { return this.#callbackFn !== null; }
  
  setReturnMemoryIdx(idx) { this.#memoryIdx = idx; }
  getReturnMemoryIdx() { return this.#memoryIdx; }
  
  setReturnLowerFns(fns) { this.#returnLowerFns = fns; }
  getReturnLowerFns() { return this.#returnLowerFns; }
  
  setParentSubtask(subtask) {
    if (!subtask || !(subtask instanceof AsyncSubtask)) { return }
    if (this.#parentSubtask) { throw new Error('parent subtask can only be set once'); }
    this.#parentSubtask = subtask;
  }
  
  getParentSubtask() { return this.#parentSubtask; }
  
  // TODO(threads): this is very inefficient, we can pass along a root task,
  // and ideally do not need this once thread support is in place
  getRootTask() {
    let currentSubtask = this.getParentSubtask();
    let task = this;
    while (currentSubtask) {
      task = currentSubtask.getParentTask();
      currentSubtask = task.getParentSubtask();
    }
    return task;
  }
  
  setPostReturnFn(f) {
    if (!f) { return; }
    if (this.#postReturnFn) { throw new Error('postReturn fn can only be set once'); }
    this.#postReturnFn = f;
  }
  
  setCallbackFn(f, name) {
    if (!f) { return; }
    if (this.#callbackFn) { throw new Error('callback fn can only be set once'); }
    this.#callbackFn = f;
    this.#callbackFnName = name;
  }
  
  getCallbackFnName() {
    if (!this.#callbackFnName) { return undefined; }
    return this.#callbackFnName;
  }
  
  runCallbackFn(...args) {
    if (!this.#callbackFn) { throw new Error('on callback function has been set for task'); }
    return this.#callbackFn.apply(null, args);
  }
  
  getCalleeParams() {
    if (!this.#getCalleeParamsFn) { throw new Error('missing/invalid getCalleeParamsFn'); }
    return this.#getCalleeParamsFn();
  }
  
  mayEnter(task) {
    const cstate = getOrCreateAsyncState(this.#componentIdx);
    if (cstate.hasBackpressure()) {
      _debugLog('[AsyncTask#mayEnter()] disallowed due to backpressure', { taskID: this.#id });
      return false;
    }
    if (!cstate.callingSyncImport()) {
      _debugLog('[AsyncTask#mayEnter()] disallowed due to sync import call', { taskID: this.#id });
      return false;
    }
    const callingSyncExportWithSyncPending = cstate.callingSyncExport && !task.isAsync;
    if (!callingSyncExportWithSyncPending) {
      _debugLog('[AsyncTask#mayEnter()] disallowed due to sync export w/ sync pending', { taskID: this.#id });
      return false;
    }
    return true;
  }
  
  async enter() {
    _debugLog('[AsyncTask#enter()] args', { taskID: this.#id });
    const cstate = getOrCreateAsyncState(this.#componentIdx);
    
    if (this.isSync()) { return true; }
    
    if (cstate.hasBackpressure()) {
      cstate.addBackpressureWaiter();
      
      const result = await this.waitUntil({
        readyFn: () => !cstate.hasBackpressure(),
        cancellable: true,
      });
      
      cstate.removeBackpressureWaiter();
      
      if (result === AsyncTask.BlockResult.CANCELLED) {
        this.cancel();
        return false;
      }
    }
    
    if (this.needsExclusiveLock()) { cstate.exclusiveLock(); }
    
    return true;
  }
  
  isRunning() {
    return this.#state !== AsyncTask.State.RESOLVED;
  }
  
  async waitUntil(opts) {
    const { readyFn, waitableSetRep, cancellable } = opts;
    _debugLog('[AsyncTask#waitUntil()] args', { taskID: this.#id, waitableSetRep, cancellable });
    
    const state = getOrCreateAsyncState(this.#componentIdx);
    const wset = state.waitableSets.get(waitableSetRep);
    
    let event;
    
    wset.incrementNumWaiting();
    
    const keepGoing = await this.suspendUntil({
      readyFn: () => {
        const hasPendingEvent = wset.hasPendingEvent();
        return readyFn() && hasPendingEvent;
      },
      cancellable,
    });
    
    if (keepGoing) {
      event = wset.getPendingEvent();
    } else {
      event = {
        code: ASYNC_EVENT_CODE.TASK_CANCELLED,
        index: 0,
        result: 0,
      };
    }
    
    wset.decrementNumWaiting();
    
    return event;
  }
  
  async onBlock(awaitable) {
    _debugLog('[AsyncTask#onBlock()] args', { taskID: this.#id, awaitable });
    if (!(awaitable instanceof Awaitable)) {
      throw new Error('invalid awaitable during onBlock');
    }
    
    // Build a promise that this task can await on which resolves when it is awoken
    const { promise, resolve, reject } = promiseWithResolvers();
    this.awaitableResume = () => {
      _debugLog('[AsyncTask] resuming after onBlock', { taskID: this.#id });
      resolve();
    };
    this.awaitableCancel = (err) => {
      _debugLog('[AsyncTask] rejecting after onBlock', { taskID: this.#id, err });
      reject(err);
    };
    
    // Park this task/execution to be handled later
    const state = getOrCreateAsyncState(this.#componentIdx);
    state.parkTaskOnAwaitable({ awaitable, task: this });
    
    try {
      await promise;
      return AsyncTask.BlockResult.NOT_CANCELLED;
    } catch (err) {
      // rejection means task cancellation
      return AsyncTask.BlockResult.CANCELLED;
    }
  }
  
  async asyncOnBlock(awaitable) {
    _debugLog('[AsyncTask#asyncOnBlock()] args', { taskID: this.#id, awaitable });
    if (!(awaitable instanceof Awaitable)) {
      throw new Error('invalid awaitable during onBlock');
    }
    // TODO: watch for waitable AND cancellation
    // TODO: if it WAS cancelled:
    // - return true
    // - only once per subtask
    // - do not wait on the scheduler
    // - control flow should go to the subtask (only once)
    // - Once subtask blocks/resolves, reqlinquishControl() will tehn resolve request_cancel_end (without scheduler lock release)
    // - control flow goes back to request_cancel
    //
    // Subtask cancellation should work similarly to an async import call -- runs sync up until
    // the subtask blocks or resolves
    //
    throw new Error('AsyncTask#asyncOnBlock() not yet implemented');
  }
  
  async yieldUntil(opts) {
    const { readyFn, cancellable } = opts;
    _debugLog('[AsyncTask#yield()] args', { taskID: this.#id, cancellable });
    
    const keepGoing = await this.suspendUntil({ readyFn, cancellable });
    if (!keepGoing) {
      return {
        code: ASYNC_EVENT_CODE.TASK_CANCELLED,
        index: 0,
        result: 0,
      };
    }
    
    return {
      code: ASYNC_EVENT_CODE.NONE,
      index: 0,
      result: 0,
    };
  }
  
  async suspendUntil(opts) {
    const { cancellable, readyFn } = opts;
    _debugLog('[AsyncTask#suspendUntil()] args', { cancellable });
    
    const pendingCancelled = this.deliverPendingCancel({ cancellable });
    if (pendingCancelled) { return false; }
    
    const completed = await this.immediateSuspendUntil({ readyFn, cancellable });
    return completed;
  }
  
  // TODO(threads): equivalent to thread.suspend_until()
  async immediateSuspendUntil(opts) {
    const { cancellable, readyFn } = opts;
    _debugLog('[AsyncTask#immediateSuspendUntil()] args', { cancellable, readyFn });
    
    const ready = readyFn();
    if (ready && !ASYNC_DETERMINISM && _coinFlip()) {
      return true;
    }
    
    const cstate = getOrCreateAsyncState(this.#componentIdx);
    cstate.addPendingTask(this);
    
    const keepGoing = await this.immediateSuspend({ cancellable, readyFn });
    return keepGoing;
  }
  
  async immediateSuspend(opts) { // NOTE: equivalent to thread.suspend()
  // TODO(threads): store readyFn on the thread
  const { cancellable, readyFn } = opts;
  _debugLog('[AsyncTask#immediateSuspend()] args', { cancellable, readyFn });
  
  const pendingCancelled = this.deliverPendingCancel({ cancellable });
  if (pendingCancelled) { return false; }
  
  const cstate = getOrCreateAsyncState(this.#componentIdx);
  
  setTimeout(() => cstate.tick(), 0);
  const taskWait = await cstate.suspendTask({ task: this, readyFn });
  const keepGoing = await taskWait;
  return keepGoing;
}

deliverPendingCancel(opts) {
  const { cancellable } = opts;
  _debugLog('[AsyncTask#deliverPendingCancel()] args', { cancellable });
  
  if (cancellable && this.#state === AsyncTask.State.PENDING_CANCEL) {
    this.#state = Task.State.CANCEL_DELIVERED;
    return true;
  }
  
  return false;
}

isCancelled() { return this.cancelled }

cancel() {
  _debugLog('[AsyncTask#cancel()] args', { });
  if (!this.taskState() !== AsyncTask.State.CANCEL_DELIVERED) {
    throw new Error(`(component [${this.#componentIdx}]) task [${this.#id}] invalid task state for cancellation`);
  }
  if (this.borrowedHandles.length > 0) { throw new Error('task still has borrow handles'); }
  this.cancelled = true;
  this.onResolve(new Error('cancelled'));
  this.#state = AsyncTask.State.RESOLVED;
}

onResolve(taskValue) {
  for (const f of this.#onResolveHandlers) {
    try {
      f(taskValue);
    } catch (err) {
      console.error("error during task resolve handler", err);
      throw err;
    }
  }
  
  if (this.#postReturnFn) {
    _debugLog('[AsyncTask#onResolve()] running post return ', {
      componentIdx: this.#componentIdx,
      taskID: this.#id,
    });
    this.#postReturnFn();
  }
}

registerOnResolveHandler(f) {
  this.#onResolveHandlers.push(f);
}

resolve(results) {
  _debugLog('[AsyncTask#resolve()] args', {
    results,
    componentIdx: this.#componentIdx,
    taskID: this.#id,
  });
  
  if (this.#state === AsyncTask.State.RESOLVED) {
    throw new Error(`(component [${this.#componentIdx}]) task [${this.#id}]  is already resolved (did you forget to wait for an import?)`);
  }
  if (this.borrowedHandles.length > 0) { throw new Error('task still has borrow handles'); }
  switch (results.length) {
    case 0:
    this.onResolve(undefined);
    break;
    case 1:
    this.onResolve(results[0]);
    break;
    default:
    throw new Error('unexpected number of results');
  }
  this.#state = AsyncTask.State.RESOLVED;
}

exit() {
  _debugLog('[AsyncTask#exit()] args', { });
  
  // TODO: ensure there is only one task at a time (scheduler.lock() functionality)
  if (this.#state !== AsyncTask.State.RESOLVED) {
    // TODO(fix): only fused, manually specified post returns seem to break this invariant,
    // as the TaskReturn trampoline is not activated it seems.
    //
    // see: test/p3/ported/wasmtime/component-async/post-return.js
    //
    // We *should* be able to upgrade this to be more strict and throw at some point,
    // which may involve rewriting the upstream test to surface task return manually somehow.
    //
    //throw new Error(`(component [${this.#componentIdx}]) task [${this.#id}] exited without resolution`);
    _debugLog('[AsyncTask#exit()] task exited without resolution', {
      componentIdx: this.#componentIdx,
      taskID: this.#id,
      subtask: this.getParentSubtask(),
      subtaskID: this.getParentSubtask()?.id(),
    });
    this.#state = AsyncTask.State.RESOLVED;
  }
  
  if (this.borrowedHandles > 0) {
    throw new Error('task [${this.#id}] exited without clearing borrowed handles');
  }
  
  const state = getOrCreateAsyncState(this.#componentIdx);
  if (!state) { throw new Error('missing async state for component [' + this.#componentIdx + ']'); }
  if (!this.#isAsync && !state.inSyncExportCall) {
    throw new Error('sync task must be run from components known to be in a sync export call');
  }
  state.inSyncExportCall = false;
  
  if (this.needsExclusiveLock() && !state.isExclusivelyLocked()) {
    throw new Error('task [' + this.#id + '] exit: component [' + this.#componentIdx + '] should have been exclusively locked');
  }
  
  state.exclusiveRelease();
}

needsExclusiveLock() { return this.#needsExclusiveLock; }

createSubtask(args) {
  _debugLog('[AsyncTask#createSubtask()] args', args);
  const { componentIdx, childTask, callMetadata } = args;
  const newSubtask = new AsyncSubtask({
    componentIdx,
    childTask,
    parentTask: this,
    callMetadata,
  });
  this.#subtasks.push(newSubtask);
  return newSubtask;
}

getLatestSubtask() { return this.#subtasks.at(-1); }

currentSubtask() {
  _debugLog('[AsyncTask#currentSubtask()]');
  if (this.#subtasks.length === 0) { return undefined; }
  return this.#subtasks.at(-1);
}

endCurrentSubtask() {
  _debugLog('[AsyncTask#endCurrentSubtask()]');
  if (this.#subtasks.length === 0) { throw new Error('cannot end current subtask: no current subtask'); }
  const subtask = this.#subtasks.pop();
  subtask.drop();
  return subtask;
}
}

class AsyncSubtask {
  static _ID = 0n;
  
  static State = {
    STARTING: 0,
    STARTED: 1,
    RETURNED: 2,
    CANCELLED_BEFORE_STARTED: 3,
    CANCELLED_BEFORE_RETURNED: 4,
  };
  
  #id;
  #state = AsyncSubtask.State.STARTING;
  #componentIdx;
  
  #parentTask;
  #childTask = null;
  
  #dropped = false;
  #cancelRequested = false;
  
  #memoryIdx = null;
  #lenders = null;
  
  #waitable = null;
  #waitableRep = null;
  #waitableResolve = null;
  #waitableReject = null;
  
  #callbackFn = null;
  #callbackFnName = null;
  
  #postReturnFn = null;
  #onProgressFn = null;
  #pendingEventFn = null;
  
  #componentRep = null;
  
  #callMetadata = {};
  
  #onResolveHandlers = [];
  
  constructor(args) {
    if (typeof args.componentIdx !== 'number') {
      throw new Error('invalid componentIdx for subtask creation');
    }
    this.#componentIdx = args.componentIdx;
    
    if (!args.parentTask) { throw new Error('missing parent task during subtask creation'); }
    this.#parentTask = args.parentTask;
    
    if (args.childTask) { this.#childTask = args.childTask; }
    
    if (args.memoryIdx) { this.#memoryIdx = args.memoryIdx; }
    
    if (args.waitable) {
      this.#waitable = args.waitable;
    } else {
      const { promise, resolve, reject } = promiseWithResolvers();
      this.#waitableResolve = resolve;
      this.#waitableReject = reject;
      
      const state = getOrCreateAsyncState(this.#componentIdx);
      if (!state) {
        throw new Error('invalid/missing async state for component instance [' + componentInstanceID + ']');
      }
      
      this.#waitable = new Waitable({ promise,  componentInstanceID: this.#componentIdx });
      this.#waitableRep = state.waitables.insert(this.#waitable);
    }
    
    this.#lenders = [];
    this.#id = ++AsyncSubtask._ID;
    
    if (args.callMetadata) { this.#callMetadata = args.callMetadata; }
  }
  
  id() { return this.#id; }
  parentTaskID() { return this.#parentTask?.id(); }
  childTaskID() { return this.#childTask?.id(); }
  state() { return this.#state; }
  
  componentIdx() { return this.#componentIdx; }
  
  setChildTask(t) {
    if (!t) { throw new Error('cannot set missing/invalid child task on subtask'); }
    if (this.#childTask) { throw new Error('child task is already set on subtask'); }
    this.#childTask = t;
  }
  getChildTask(t) { return this.#childTask; }
  
  getParentTask() { return this.#parentTask; }
  
  setCallbackFn(f, name) {
    if (!f) { return; }
    if (this.#callbackFn) { throw new Error('callback fn can only be set once'); }
    this.#callbackFn = f;
    this.#callbackFnName = name;
  }
  
  getCallbackFnName() {
    if (!this.#callbackFn) { return undefined; }
    return this.#callbackFn.name;
  }
  
  setPostReturnFn(f) {
    if (!f) { return; }
    if (this.#postReturnFn) { throw new Error('postReturn fn can only be set once'); }
    this.#postReturnFn = f;
  }
  
  setOnProgressFn(f) {
    if (this.#onProgressFn) { throw new Error('on progress fn can only be set once'); }
    this.#onProgressFn = f;
  }
  
  isNotStarted() {
    return this.#state == AsyncSubtask.State.STARTING;
  }
  
  onStart(args) {
    if (!this.#onProgressFn) { throw new Error('missing on progress function'); }
    _debugLog('[AsyncSubtask#onStart()] args', {
      componentIdx: this.#componentIdx,
      taskID: this.#id,
      parentTaskID: this.parentTaskID(),
    });
    this.#onProgressFn();
    
    let result;
    
    this.#state = AsyncSubtask.State.STARTED;
    
    // If we have been provided a helper start function as a result of
    // component fusion performed by wasmtime tooling, then we can call that helper and lifts/lowers will
    // be performed for us.
    //
    // See also documentation on `HostIntrinsic::PrepareCall`
    //
    if (this.#callMetadata.startFn) {
      const { resultPtr } = this.#callMetadata;
      const startFnArgs = [];
      if (args?.startFnParams) { startFnArgs.push(...args.startFnParams); }
      result = this.#callMetadata.startFn.apply(null, startFnArgs);
    }
    
    return result;
  }
  
  setPendingEventFn(fn) {
    this.#waitable.setPendingEventFn(fn);
  }
  
  registerOnResolveHandler(f) {
    this.#onResolveHandlers.push(f);
  }
  
  onResolve(subtaskValue) {
    _debugLog('[AsyncSubtask#onResolve()] args', {
      componentIdx: this.#componentIdx,
      subtaskID: this.#id,
      childTaskID: this.childTaskID(),
      parentTaskID: this.parentTaskID(),
      subtaskValue,
    });
    
    if (!this.#onProgressFn) { throw new Error('missing on progress function'); }
    this.#onProgressFn();
    
    if (subtaskValue === null) {
      if (this.#cancelRequested) {
        throw new Error('cancel was not requested, but no value present at return');
      }
      
      if (this.#state === AsyncSubtask.State.STARTING) {
        this.#state = Subtask.State.CANCELLED_BEFORE_STARTED;
      } else {
        if (this.#state !== AsyncSubtask.State.STARTED) {
          throw new Error('cancelled subtask must have been started before cancellation');
        }
        this.#state = AsyncSubtask.State.CANCELLED_BEFORE_RETURNED;
      }
    } else {
      if (this.#state !== AsyncSubtask.State.STARTED) {
        throw new Error('cancelled subtask must have been started before cancellation');
      }
      this.#state = AsyncSubtask.State.RETURNED;
    }
    
    for (const f of this.#onResolveHandlers) {
      try {
        f(subtaskValue);
      } catch (err) {
        console.error("error during subtask resolve handler", err);
        throw err;
      }
    }
    
  }
  
  setRep(rep) { this.#componentRep = rep; }
  
  getStateNumber() { return this.#state; }
  getWaitableRep() { return this.#waitableRep; }
  
  waitableRep() { return this.#waitableRep; }
  
  getCallMetadata() { return this.#callMetadata; }
  
  resolved() {
    if (this.#state === AsyncSubtask.State.STARTING
    || this.#state === AsyncSubtask.State.STARTED) {
      return false;
    }
    if (this.#state === AsyncSubtask.State.RETURNED
    || this.#state === AsyncSubtask.State.CANCELLED_BEFORE_STARTED
    || this.#state === AsyncSubtask.State.CANCELLED_BEFORE_RETURNED) {
      return true;
    }
    throw new Error('unrecognized internal Subtask state [' + this.#state + ']');
  }
  
  addLender(handle) {
    _debugLog('[AsyncSubtask#addLender()] args', { handle });
    if (!Number.isNumber(handle)) { throw new Error('missing/invalid lender handle [' + handle + ']'); }
    
    if (this.#lenders.length === 0 || this.#waitable.resolved()) {
      throw new Error('subtask has no lendors or has already been resolved');
    }
    
    handle.lends++;
    this.#lenders.push(handle);
  }
  
  deliverResolve() {
    _debugLog('[AsyncSubtask#deliverResolve()] args', {
      lenders: this.#lenders,
      parentTaskID: this.parentTaskID(),
      subtaskID: this.#id,
      childTaskID: this.childTaskID(),
      resolved: this.resolved(),
      resolveDelivered: this.resolveDelivered(),
    });
    
    const canDeliverResolve = !this.resolveDelivered() && this.resolved();
    if (!canDeliverResolve) {
      throw new Error('subtask cannot deliver resolution twice, and the subtask must be resolved');
    }
    
    for (const lender of this.#lenders) {
      lender.lends--;
    }
    
    this.#lenders = null;
  }
  
  resolveDelivered() {
    _debugLog('[AsyncSubtask#resolveDelivered()] args', { });
    if (this.#lenders === null && !this.resolved()) {
      throw new Error('invalid subtask state, lenders missing and subtask has not been resolved');
    }
    return this.#lenders === null;
  }
  
  drop() {
    _debugLog('[AsyncSubtask#drop()] args', { });
    if (!this.resolveDelivered()) {
      throw new Error('cannot drop subtask before resolve is delivered');
    }
    if (!this.#waitable) { throw new Error('missing/invalid waitable'); }
    
    const state = this.#getComponentState();
    const waitable = state.waitables.remove(this.#waitableRep);
    
    if (waitable !== this.#waitable) {
      throw new Error('unexpectedly different waitable from removed rep');
    }
    waitable.drop();
    
    this.#dropped = true;
  }
  
  #getComponentState() {
    const state = getOrCreateAsyncState(this.#componentIdx);
    if (!state) {
      throw new Error('invalid/missing async state for component [' + componentInstanceID + ']');
    }
    return state;
  }
  
  getWaitableHandleIdx() {
    _debugLog('[AsyncSubtask#getWaitableHandleIdx()] args', { });
    if (!this.#waitable) { throw new Error('missing/invalid waitable'); }
    return this.#waitableRep;
  }
}

function unpackCallbackResult(result) {
  _debugLog('[unpackCallbackResult()] args', { result });
  if (!(_typeCheckValidI32(result))) { throw new Error('invalid callback return value [' + result + '], not a valid i32'); }
  const eventCode = result & 0xF;
  if (eventCode < 0 || eventCode > 3) {
    throw new Error('invalid async return value [' + eventCode + '], outside callback code range');
  }
  if (result < 0 || result >= 2**32) { throw new Error('invalid callback result'); }
  // TODO: table max length check?
  const waitableSetRep = result >> 4;
  return [eventCode, waitableSetRep];
}

async function _driverLoop(args) {
  _debugLog('[_driverLoop()] args', args);
  const {
    componentState,
    task,
    fnName,
    isAsync,
    resolve,
    reject,
  } = args;
  let callbackResult = args.callbackResult;
  
  const callbackFnName = task.getCallbackFnName();
  const componentIdx = task.componentIdx();
  
  try {
    callbackResult = await callbackResult;
  } catch (err) {
    err.componentIdx = componentIdx;
    
    componentState.setErrored(err);
    _ComponentStateSetAllError();
    
    reject(err);
    task.resolve([]);
    return;
  }
  
  // TODO(fix): callbackResult should not ever be undefined, *unless*
  // we are calling it on a function that was not async to begin with?...
  //
  // In practice, the callback of `[async]run` returns undefined.
  //
  if (callbackResult === undefined) {
    _debugLog('[_driverLoop()] early exit due to undefined callback result', {
      taskID: task.id(),
      subtaskID: task.currentSubtask()?.id(),
      parentTaskID: task.currentSubtask()?.parentTaskID(),
      fnName,
      callbackResult
    });
    resolve(null);
    task.resolve([]);
    return;
  }
  
  // TODO: the callback result here IS a number,
  // because task-return was called with a host function.
  //
  // Is our job here to resolve the task promise w/ the results?
  //
  //
  // Or maybe to take the results, lower them back in for the component
  // that did this call (possibly) to use??
  
  let callbackCode;
  let waitableSetRep;
  let unpacked;
  try {
    if (!(_typeCheckValidI32(callbackResult))) {
      throw new Error('invalid callback result [' + callbackResult + '], not a number');
    }
    
    unpacked = unpackCallbackResult(callbackResult);
    callbackCode = unpacked[0];
    waitableSetRep = unpacked[1];
  } catch(err) {
    console.error("failed to unpack callback result", err);
    throw err;
  }
  
  if (callbackCode < 0 || callbackCode > 3) {
    throw new Error('invalid async return value, outside callback code range');
  }
  
  let eventCode;
  let index;
  let result;
  let asyncRes;
  try {
    while (true) {
      if (callbackCode !== 0) {
        componentState.exclusiveRelease();
      }
      
      switch (callbackCode) {
        case 0: // EXIT
        _debugLog('[_driverLoop()] async exit indicated', {
          fnName,
          componentIdx,
          callbackFnName,
          taskID: task.id()
        });
        task.exit();
        resolve(null);
        return;
        
        case 1: // YIELD
        _debugLog('[_driverLoop()] yield', {
          fnName,
          componentIdx,
          callbackFnName,
          taskID: task.id()
        });
        asyncRes = await task.yieldUntil({
          cancellable: true,
          readyFn: () => !componentState.isExclusivelyLocked()
        });
        break;
        
        case 2: // WAIT for a given waitable set
        _debugLog('[_driverLoop()] waiting for event', {
          fnName,
          componentIdx,
          callbackFnName,
          taskID: task.id(),
          waitableSetRep,
        });
        asyncRes = await task.waitUntil({
          readyFn: () => true,
          waitableSetRep,
          cancellable: true,
        });
        break;
        
        default:
        throw new Error('Unrecognized async function result [' + ret + ']');
      }
      
      componentState.exclusiveLock();
      
      eventCode = asyncRes.code; // async event enum code
      index = asyncRes.index; // idx of related waitable set
      result = asyncRes.result; // task state
      asyncRes = null;
      
      _debugLog('[_driverLoop()] performing callback', {
        fnName,
        componentIdx,
        callbackFnName,
        eventCode,
        index,
        result
      });
      
      const callbackRes = task.runCallbackFn(
      toInt32(eventCode),
      toInt32(index),
      toInt32(result),
      );
      
      unpacked = unpackCallbackResult(callbackRes);
      callbackCode = unpacked[0];
      waitableSetRep = unpacked[1];
    }
  } catch (err) {
    _debugLog('[_driverLoop()] error during async driver loop', {
      fnName,
      callbackFnName,
      eventCode,
      index,
      result,
      err,
    });
    reject(err);
  }
}

function _lowerImport(args, exportFn) {
  const params = [...arguments].slice(2);
  _debugLog('[_lowerImport()] args', { args, params, exportFn });
  const {
    functionIdx,
    componentIdx,
    isAsync,
    paramLiftFns,
    resultLowerFns,
    metadata,
    memoryIdx,
    getMemoryFn,
    getReallocFn,
  } = args;
  
  const parentTaskMeta = getCurrentTask(componentIdx);
  const parentTask = parentTaskMeta?.task;
  if (!parentTask) { throw new Error('missing parent task during lower of import'); }
  
  const cstate = getOrCreateAsyncState(componentIdx);
  
  const subtask = parentTask.createSubtask({
    componentIdx,
    parentTask,
    callMetadata: {
      memoryIdx,
      memory: getMemoryFn(),
      realloc: getReallocFn(),
      resultPtr: params[0],
    }
  });
  parentTask.setReturnMemoryIdx(memoryIdx);
  
  const rep = cstate.subtasks.insert(subtask);
  subtask.setRep(rep);
  
  subtask.setOnProgressFn(() => {
    subtask.setPendingEventFn(() => {
      if (subtask.resolved()) { subtask.deliverResolve(); }
      return {
        code: ASYNC_EVENT_CODE.SUBTASK,
        index: rep,
        result: subtask.getStateNumber(),
      }
    });
  });
  
  // Set up a handler on subtask completion to lower results from the call into the caller's memory region.
  subtask.registerOnResolveHandler((res) => {
    _debugLog('[_lowerImport()] handling subtask result', { res, subtaskID: subtask.id() });
    const { memory, resultPtr, realloc } = subtask.getCallMetadata();
    resultLowerFns[0]({ componentIdx, memory, realloc, vals: [res], storagePtr: resultPtr });
  });
  
  const subtaskState = subtask.getStateNumber();
  if (subtaskState < 0 || subtaskState > 2**5) {
    throw new Error('invalid subtask state, out of valid range');
  }
  
  // NOTE: we must wait a bit before calling the export function,
  // to ensure the subtask state is not modified before the lower call return
  //
  // TODO: we should trigger via subtask state changing, rather than a static wait?
  setTimeout(async () => {
    try {
      _debugLog('[_lowerImport()] calling lowered import', { exportFn, params });
      exportFn.apply(null, params);
      
      const task = subtask.getChildTask();
      task.registerOnResolveHandler((res) => {
        _debugLog('[_lowerImport()] cascading subtask completion', {
          childTaskID: task.id(),
          subtaskID: subtask.id(),
          parentTaskID: parentTask.id(),
        });
        
        subtask.onResolve(res);
        
        cstate.tick();
      });
    } catch (err) {
      console.error("post-lower import fn error:", err);
      throw err;
    }
  }, 100);
  
  return Number(subtask.waitableRep()) << 4 | subtaskState;
}

class WaitableSet {
  #componentInstanceID;
  #waitables = [];
  #pendingEvent = null;
  #waiting = 0;
  
  constructor(componentInstanceID) {
    this.#componentInstanceID = componentInstanceID;
  }
  
  numWaitables() { return this.#waitables.length; }
  numWaiting() { return this.#waiting; }
  
  incrementNumWaiting(n) { this.#waiting += n ?? 1; }
  decrementNumWaiting(n) { this.#waiting -= n ?? 1; }
  
  shuffleWaitables() {
    this.#waitables = this.#waitables
    .map(value => ({ value, sort: Math.random() }))
    .sort((a, b) => a.sort - b.sort)
    .map(({ value }) => value);
  }
  
  removeWaitable(waitable) {
    const existing = this.#waitables.find(w => w === waitable);
    if (!existing) { return undefined; }
    this.#waitables = this.#waitables.filter(w => w !== waitable);
    return waitable;
  }
  
  addWaitable(waitable) {
    this.removeWaitable(waitable);
    this.#waitables.push(waitable);
  }
  
  hasPendingEvent() {
    _debugLog('[WaitableSet#hasPendingEvent()] args', {
      componentIdx: this.#componentInstanceID
    });
    const waitable = this.#waitables.find(w => w.hasPendingEvent());
    return waitable !== undefined;
  }
  
  getPendingEvent() {
    _debugLog('[WaitableSet#getPendingEvent()] args', {
      componentIdx: this.#componentInstanceID
    });
    for (const waitable of this.#waitables) {
      if (!waitable.hasPendingEvent()) { continue; }
      return waitable.getPendingEvent();
    }
    throw new Error('no waitables had a pending event');
  }
  
  async poll() {
    _debugLog('[WaitableSet#poll()] args', {
      componentIdx: this.#componentInstanceID
    });
    
    const state = getOrCreateAsyncState(this.#componentInstanceID);
    
    this.shuffleWaitables();
    
    for (const waitableRep of this.#waitables) {
      const w = state.waitables.get(waitableRep);
      if (!w) { throw new Error('no waitable with rep [' + waitableRep + ']'); }
      waitables.push(w);
    }
    
    const event = await Promise.race(waitables.map((w) => w.promise));
    
    throw new Error('WaitableSet#poll() not implemented');
  }
}

class Waitable {
  static _ID =  0n; // NOTE: this id is *not* the component model representation (aka 'rep')
  
  #id;
  #componentInstanceID;
  #pendingEventFn = null;
  #waitableSet;
  #promise;
  
  constructor({ promise, componentInstanceID }) {
    this.#id = ++Waitable._ID;
    this.#componentInstanceID = componentInstanceID;
    this.#promise = promise;
  }
  
  hasPendingEvent() {
    _debugLog('[Waitable#hasPendingEvent()]', {
      componentIdx: this.#componentInstanceID,
      waitableSet: this.#waitableSet,
      hasPendingEvent: this.#pendingEventFn,
    });
    return this.#pendingEventFn !== null;
  }
  
  setPendingEventFn(fn) {
    _debugLog('[Waitable#setPendingEvent()] args', { });
    this.#pendingEventFn = fn;
  }
  
  getPendingEvent() {
    _debugLog('[Waitable#getPendingEvent()] args', { });
    if (this.#pendingEventFn === null) { return null; }
    const e = this.#pendingEventFn();
    this.#pendingEventFn = null;
    return e;
  }
  
  async poll() {
    _debugLog('[Waitable#poll()] args', {
      componentIdx: this.#componentInstanceID,
      _id: this.#id,
    });
    
    const state = getOrCreateAsyncState(this.#componentInstanceID);
    if (!state) {
      throw new Error('invalid/missing async state for component instance [' + componentInstanceID + ']');
    }
    
    const waitables = [];
    for (const waitableRep in waitableSet.waitables) {
      const w = state.waitables.get(waitableRep);
      if (!w) { throw new Error('no waitable with rep [' + waitableRep + ']'); }
      waitables.push(w);
    }
    
    const event = await Promise.race(waitables.map((w) => w.promise));
    
    throw new Error('Waitable#poll() not implemented');
  }
  
  join(waitableSet) {
    if (this.#waitableSet) { this.#waitableSet.removeWaitable(this); }
    if (!waitableSet) {
      this.#waitableSet = null;
      return;
    }
    waitableSet.addWaitable(this);
    this.#waitableSet = waitableSet;
  }
  
  drop() {
    _debugLog('[Waitable#drop()] args', {
      componentIdx: this.#componentInstanceID,
      _id: this.#id,
    });
    if (this.hasPendingEvent()) {
      throw new Error('waitables with pending events cannot be dropped');
    }
    this.join(null);
  }
  
}

function waitableSetNew(componentInstanceID) {
  _debugLog('[waitableSetNew()] args', { componentInstanceID });
  const state = getOrCreateAsyncState(componentInstanceID);
  if (!state) { throw new Error('invalid/missing async state for component instance [' + componentInstanceID + ']'); }
  const rep = state.waitableSets.insert(new WaitableSet(componentInstanceID));
  if (typeof rep !== 'number') { throw new Error('invalid/missing waitable set rep [' + rep + ']'); }
  return rep;
}

function waitableSetDrop(componentInstanceID, waitableSetRep) {
  _debugLog('[waitableSetDrop()] args', { componentInstanceID, waitableSetRep });
  const task = getCurrentTask(componentInstanceID);
  
  if (!task) { throw new Error('invalid/missing async task'); }
  if (task.componentIdx !== componentInstanceID) {
    throw Error('task component idx [' + task.componentIdx + '] != component instance ID [' + componentInstanceID + ']');
  }
  
  const state = getOrCreateAsyncState(componentInstanceID);
  if (!state.mayLeave) { throw new Error('component instance is not marked as may leave, cannot be cancelled'); }
  
  getOrCreateAsyncState({ state, waitableSetRep, task });
}

function waitableJoin(componentInstanceID, waitableRep, waitableSetRep) {
  _debugLog('[waitableJoin()] args', { componentInstanceID, waitableSetRep, waitableRep });
  
  const state = getOrCreateAsyncState(componentInstanceID);
  if (!state) {
    throw new Error('invalid/missing async state for component instance [' + componentInstanceID + ']');
  }
  
  if (!state.mayLeave) {
    throw new Error('component instance is not marked as may leave, cannot join waitable');
  }
  
  const waitable = state.waitables.get(waitableRep);
  if (!waitable) {
    throw new Error('failed to find waitable [' + waitableRep + '] in component instance [' + componentInstanceID + ']');
  }
  
  const waitableSet = waitableSetRep === 0 ? null : state.waitableSets.get(waitableSetRep);
  if (waitableSetRep !== 0 && !waitableSet) {
    throw new Error('failed to find waitable set [' + waitableSetRep + '] in component instance [' + componentInstanceID + ']');
  }
  
  waitable.join(waitableSet);
}

function _liftFlatBool(ctx) {
  _debugLog('[_liftFlatBool()] args', { ctx });
  
  let val;
  if (ctx.useDirectParams) {
    if (ctx.params.length === 0) { throw new Error('expected at least a single i32 argument'); }
    val = ctx.params[0] === 1;
    ctx.params = ctx.params.slice(1);
  } else {
    if (ctx.storageLen < ctx.storagePtr + 1) { throw new Error('not enough storage remaining for lift'); }
    val = new DataView(ctx.memory.buffer).getUint8(ctx.storagePtr) === 1;
    ctx.storagePtr += 1;
    ctx.storageLen -= 1;
  }
  
  return [val, ctx];
}

function _liftFlatU8(ctx) {
  _debugLog('[_liftFlatU8()] args', { ctx });
  
  let val;
  if (ctx.useDirectParams) {
    if (ctx.params.length === 0) { throw new Error('expected at least a single i32 argument'); }
    val = ctx.params[0];
    ctx.params = ctx.params.slice(1);
  } else {
    if (ctx.storageLen < ctx.storagePtr + 1) { throw new Error('not enough storage remaining for lift'); }
    val = new DataView(ctx.memory.buffer).getUint8(ctx.storagePtr);
    ctx.storagePtr += 1;
    ctx.storageLen -= 1;
  }
  
  return [val, ctx];
}

function _liftFlatU16(ctx) {
  _debugLog('[_liftFlatU16()] args', { ctx });
  
  let val;
  if (ctx.useDirectParams) {
    if (params.length === 0) { throw new Error('expected at least a single i32 argument'); }
    val = ctx.params[0];
    ctx.params = ctx.params.slice(1);
  } else {
    if (ctx.storageLen < ctx.storagePtr + 2) { throw new Error('not enough storage remaining for lift'); }
    val = new DataView(ctx.memory.buffer).getUint16(ctx.storagePtr);
    ctx.storagePtr += 2;
    ctx.storageLen -= 2;
  }
  
  return [val, ctx];
}

function _liftFlatU32(ctx) {
  _debugLog('[_liftFlatU32()] args', { ctx });
  
  let val;
  if (ctx.useDirectParams) {
    if (ctx.params.length === 0) { throw new Error('expected at least a single i34 argument'); }
    val = ctx.params[0];
    ctx.params = ctx.params.slice(1);
  } else {
    if (ctx.storageLen < ctx.storagePtr + 4) { throw new Error('not enough storage remaining for lift'); }
    val = new DataView(ctx.memory.buffer).getUint32(ctx.storagePtr);
    ctx.storagePtr += 4;
    ctx.storageLen -= 4;
  }
  
  return [val, ctx];
}

function _liftFlatU64(ctx) {
  _debugLog('[_liftFlatU64()] args', { ctx });
  
  let val;
  if (ctx.useDirectParams) {
    if (ctx.params.length === 0) { throw new Error('expected at least one single i64 argument'); }
    if (typeof ctx.params[0] !== 'bigint') { throw new Error('expected bigint'); }
    val = ctx.params[0];
    ctx.params = ctx.params.slice(1);
  } else {
    if (ctx.storageLen < ctx.storagePtr + 8) { throw new Error('not enough storage remaining for lift'); }
    val = new DataView(ctx.memory.buffer).getUint64(ctx.storagePtr);
    ctx.storagePtr += 8;
    ctx.storageLen -= 8;
  }
  
  return [val, ctx];
}

function _liftFlatStringUTF8(ctx) {
  _debugLog('[_liftFlatStringUTF8()] args', { ctx });
  
  let val;
  if (ctx.useDirectParams) {
    if (ctx.params.length < 2) { throw new Error('expected at least two u32 arguments'); }
    const offset = ctx.params[0];
    if (!Number.isSafeInteger(offset)) {  throw new Error('invalid offset'); }
    const len = ctx.params[1];
    if (!Number.isSafeInteger(len)) {  throw new Error('invalid len'); }
    val = TEXT_DECODER_UTF8.decode(new DataView(ctx.memory.buffer, offset, len));
    ctx.params = ctx.params.slice(2);
  } else {
    const start = new DataView(ctx.memory.buffer).getUint32(ctx.storagePtr, true);
    const codeUnits = new DataView(ctx.memory.buffer).getUint32(ctx.storagePtr + 4, true);
    val = TEXT_DECODER_UTF8.decode(new Uint8Array(ctx.memory.buffer, start, codeUnits));
    ctx.storagePtr += 8;
    ctx.storageLen -= 8;
  }
  
  return [val, ctx];
}

function _liftFlatRecord(keysAndLiftFns) {
  return function _liftFlatRecordInner(ctx) {
    _debugLog('[_liftFlatRecord()] args', { ctx });
    const { memory, useDirectParams, storagePtr, storageLen, params } = ctx;
    
    const res = {};
    for (const [key, liftFn, alignment32] of keysAndLiftFns) {
      ctx.storagePtr = Math.ceil(ctx.storagePtr / alignment32) * alignment32;
      let [val, newCtx] = liftFn(ctx);
      res[key] = val;
      ctx = newCtx;
    }
    
    return [res, ctx];
  }
}

function _liftFlatVariant(casesAndLiftFns) {
  return function _liftFlatVariantInner(ctx) {
    _debugLog('[_liftFlatVariant()] args', { ctx });
    
    const origUseParams = ctx.useDirectParams;
    
    let caseIdx;
    if (casesAndLiftFns.length < 256) {
      let discriminantByteLen = 1;
      const [idx, newCtx] = _liftFlatU8(ctx);
      caseIdx = idx;
      ctx = newCtx;
    } else if (casesAndLiftFns.length > 256 && discriminantByteLen < 65536) {
      discriminantByteLen = 2;
      const [idx, newCtx] = _liftFlatU16(ctx);
      caseIdx = idx;
      ctx = newCtx;
    } else if (casesAndLiftFns.length > 65536 && discriminantByteLen < 4_294_967_296) {
      discriminantByteLen = 4;
      const [idx, newCtx] = _liftFlatU32(ctx);
      caseIdx = idx;
      ctx = newCtx;
    } else {
      throw new Error('unsupported number of cases [' + casesAndLIftFns.legnth + ']');
    }
    
    const [ tag, liftFn, size32, alignment32 ] = casesAndLiftFns[caseIdx];
    
    let val;
    if (liftFn === null) {
      val = { tag };
      return [val, ctx];
    }
    
    const [newVal, newCtx] = liftFn(ctx);
    ctx = newCtx;
    val = { tag, val: newVal };
    
    return [val, ctx];
  }
}

function _liftFlatList(elemLiftFn, alignment32, knownLen) {
  function _liftFlatListInner(ctx) {
    _debugLog('[_liftFlatList()] args', { ctx });
    
    let metaPtr;
    let dataPtr;
    let len;
    if (ctx.useDirectParams) {
      if (knownLen) {
        dataPtr = _liftFlatU32(ctx);
      } else {
        metaPtr = _liftFlatU32(ctx);
      }
    } else {
      if (knownLen) {
        dataPtr = _liftFlatU32(ctx);
      } else {
        metaPtr = _liftFlatU32(ctx);
      }
    }
    
    if (metaPtr) {
      if (dataPtr !== undefined) { throw new Error('both meta and data pointers should not be set yet'); }
      
      if (ctx.useDirectParams) {
        ctx.useDirectParams = false;
        ctx.storagePtr = metaPtr;
        ctx.storageLen = 8;
        
        dataPtr = _liftFlatU32(ctx);
        len = _liftFlatU32(ctx);
        
        ctx.useDirectParams = true;
        ctx.storagePtr = null;
        ctx.storageLen = null;
      } else {
        dataPtr = _liftFlatU32(ctx);
        len = _liftFlatU32(ctx);
      }
    }
    
    const val = [];
    for (var i = 0; i < len; i++) {
      ctx.storagePtr = Math.ceil(ctx.storagePtr / alignment32) * alignment32;
      const [res, nextCtx] = elemLiftFn(ctx);
      val.push(res);
      ctx = nextCtx;
    }
    
    return [val, ctx];
  }
}

function _liftFlatTuple(numberedLiftFns) {
  return function _liftFlatTupleInner(ctx) {
    _debugLog('[_liftFlatTuple()] args', { ctx });
    
    const obj = _liftFlatRecord(numberedLiftFns)(ctx);
    const val = [];
    for (var i = 0; i++; i < nubmeredLiftFns.length) {
      val.push(obj[i]);
    }
    
    return val;
  }
}

function _liftFlatFlags(cases) {
  return function _liftFlatFlagsInner(ctx) {
    _debugLog('[_liftFlatFlags()] args', { ctx });
    throw new Error('flat lift for flags not yet implemented!');
  }
}

function _liftFlatEnum(casesAndLiftFns) {
  return function _liftFlatEnumInner(ctx) {
    _debugLog('[_liftFlatEnum()] args', { ctx });
    return _liftFlatVariant(casesAndLiftFns)(ctx);
  }
}

function _liftFlatOption(casesAndLiftFns) {
  return function _liftFlatOptionInner(ctx) {
    _debugLog('[_liftFlatOption()] args', { ctx });
    return _liftFlatVariant(casesAndLiftFns)(ctx);
  }
}

function _liftFlatResult(casesAndLiftFns) {
  return function _liftFlatResultInner(ctx) {
    _debugLog('[_liftFlatResult()] args', { ctx });
    return _liftFlatVariant(casesAndLiftFns)(ctx);
  }
}

function _liftFlatOwn(componentTableIdx, size, memory, vals, storagePtr, storageLen) {
  _debugLog('[_liftFlatOwn()] args', { size, memory, vals, storagePtr, storageLen });
  throw new Error('flat lift for owned resources not yet implemented!');
}

function _lowerFlatBool(memory, vals, storagePtr, storageLen) {
  _debugLog('[_lowerFlatBool()] args', { memory, vals, storagePtr, storageLen });
  if (vals.length !== 1) {
    throw new Error('unexpected number (' + vals.length + ') of core vals (expected 1)');
  }
  if (vals[0] !== 0 && vals[0] !== 1) { throw new Error('invalid value for core value representing bool'); }
  new DataView(memory.buffer).setUint32(storagePtr, vals[0], true);
  return 1;
}

function _lowerFlatU8(ctx) {
  _debugLog('[_lowerFlatU8()] args', ctx);
  const { memory, realloc, vals, storagePtr, storageLen } = ctx;
  if (vals.length !== 1) {
    throw new Error('unexpected number (' + vals.length + ') of core vals (expected 1)');
  }
  if (vals[0] > 255 || vals[0] < 0) { throw new Error('invalid value for core value representing u8'); }
  if (!memory) { throw new Error("missing memory for lower"); }
  new DataView(memory.buffer).setUint32(storagePtr, vals[0], true);
  return 1;
}

function _lowerFlatU16(memory, vals, storagePtr, storageLen) {
  _debugLog('[_lowerFlatU16()] args', { memory, vals, storagePtr, storageLen });
  if (vals.length !== 1) {
    throw new Error('unexpected number (' + vals.length + ') of core vals (expected 1)');
  }
  if (vals[0] > 65_535 || vals[0] < 0) { throw new Error('invalid value for core value representing u16'); }
  new DataView(memory.buffer).setUint16(storagePtr, vals[0], true);
  return 2;
}

function _lowerFlatU32(ctx) {
  _debugLog('[_lowerFlatU32()] args', ctx);
  const { memory, realloc, vals, storagePtr, storageLen } = ctx;
  if (vals.length !== 1) { throw new Error('expected single value to lower, got (' + vals.length + ')'); }
  if (vals[0] > 4_294_967_295 || vals[0] < 0) { throw new Error('invalid value for core value representing u32'); }
  
  // TODO(fix): fix misaligned writes properly
  const rem = ctx.storagePtr % 4;
  if (rem !== 0) { ctx.storagePtr += (4 - rem); }
  
  new DataView(memory.buffer).setUint32(storagePtr, vals[0], true);
  return 4;
}

function _lowerFlatU64(memory, vals, storagePtr, storageLen) {
  _debugLog('[_lowerFlatU64()] args', { memory, vals, storagePtr, storageLen });
  if (vals.length !== 1) { throw new Error('unexpected number of core vals'); }
  if (vals[0] > 18_446_744_073_709_551_615n || vals[0] < 0n) { throw new Error('invalid value for core value representing u64'); }
  new DataView(memory.buffer).setBigUint64(storagePtr, vals[0], true);
  return 8;
}

function _lowerFlatStringUTF8(ctx) {
  _debugLog('[_lowerFlatStringUTF8()] args', ctx);
  const { memory, realloc, vals, storagePtr, storageLen } = ctx;
  
  const s = vals[0];
  const { ptr, len, codepoints } = _utf8AllocateAndEncode(vals[0], realloc, memory);
  
  const view = new DataView(memory.buffer);
  view.setUint32(storagePtr, ptr, true);
  view.setUint32(storagePtr + 4, codepoints, true);
  
  return len;
}

function _lowerFlatRecord(fieldMetas) {
  return (size, memory, vals, storagePtr, storageLen) => {
    const params = [...arguments].slice(5);
    _debugLog('[_lowerFlatRecord()] args', {
      size,
      memory,
      vals,
      storagePtr,
      storageLen,
      params,
      fieldMetas
    });
    
    const [start] = vals;
    if (storageLen !== undefined && size !== undefined && size > storageLen) {
      throw new Error('not enough storage remaining for record flat lower');
    }
    const data = new Uint8Array(memory.buffer, start, size);
    new Uint8Array(memory.buffer, storagePtr, size).set(data);
    return data.byteLength;
  }
}

function _lowerFlatVariant(metadata, extra) {
  const { discriminantSizeBytes, lowerMetas } = metadata;
  
  return function _lowerFlatVariantInner(ctx) {
    _debugLog('[_lowerFlatVariant()] args', ctx);
    const { memory, realloc, vals, storageLen, componentIdx } = ctx;
    let storagePtr = ctx.storagePtr;
    
    const { tag, val } = vals[0];
    const variant = lowerMetas.find(vm => vm.tag === tag);
    if (!variant) { throw new Error(`missing/invalid variant, no tag matches [${tag}] (options were ${variantMetas.map(vm => vm.tag)})`); }
    if (!variant.discriminant) { throw new Error(`missing/invalid discriminant for variant [${variant}]`); }
    
    let bytesWritten;
    let discriminantLowerArgs = { memory, realloc, vals: [variant.discriminant], storagePtr, componentIdx }
    switch (discriminantSizeBytes) {
      case 1:
      bytesWritten = _lowerFlatU8(discriminantLowerArgs);
      break;
      case 2:
      bytesWritten = _lowerFlatU16(discriminantLowerArgs);
      break;
      case 4:
      bytesWritten = _lowerFlatU32(discriminantLowerArgs);
      break;
      default:
      throw new Error(`unexpected discriminant size bytes [${discriminantSizeBytes}]`);
    }
    if (bytesWritten !== discriminantSizeBytes) {
      throw new Error("unexpectedly wrote more bytes than discriminant");
    }
    storagePtr += bytesWritten;
    
    bytesWritten += variant.lowerFn({ memory, realloc, vals: [val], storagePtr, storageLen, componentIdx });
    
    return bytesWritten;
  }
}

function _lowerFlatList(size, memory, vals, storagePtr, storageLen) {
  _debugLog('[_lowerFlatList()] args', { size, memory, vals, storagePtr, storageLen });
  let [start, len] = vals;
  const totalSizeBytes = len * size;
  if (storageLen !== undefined && totalSizeBytes > storageLen) {
    throw new Error('not enough storage remaining for list flat lower');
  }
  const data = new Uint8Array(memory.buffer, start, totalSizeBytes);
  new Uint8Array(memory.buffer, storagePtr, totalSizeBytes).set(data);
  return data.byteLength;
}

function _lowerFlatTuple(size, memory, vals, storagePtr, storageLen) {
  _debugLog('[_lowerFlatTuple()] args', { size, memory, vals, storagePtr, storageLen });
  let [start, len] = vals;
  if (storageLen !== undefined && len > storageLen) {
    throw new Error('not enough storage remaining for tuple flat lower');
  }
  const data = new Uint8Array(memory.buffer, start, len);
  new Uint8Array(memory.buffer, storagePtr, len).set(data);
  return data.byteLength;
}

function _lowerFlatFlags(memory, vals, storagePtr, storageLen) {
  _debugLog('[_lowerFlatFlags()] args', { size, memory, vals, storagePtr, storageLen });
  if (vals.length !== 1) { throw new Error('unexpected number of core vals'); }
  new DataView(memory.buffer).setInt32(storagePtr, vals[0], true);
  return 4;
}

function _lowerFlatEnum(size, memory, vals, storagePtr, storageLen) {
  _debugLog('[_lowerFlatEnum()] args', { size, memory, vals, storagePtr, storageLen });
  let [start] = vals;
  if (storageLen !== undefined && size !== undefined && size > storageLen) {
    throw new Error('not enough storage remaining for enum flat lower');
  }
  const data = new Uint8Array(memory.buffer, start, size);
  new Uint8Array(memory.buffer, storagePtr, size).set(data);
  return data.byteLength;
}

function _lowerFlatOption(size, memory, vals, storagePtr, storageLen) {
  _debugLog('[_lowerFlatOption()] args', { size, memory, vals, storagePtr, storageLen });
  let [start] = vals;
  if (storageLen !== undefined && size !== undefined && size > storageLen) {
    throw new Error('not enough storage remaining for option flat lower');
  }
  const data = new Uint8Array(memory.buffer, start, size);
  new Uint8Array(memory.buffer, storagePtr, size).set(data);
  return data.byteLength;
}

function _lowerFlatResult(lowerMetas) {
  const invalidTag = lowerMetas.find(t => t.tag !== 'ok' && t.tag !== 'error')
  if (invalidTag) { throw new Error(`invalid variant tag [${invalidTag}] found for result`); }
  
  return function _lowerFlatResultInner() {
    _debugLog('[_lowerFlatResult()] args', { lowerMetas });
    let lowerFn = _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas }, { forResult: true });
    return lowerFn.apply(null, arguments);
  };
}

function _lowerFlatOwn(size, memory, vals, storagePtr, storageLen) {
  _debugLog('[_lowerFlatOwn()] args', { size, memory, vals, storagePtr, storageLen });
  throw new Error('flat lower for owned resources not yet implemented!');
}
const ASYNC_STATE = new Map();

function getOrCreateAsyncState(componentIdx, init) {
  if (!ASYNC_STATE.has(componentIdx)) {
    const newState = new ComponentAsyncState({ componentIdx });
    ASYNC_STATE.set(componentIdx, newState);
  }
  return ASYNC_STATE.get(componentIdx);
}

class ComponentAsyncState {
  static EVENT_HANDLER_EVENTS = [ 'backpressure-change' ];
  
  #componentIdx;
  #callingAsyncImport = false;
  #syncImportWait = promiseWithResolvers();
  #locked = false;
  #parkedTasks = new Map();
  #suspendedTasksByTaskID = new Map();
  #suspendedTaskIDs = [];
  #pendingTasks = [];
  #errored = null;
  
  #backpressure = 0;
  #backpressureWaiters = 0n;
  
  #handlerMap = new Map();
  #nextHandlerID = 0n;
  
  mayLeave = true;
  
  waitableSets;
  waitables;
  subtasks;
  
  constructor(args) {
    this.#componentIdx = args.componentIdx;
    this.waitableSets = new RepTable({ target: `component [${this.#componentIdx}] waitable sets` });
    this.waitables = new RepTable({ target: `component [${this.#componentIdx}] waitables` });
    this.subtasks = new RepTable({ target: `component [${this.#componentIdx}] subtasks` });
  };
  
  componentIdx() { return this.#componentIdx; }
  
  errored() { return this.#errored !== null; }
  setErrored(err) {
    _debugLog('[ComponentAsyncState#setErrored()] component errored', { err, componentIdx: this.#componentIdx });
    if (this.#errored) { return; }
    if (!err) {
      err = new Error('error elswehere (see other component instance error)')
      err.componentIdx = this.#componentIdx;
    }
    this.#errored = err;
  }
  
  callingSyncImport(val) {
    if (val === undefined) { return this.#callingAsyncImport; }
    if (typeof val !== 'boolean') { throw new TypeError('invalid setting for async import'); }
    const prev = this.#callingAsyncImport;
    this.#callingAsyncImport = val;
    if (prev === true && this.#callingAsyncImport === false) {
      this.#notifySyncImportEnd();
    }
  }
  
  #notifySyncImportEnd() {
    const existing = this.#syncImportWait;
    this.#syncImportWait = promiseWithResolvers();
    existing.resolve();
  }
  
  async waitForSyncImportCallEnd() {
    await this.#syncImportWait.promise;
  }
  
  setBackpressure(v) { this.#backpressure = v; }
  getBackpressure(v) { return this.#backpressure; }
  incrementBackpressure() {
    const newValue = this.getBackpressure() + 1;
    if (newValue > 2**16) { throw new Error("invalid backpressure value, overflow"); }
    this.setBackpressure(newValue);
  }
  decrementBackpressure() {
    this.setBackpressure(Math.max(0, this.getBackpressure() - 1));
  }
  hasBackpressure() { return this.#backpressure > 0; }
  
  waitForBackpressure() {
    let backpressureCleared = false;
    const cstate = this;
    cstate.addBackpressureWaiter();
    const handlerID = this.registerHandler({
      event: 'backpressure-change',
      fn: (bp) => {
        if (bp === 0) {
          cstate.removeHandler(handlerID);
          backpressureCleared = true;
        }
      }
    });
    return new Promise((resolve) => {
      const interval = setInterval(() => {
        if (backpressureCleared) { return; }
        clearInterval(interval);
        cstate.removeBackpressureWaiter();
        resolve(null);
      }, 0);
    });
  }
  
  registerHandler(args) {
    const { event, fn } = args;
    if (!event) { throw new Error("missing handler event"); }
    if (!fn) { throw new Error("missing handler fn"); }
    
    if (!ComponentAsyncState.EVENT_HANDLER_EVENTS.includes(event)) {
      throw new Error(`unrecognized event handler [${event}]`);
    }
    
    const handlerID = this.#nextHandlerID++;
    let handlers = this.#handlerMap.get(event);
    if (!handlers) {
      handlers = [];
      this.#handlerMap.set(event, handlers)
    }
    
    handlers.push({ id: handlerID, fn, event });
    return handlerID;
  }
  
  removeHandler(args) {
    const { event, handlerID } = args;
    const registeredHandlers = this.#handlerMap.get(event);
    if (!registeredHandlers) { return; }
    const found = registeredHandlers.find(h => h.id === handlerID);
    if (!found) { return; }
    this.#handlerMap.set(event, this.#handlerMap.get(event).filter(h => h.id !== handlerID));
  }
  
  getBackpressureWaiters() { return this.#backpressureWaiters; }
  addBackpressureWaiter() { this.#backpressureWaiters++; }
  removeBackpressureWaiter() {
    this.#backpressureWaiters--;
    if (this.#backpressureWaiters < 0) {
      throw new Error("unexepctedly negative number of backpressure waiters");
    }
  }
  
  parkTaskOnAwaitable(args) {
    if (!args.awaitable) { throw new TypeError('missing awaitable when trying to park'); }
    if (!args.task) { throw new TypeError('missing task when trying to park'); }
    const { awaitable, task } = args;
    
    let taskList = this.#parkedTasks.get(awaitable.id());
    if (!taskList) {
      taskList = [];
      this.#parkedTasks.set(awaitable.id(), taskList);
    }
    taskList.push(task);
    
    this.wakeNextTaskForAwaitable(awaitable);
  }
  
  wakeNextTaskForAwaitable(awaitable) {
    if (!awaitable) { throw new TypeError('missing awaitable when waking next task'); }
    const awaitableID = awaitable.id();
    
    const taskList = this.#parkedTasks.get(awaitableID);
    if (!taskList || taskList.length === 0) {
      _debugLog('[ComponentAsyncState] no tasks waiting for awaitable', { awaitableID: awaitable.id() });
      return;
    }
    
    let task = taskList.shift(); // todo(perf)
    if (!task) { throw new Error('no task in parked list despite previous check'); }
    
    if (!task.awaitableResume) {
      throw new Error('task ready due to awaitable is missing resume', { taskID: task.id(), awaitableID });
    }
    task.awaitableResume();
  }
  
  // TODO: we might want to check for pre-locked status here
  exclusiveLock() {
    this.#locked = true;
  }
  
  exclusiveRelease() {
    _debugLog('[ComponentAsyncState#exclusiveRelease()] releasing', {
      locked: this.#locked,
      componentIdx: this.#componentIdx,
    });
    
    this.#locked = false
  }
  
  isExclusivelyLocked() { return this.#locked === true; }
  
  #getSuspendedTaskMeta(taskID) {
    return this.#suspendedTasksByTaskID.get(taskID);
  }
  
  #removeSuspendedTaskMeta(taskID) {
    _debugLog('[ComponentAsyncState#removeSuspendedTaskMeta()] removing suspended task', { taskID });
    const idx = this.#suspendedTaskIDs.findIndex(t => t === taskID);
    const meta = this.#suspendedTasksByTaskID.get(taskID);
    this.#suspendedTaskIDs[idx] = null;
    this.#suspendedTasksByTaskID.delete(taskID);
    return meta;
  }
  
  #addSuspendedTaskMeta(meta) {
    if (!meta) { throw new Error('missing task meta'); }
    const taskID = meta.taskID;
    this.#suspendedTasksByTaskID.set(taskID, meta);
    this.#suspendedTaskIDs.push(taskID);
    if (this.#suspendedTasksByTaskID.size < this.#suspendedTaskIDs.length - 10) {
      this.#suspendedTaskIDs = this.#suspendedTaskIDs.filter(t => t !== null);
    }
  }
  
  suspendTask(args) {
    // TODO(threads): readyFn is normally on the thread
    const { task, readyFn } = args;
    const taskID = task.id();
    _debugLog('[ComponentAsyncState#suspendTask()]', { taskID });
    
    if (this.#getSuspendedTaskMeta(taskID)) {
      throw new Error('task [' + taskID + '] already suspended');
    }
    
    const { promise, resolve } = Promise.withResolvers();
    this.#addSuspendedTaskMeta({
      task,
      taskID,
      readyFn,
      resume: () => {
        _debugLog('[ComponentAsyncState#suspendTask()] resuming suspended task', { taskID });
        // TODO(threads): it's thread cancellation we should be checking for below, not task
        resolve(!task.isCancelled());
      },
    });
    
    return promise;
  }
  
  resumeTaskByID(taskID) {
    const meta = this.#removeSuspendedTaskMeta(taskID);
    if (!meta) { return; }
    if (meta.taskID !== taskID) { throw new Error('task ID does not match'); }
    meta.resume();
  }
  
  tick() {
    _debugLog('[ComponentAsyncState#tick()]', { suspendedTaskIDs: this.#suspendedTaskIDs });
    let resumedTask = false;
    for (const taskID of this.#suspendedTaskIDs.filter(t => t !== null)) {
      const meta = this.#suspendedTasksByTaskID.get(taskID);
      if (!meta || !meta.readyFn) {
        throw new Error('missing/invalid task despite ID [' + taskID + '] being present');
      }
      if (!meta.readyFn()) { continue; }
      resumedTask = true;
      this.resumeTaskByID(taskID);
    }
    return resumedTask;
  }
  
  addPendingTask(task) {
    this.#pendingTasks.push(task);
  }
}

function _ComponentStateSetAllError() {
  _debugLog('[_ComponentStateSetAllError()]');
  for (const state of ASYNC_STATE.values()) {
    state.setErrored();
  }
}

function _prepareCall(
memoryIdx,
getMemoryFn,
startFn,
returnFn,
callerInstanceIdx,
calleeInstanceIdx,
taskReturnTypeIdx,
isCalleeAsyncInt,
stringEncoding,
resultCountOrAsync,
) {
  _debugLog('[_prepareCall()]', {
    callerInstanceIdx,
    calleeInstanceIdx,
    taskReturnTypeIdx,
    isCalleeAsyncInt,
    stringEncoding,
    resultCountOrAsync,
  });
  const argArray = [...arguments];
  
  // Since Rust will happily pass large u32s over, resultCountOrAsync should be one of:
  // (a) u32 max size     => callee is async fn with no result
  // (b) u32 max size - 1 => callee is async fn with result
  // (c) any other value  => callee is sync with the given result count
  //
  // Due to JS handling the value as 2s complement, the `resultCountOrAsync` ends up being:
  // (a) -1 as u32 max size
  // (b) -2 as u32 max size - 1
  // (c) x
  //
  // Due to JS mishandling the value as 2s complement, the actual values we get are:
  // see. https://github.com/wasm-bindgen/wasm-bindgen/issues/1388
  let isAsync = false;
  let hasResultPointer = false;
  if (resultCountOrAsync === -1) {
    isAsync = true;
    hasResultPointer = false;
  } else if (resultCountOrAsync === -2) {
    isAsync = true;
    hasResultPointer = true;
  }
  
  const currentCallerTaskMeta = getCurrentTask(callerInstanceIdx);
  if (!currentCallerTaskMeta) {
    throw new Error('invalid/missing current task for caller during prepare call');
  }
  
  const currentCallerTask = currentCallerTaskMeta.task;
  if (!currentCallerTask) {
    throw new Error('unexpectedly missing task in meta for caller during prepare call');
  }
  
  if (currentCallerTask.componentIdx() !== callerInstanceIdx) {
    throw new Error(`task component idx [${ currentCallerTask.componentIdx() }] !== [${ callerInstanceIdx }] (callee ${ calleeInstanceIdx })`);
  }
  
  let getCalleeParamsFn;
  let resultPtr = null;
  if (hasResultPointer) {
    const directParamsArr = argArray.slice(11);
    getCalleeParamsFn = () => directParamsArr;
    resultPtr = argArray[10];
  } else {
    const directParamsArr = argArray.slice(10);
    getCalleeParamsFn = () => directParamsArr;
  }
  
  let encoding;
  switch (stringEncoding) {
    case 0:
    encoding = 'utf8';
    break;
    case 1:
    encoding = 'utf16';
    break;
    case 2:
    encoding = 'compact-utf16';
    break;
    default:
    throw new Error(`unrecognized string encoding enum [${stringEncoding}]`);
  }
  
  const [newTask, newTaskID] = createNewCurrentTask({
    componentIdx: calleeInstanceIdx,
    isAsync: isCalleeAsyncInt !== 0,
    getCalleeParamsFn,
    // TODO: find a way to pass the import name through here
    entryFnName: 'task/' + currentCallerTask.id() + '/new-prepare-task',
    stringEncoding,
  });
  
  const subtask = currentCallerTask.createSubtask({
    componentIdx: callerInstanceIdx,
    parentTask: currentCallerTask,
    childTask: newTask,
    callMetadata: {
      memory: getMemoryFn(),
      memoryIdx,
      resultPtr,
      returnFn,
      startFn,
    }
  });
  
  newTask.setParentSubtask(subtask);
  // NOTE: This isn't really a return memory idx for the caller, it's for checking
  // against the task.return (which will be called from the callee)
  newTask.setReturnMemoryIdx(memoryIdx);
}

function _asyncStartCall(args, callee, paramCount, resultCount, flags) {
  const { getCallbackFn, callbackIdx, getPostReturnFn, postReturnIdx } = args;
  _debugLog('[_asyncStartCall()] args', args);
  
  const taskMeta = getCurrentTask(ASYNC_CURRENT_COMPONENT_IDXS.at(-1), ASYNC_CURRENT_TASK_IDS.at(-1));
  if (!taskMeta) { throw new Error('invalid/missing current async task meta during prepare call'); }
  
  const argArray = [...arguments];
  
  // NOTE: at this point we know the current task is the one that was started
  // in PrepareCall, so we *should* be able to pop it back off and be left with
  // the previous task
  const preparedTask = taskMeta.task;
  if (!preparedTask) { throw new Error('unexpectedly missing task in task meta during prepare call'); }
  
  if (resultCount < 0 || resultCount > 1) { throw new Error('invalid/unsupported result count'); }
  
  const callbackFnName = 'callback_' + callbackIdx;
  const callbackFn = getCallbackFn();
  preparedTask.setCallbackFn(callbackFn, callbackFnName);
  preparedTask.setPostReturnFn(getPostReturnFn());
  
  const subtask = preparedTask.getParentSubtask();
  
  if (resultCount < 0 || resultCount > 1) { throw new Error(`unsupported result count [${ resultCount }]`); }
  
  const params = preparedTask.getCalleeParams();
  if (paramCount !== params.length) {
    throw new Error(`unexpected callee param count [${ params.length }], _asyncStartCall invocation expected [${ paramCount }]`);
  }
  
  subtask.setOnProgressFn(() => {
    subtask.setPendingEventFn(() => {
      if (subtask.resolved()) { subtask.deliverResolve(); }
      return {
        code: ASYNC_EVENT_CODE.SUBTASK,
        index: rep,
        result: subtask.getStateNumber(),
      }
    });
  });
  
  const subtaskState = subtask.getStateNumber();
  if (subtaskState < 0 || subtaskState > 2**5) {
    throw new Error('invalid subtask state, out of valid range');
  }
  
  const callerComponentState = getOrCreateAsyncState(subtask.componentIdx());
  const rep = callerComponentState.subtasks.insert(subtask);
  subtask.setRep(rep);
  
  const calleeComponentState = getOrCreateAsyncState(preparedTask.componentIdx());
  const calleeBackpressure = calleeComponentState.hasBackpressure();
  
  // Set up a handler on subtask completion to lower results from the call into the caller's memory region.
  //
  // NOTE: during fused guest->guest calls this handler is triggered, but does not actually perform
  // lowering manually, as fused modules provider helper functions that can
  subtask.registerOnResolveHandler((res) => {
    _debugLog('[_asyncStartCall()] handling subtask result', { res, subtaskID: subtask.id() });
    let subtaskCallMeta = subtask.getCallMetadata();
    
    // NOTE: in the case of guest -> guest async calls, there may be no memory/realloc present,
    // as the host will intermediate the value storage/movement between calls.
    //
    // We can simply take the value and lower it as a parameter
    if (subtaskCallMeta.memory || subtaskCallMeta.realloc) {
      throw new Error("call metadata unexpectedly contains memory/realloc for guest->guest call");
    }
    
    const callerTask = subtask.getParentTask();
    const calleeTask = preparedTask;
    const callerMemoryIdx = callerTask.getReturnMemoryIdx();
    const callerComponentIdx = callerTask.componentIdx();
    
    // If a helper function was provided we are likely in a fused guest->guest call,
    // and the result will be delivered (lift/lowered) via helper function
    if (subtaskCallMeta.returnFn) {
      _debugLog('[_asyncStartCall()] return function present while ahndling subtask result, returning early (skipping lower)');
      return;
    }
    
    // If there is no where to lower the results, exit early
    if (!subtaskCallMeta.resultPtr) {
      _debugLog('[_asyncStartCall()] no result ptr during subtask result handling, returning early (skipping lower)');
      return;
    }
    
    let callerMemory;
    if (callerMemoryIdx) {
      callerMemory = GlobalComponentMemories.getMemory(callerComponentIdx, callerMemoryIdx);
    } else {
      const callerMemories = GlobalComponentMemories.getMemoriesForComponentIdx(callerComponentIdx);
      if (callerMemories.length != 1) { throw new Error(`unsupported amount of caller memories`); }
      callerMemory = callerMemories[0];
    }
    
    if (!callerMemory) {
      throw new Error(`missing memory for to guest->guest call result (subtask [${subtask.id()}])`);
    }
    
    const lowerFns = calleeTask.getReturnLowerFns();
    if (!lowerFns || lowerFns.length === 0) {
      throw new Error(`missing result lower metadata for guest->guests call (subtask [${subtask.id()}])`);
    }
    
    if (lowerFns.length !== 1) {
      throw new Error(`only single result supported for guest->guest calls (subtask [${subtask.id()}])`);
    }
    
    lowerFns[0]({
      realloc: undefined,
      memory: callerMemory,
      vals: [res],
      storagePtr: subtaskCallMeta.resultPtr,
      componentIdx: callerComponentIdx
    });
    
  });
  
  // Build call params
  const subtaskCallMeta = subtask.getCallMetadata();
  let startFnParams = [];
  let calleeParams = [];
  if (subtaskCallMeta.startFn && subtaskCallMeta.resultPtr) {
    // If we're using a fused component start fn  and a result pointer is present,
    // then we need to pass the result pointer and other params to the start fn
    startFnParams.push(subtaskCallMeta.resultPtr, ...params);
  } else {
    // if not we need to pass params to the callee instead
    startFnParams.push(...params);
    calleeParams.push(...params);
  }
  
  preparedTask.registerOnResolveHandler((res) => {
    _debugLog('[_asyncStartCall()] signaling subtask completion due to task completion', {
      childTaskID: preparedTask.id(),
      subtaskID: subtask.id(),
      parentTaskID: subtask.getParentTask().id(),
    });
    subtask.onResolve(res);
  });
  
  // TODO(fix): start fns sometimes produce results, how should they be used?
  // the result should theoretically be used for flat lowering, but fused components do
  // this automatically!
  subtask.onStart({ startFnParams });
  
  _debugLog("[_asyncStartCall()] initial call", {
    task: preparedTask.id(),
    subtaskID: subtask.id(),
    calleeFnName: callee.name,
  });
  
  const callbackResult = callee.apply(null, calleeParams);
  
  _debugLog("[_asyncStartCall()] after initial call", {
    task: preparedTask.id(),
    subtaskID: subtask.id(),
    calleeFnName: callee.name,
  });
  
  const doSubtaskResolve = () => {
    subtask.deliverResolve();
  };
  
  // If a single call resolved the subtask and there is no backpressure in the guest,
  // we can return immediately
  if (subtask.resolved() && !calleeBackpressure) {
    _debugLog("[_asyncStartCall()] instantly resolved", {
      calleeComponentIdx: preparedTask.componentIdx(),
      task: preparedTask.id(),
      subtaskID: subtask.id(),
      callerComponentIdx: subtask.componentIdx(),
    });
    
    // If a fused component return function was specified for the subtask,
    // we've likely already called it during resolution of the task.
    //
    // In this case, we do not want to actually return 2 AKA "RETURNED",
    // but the normal started task state, because the fused component expects to get
    // the waitable + the original subtask state (0 AKA "STARTING")
    //
    if (subtask.getCallMetadata().returnFn) {
      return Number(subtask.waitableRep()) << 4 | subtaskState;
    }
    
    doSubtaskResolve();
    return AsyncSubtask.State.RETURNED;
  }
  
  // Start the (event) driver loop that will resolve the task
  new Promise(async (resolve, reject) => {
    if (subtask.resolved() && calleeBackpressure) {
      await calleeComponentState.waitForBackpressure();
      
      _debugLog("[_asyncStartCall()] instantly resolved after cleared backpressure", {
        calleeComponentIdx: preparedTask.componentIdx(),
        task: preparedTask.id(),
        subtaskID: subtask.id(),
        callerComponentIdx: subtask.componentIdx(),
      });
      return;
    }
    
    const started = await preparedTask.enter();
    if (!started) {
      _debugLog('[_asyncStartCall()] task failed early', {
        taskID: preparedTask.id(),
        subtaskID: subtask.id(),
      });
      throw new Error("task failed to start");
      return;
    }
    
    // TODO: retrieve/pass along actual fn name the callback corresponds to
    // (at least something like `<lifted fn name>_callback`)
    const fnName = [
    '<task ',
    subtask.parentTaskID(),
    '/subtask ',
    subtask.id(),
    '/task ',
    preparedTask.id(),
    '>',
    ].join("");
    
    try {
      _debugLog("[_asyncStartCall()] starting driver loop", { fnName, componentIdx: preparedTask.componentIdx(), });
      await _driverLoop({
        componentState: calleeComponentState,
        task: preparedTask,
        fnName,
        isAsync: true,
        callbackResult,
        resolve,
        reject
      });
    } catch (err) {
      _debugLog("[AsyncStartCall] drive loop call failure", { err });
    }
    
  });
  
  return Number(subtask.waitableRep()) << 4 | subtaskState;
}

function _syncStartCall(callbackIdx) {
  _debugLog('[_syncStartCall()] args', { callbackIdx });
  throw new Error('synchronous start call not implemented!');
}

function promiseWithResolvers() {
  if (Promise.withResolvers) {
    return Promise.withResolvers();
  } else {
    let resolve;
    let reject;
    const promise = new Promise((res, rej) => {
      resolve = res;
      reject = rej;
    });
    return { promise, resolve, reject };
  }
}

const _debugLog = (...args) => {
  if (!globalThis?.process?.env?.JCO_DEBUG) { return; }
  console.debug(...args);
}
const ASYNC_DETERMINISM = 'random';
const _coinFlip = () => { return Math.random() > 0.5; };
const I32_MAX = 2_147_483_647;
const I32_MIN = -2_147_483_648;
const _typeCheckValidI32 = (n) => typeof n === 'number' && n >= I32_MIN && n <= I32_MAX;

const _typeCheckAsyncFn= (f) => {
  return f instanceof ASYNC_FN_CTOR;
};

const ASYNC_FN_CTOR = (async () => {}).constructor;

const base64Compile = str => WebAssembly.compile(typeof Buffer !== 'undefined' ? Buffer.from(str, 'base64') : Uint8Array.from(atob(str), b => b.charCodeAt(0)));

function clampGuest(i, min, max) {
  if (i < min || i > max) throw new TypeError(`must be between ${min} and ${max}`);
  return i;
}

const isNode = typeof process !== 'undefined' && process.versions && process.versions.node;
let _fs;
async function fetchCompile (url) {
  if (isNode) {
    if (!_fs) {
      try {
        _fs = await import(/* webpackIgnore: true */ 'node:fs/promises');
      } catch {
        // Fallback for environments where node:fs/promises is unavailable
      }
    }
    if (_fs) {
      return WebAssembly.compile(await _fs.readFile(url));
    }
  }
  return fetch(url).then(WebAssembly.compileStreaming);
}

const symbolCabiDispose = Symbol.for('cabiDispose');

const symbolRscHandle = Symbol('handle');

const symbolRscRep = Symbol.for('cabiRep');

const symbolDispose = Symbol.dispose || Symbol.for('dispose');

const handleTables = [];

function getErrorPayload(e) {
  if (e && hasOwnProperty.call(e, 'payload')) return e.payload;
  if (e instanceof Error) throw e;
  return e;
}

class RepTable {
  #data = [0, null];
  #target;
  
  constructor(args) {
    if (args?.target) { this.target = args.target }
  }
  
  insert(val) {
    _debugLog('[RepTable#insert()] args', { val, target: this.target });
    const freeIdx = this.#data[0];
    if (freeIdx === 0) {
      this.#data.push(val);
      this.#data.push(null);
      return (this.#data.length >> 1) - 1;
    }
    this.#data[0] = this.#data[freeIdx << 1];
    const placementIdx = freeIdx << 1;
    this.#data[placementIdx] = val;
    this.#data[placementIdx + 1] = null;
    return freeIdx;
  }
  
  get(rep) {
    _debugLog('[RepTable#get()] args', { rep, target: this.target });
    const baseIdx = rep << 1;
    const val = this.#data[baseIdx];
    return val;
  }
  
  contains(rep) {
    _debugLog('[RepTable#contains()] args', { rep, target: this.target });
    const baseIdx = rep << 1;
    return !!this.#data[baseIdx];
  }
  
  remove(rep) {
    _debugLog('[RepTable#remove()] args', { rep, target: this.target });
    if (this.#data.length === 2) { throw new Error('invalid'); }
    
    const baseIdx = rep << 1;
    const val = this.#data[baseIdx];
    if (val === 0) { throw new Error('invalid resource rep (cannot be 0)'); }
    
    this.#data[baseIdx] = this.#data[0];
    this.#data[0] = rep;
    
    return val;
  }
  
  clear() {
    _debugLog('[RepTable#clear()] args', { rep, target: this.target });
    this.#data = [0, null];
  }
}

class Awaitable {
  static _ID = 0n;
  
  #id;
  #promise;
  #resolved = false;
  
  constructor(promise) {
    if (!promise) {
      throw new TypeError('Awaitable must have an interior promise');
    }
    
    if (!('then' in promise) || typeof promise.then !== 'function') {
      throw new Error('missing/invalid promise');
    }
    promise.then(() => this.#resolved  = true);
    this.#promise = promise;
    this.#id = ++Awaitable._ID;
  }
  
  id() { return this.#id; }
  
  resolved() { return this.#resolved; }
  
  then() { return this.#promise.then(...arguments); }
}

const ASYNC_EVENT_CODE = {
  NONE: 0,
  SUBTASK: 1,
  STREAM_READ: 2,
  STREAM_WRITE: 3,
  FUTURE_READ: 4,
  FUTURE_WRITE: 5,
  TASK_CANCELLED: 6,
};

function throwInvalidBool() {
  throw new TypeError('invalid variant discriminant for bool');
}

const hasOwnProperty = Object.prototype.hasOwnProperty;

const instantiateCore = WebAssembly.instantiate;

class GlobalComponentAsyncLowers {
  static map = new Map();
  
  constructor() { throw new Error('GlobalComponentAsyncLowers should not be constructed'); }
  
  static define(args) {
    const { componentIdx, qualifiedImportFn, fn } = args;
    let inner = GlobalComponentAsyncLowers.map.get(componentIdx);
    if (!inner) {
      inner = new Map();
      GlobalComponentAsyncLowers.map.set(componentIdx, inner);
    }
    
    inner.set(qualifiedImportFn, fn);
  }
  
  static lookup(componentIdx, qualifiedImportFn) {
    let inner = GlobalComponentAsyncLowers.map.get(componentIdx);
    if (!inner) {
      inner = new Map();
      GlobalComponentAsyncLowers.map.set(componentIdx, inner);
    }
    
    const found = inner.get(qualifiedImportFn);
    if (found) { return found; }
    
    return (...args) => {
      const [originalFn, ...params] = args;
      return originalFn(...params);
    };
  }
}

class GlobalComponentMemories {
  static map = new Map();
  
  constructor() { throw new Error('GlobalComponentMemories should not be constructed'); }
  
  static save(args) {
    const { idx, componentIdx, memory } = args;
    let inner = GlobalComponentMemories.map.get(componentIdx);
    if (!inner) {
      inner = [];
      GlobalComponentMemories.map.set(componentIdx, inner);
    }
    inner.push({ memory, idx });
  }
  
  static getMemoriesForComponentIdx(componentIdx) {
    const metas = GlobalComponentMemories.map.get(componentIdx);
    return metas.map(meta => meta.memory);
  }
  
  static getMemory(componentIdx, idx) {
    const metas = GlobalComponentMemories.map.get(componentIdx);
    return metas.find(meta => meta.idx === idx)?.memory;
  }
}


let exports0;
let exports1;

let lowered_import_0_metadata = {
  qualifiedImportFn: 'wasi:clocks/monotonic-clock@0.2.0#resolution',
  moduleIdx: null,
};


function trampoline0() {
  _debugLog('[iface="wasi:clocks/monotonic-clock@0.2.0", function="resolution"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = resolution._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'resolution',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  resolution();
  endCurrentTask(0);
  _debugLog('[iface="wasi:clocks/monotonic-clock@0.2.0", function="resolution"][Instruction::Return]', {
    funcName: 'resolution',
    paramCount: 1,
    async: false,
    postReturn: false
  });
  return toUint64(ret);
}


let lowered_import_1_metadata = {
  qualifiedImportFn: 'wasi:clocks/monotonic-clock@0.2.0#now',
  moduleIdx: null,
};


function trampoline1() {
  _debugLog('[iface="wasi:clocks/monotonic-clock@0.2.0", function="now"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = now._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'now',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  now();
  endCurrentTask(0);
  _debugLog('[iface="wasi:clocks/monotonic-clock@0.2.0", function="now"][Instruction::Return]', {
    funcName: 'now',
    paramCount: 1,
    async: false,
    postReturn: false
  });
  return toUint64(ret);
}


let lowered_import_2_metadata = {
  qualifiedImportFn: 'wasi:clocks/monotonic-clock@0.2.0#subscribe-duration',
  moduleIdx: null,
};

const handleTable1 = [T_FLAG, 0];
const captureTable1= new Map();
let captureCnt1 = 0;
handleTables[1] = handleTable1;

function trampoline7(arg0) {
  _debugLog('[iface="wasi:clocks/monotonic-clock@0.2.0", function="subscribe-duration"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = subscribeDuration._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'subscribeDuration',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  subscribeDuration(BigInt.asUintN(64, arg0));
  endCurrentTask(0);
  if (!(ret instanceof Pollable)) {
    throw new TypeError('Resource error: Not a valid "Pollable" resource.');
  }
  var handle0 = ret[symbolRscHandle];
  if (!handle0) {
    const rep = ret[symbolRscRep] || ++captureCnt1;
    captureTable1.set(rep, ret);
    handle0 = rscTableCreateOwn(handleTable1, rep);
  }
  _debugLog('[iface="wasi:clocks/monotonic-clock@0.2.0", function="subscribe-duration"][Instruction::Return]', {
    funcName: 'subscribe-duration',
    paramCount: 1,
    async: false,
    postReturn: false
  });
  return handle0;
}


let lowered_import_3_metadata = {
  qualifiedImportFn: 'wasi:clocks/monotonic-clock@0.2.0#subscribe-instant',
  moduleIdx: null,
};


function trampoline8(arg0) {
  _debugLog('[iface="wasi:clocks/monotonic-clock@0.2.0", function="subscribe-instant"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = subscribeInstant._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'subscribeInstant',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  subscribeInstant(BigInt.asUintN(64, arg0));
  endCurrentTask(0);
  if (!(ret instanceof Pollable)) {
    throw new TypeError('Resource error: Not a valid "Pollable" resource.');
  }
  var handle0 = ret[symbolRscHandle];
  if (!handle0) {
    const rep = ret[symbolRscRep] || ++captureCnt1;
    captureTable1.set(rep, ret);
    handle0 = rscTableCreateOwn(handleTable1, rep);
  }
  _debugLog('[iface="wasi:clocks/monotonic-clock@0.2.0", function="subscribe-instant"][Instruction::Return]', {
    funcName: 'subscribe-instant',
    paramCount: 1,
    async: false,
    postReturn: false
  });
  return handle0;
}


let lowered_import_4_metadata = {
  qualifiedImportFn: 'wasi:io/streams@0.2.0#[method]output-stream.subscribe',
  moduleIdx: null,
};

const handleTable3 = [T_FLAG, 0];
const captureTable3= new Map();
let captureCnt3 = 0;
handleTables[3] = handleTable3;

function trampoline9(arg0) {
  var handle1 = arg0;
  var rep2 = handleTable3[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable3.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(OutputStream.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:io/streams@0.2.0", function="[method]output-stream.subscribe"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.subscribe._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'subscribe',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  rsc0.subscribe();
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  if (!(ret instanceof Pollable)) {
    throw new TypeError('Resource error: Not a valid "Pollable" resource.');
  }
  var handle3 = ret[symbolRscHandle];
  if (!handle3) {
    const rep = ret[symbolRscRep] || ++captureCnt1;
    captureTable1.set(rep, ret);
    handle3 = rscTableCreateOwn(handleTable1, rep);
  }
  _debugLog('[iface="wasi:io/streams@0.2.0", function="[method]output-stream.subscribe"][Instruction::Return]', {
    funcName: '[method]output-stream.subscribe',
    paramCount: 1,
    async: false,
    postReturn: false
  });
  return handle3;
}


let lowered_import_5_metadata = {
  qualifiedImportFn: 'wasi:io/streams@0.2.0#[method]input-stream.subscribe',
  moduleIdx: null,
};

const handleTable2 = [T_FLAG, 0];
const captureTable2= new Map();
let captureCnt2 = 0;
handleTables[2] = handleTable2;

function trampoline10(arg0) {
  var handle1 = arg0;
  var rep2 = handleTable2[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable2.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(InputStream.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:io/streams@0.2.0", function="[method]input-stream.subscribe"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.subscribe._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'subscribe',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  rsc0.subscribe();
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  if (!(ret instanceof Pollable)) {
    throw new TypeError('Resource error: Not a valid "Pollable" resource.');
  }
  var handle3 = ret[symbolRscHandle];
  if (!handle3) {
    const rep = ret[symbolRscRep] || ++captureCnt1;
    captureTable1.set(rep, ret);
    handle3 = rscTableCreateOwn(handleTable1, rep);
  }
  _debugLog('[iface="wasi:io/streams@0.2.0", function="[method]input-stream.subscribe"][Instruction::Return]', {
    funcName: '[method]input-stream.subscribe',
    paramCount: 1,
    async: false,
    postReturn: false
  });
  return handle3;
}


let lowered_import_6_metadata = {
  qualifiedImportFn: 'wasi:cli/stderr@0.2.0#get-stderr',
  moduleIdx: null,
};


function trampoline14() {
  _debugLog('[iface="wasi:cli/stderr@0.2.0", function="get-stderr"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = getStderr._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'getStderr',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  getStderr();
  endCurrentTask(0);
  if (!(ret instanceof OutputStream)) {
    throw new TypeError('Resource error: Not a valid "OutputStream" resource.');
  }
  var handle0 = ret[symbolRscHandle];
  if (!handle0) {
    const rep = ret[symbolRscRep] || ++captureCnt3;
    captureTable3.set(rep, ret);
    handle0 = rscTableCreateOwn(handleTable3, rep);
  }
  _debugLog('[iface="wasi:cli/stderr@0.2.0", function="get-stderr"][Instruction::Return]', {
    funcName: 'get-stderr',
    paramCount: 1,
    async: false,
    postReturn: false
  });
  return handle0;
}


let lowered_import_7_metadata = {
  qualifiedImportFn: 'wasi:cli/exit@0.2.0#exit',
  moduleIdx: null,
};


function trampoline15(arg0) {
  let variant0;
  switch (arg0) {
    case 0: {
      variant0= {
        tag: 'ok',
        val: undefined
      };
      break;
    }
    case 1: {
      variant0= {
        tag: 'err',
        val: undefined
      };
      break;
    }
    default: {
      throw new TypeError('invalid variant discriminant for expected');
    }
  }
  _debugLog('[iface="wasi:cli/exit@0.2.0", function="exit"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = exit._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'exit',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret; exit(variant0);
  endCurrentTask(0);
  _debugLog('[iface="wasi:cli/exit@0.2.0", function="exit"][Instruction::Return]', {
    funcName: 'exit',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_8_metadata = {
  qualifiedImportFn: 'wasi:cli/stdin@0.2.0#get-stdin',
  moduleIdx: null,
};


function trampoline16() {
  _debugLog('[iface="wasi:cli/stdin@0.2.0", function="get-stdin"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = getStdin._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'getStdin',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  getStdin();
  endCurrentTask(0);
  if (!(ret instanceof InputStream)) {
    throw new TypeError('Resource error: Not a valid "InputStream" resource.');
  }
  var handle0 = ret[symbolRscHandle];
  if (!handle0) {
    const rep = ret[symbolRscRep] || ++captureCnt2;
    captureTable2.set(rep, ret);
    handle0 = rscTableCreateOwn(handleTable2, rep);
  }
  _debugLog('[iface="wasi:cli/stdin@0.2.0", function="get-stdin"][Instruction::Return]', {
    funcName: 'get-stdin',
    paramCount: 1,
    async: false,
    postReturn: false
  });
  return handle0;
}


let lowered_import_9_metadata = {
  qualifiedImportFn: 'wasi:cli/stdout@0.2.0#get-stdout',
  moduleIdx: null,
};


function trampoline17() {
  _debugLog('[iface="wasi:cli/stdout@0.2.0", function="get-stdout"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = getStdout._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'getStdout',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  getStdout();
  endCurrentTask(0);
  if (!(ret instanceof OutputStream)) {
    throw new TypeError('Resource error: Not a valid "OutputStream" resource.');
  }
  var handle0 = ret[symbolRscHandle];
  if (!handle0) {
    const rep = ret[symbolRscRep] || ++captureCnt3;
    captureTable3.set(rep, ret);
    handle0 = rscTableCreateOwn(handleTable3, rep);
  }
  _debugLog('[iface="wasi:cli/stdout@0.2.0", function="get-stdout"][Instruction::Return]', {
    funcName: 'get-stdout',
    paramCount: 1,
    async: false,
    postReturn: false
  });
  return handle0;
}

let exports2;
let exports3;

let lowered_import_10_metadata = {
  qualifiedImportFn: 'wasi:io/poll@0.2.0#[method]pollable.ready',
  moduleIdx: null,
};


function trampoline24(arg0) {
  var handle1 = arg0;
  var rep2 = handleTable1[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable1.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Pollable.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:io/poll@0.2.0", function="[method]pollable.ready"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.ready._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'ready',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  rsc0.ready();
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  _debugLog('[iface="wasi:io/poll@0.2.0", function="[method]pollable.ready"][Instruction::Return]', {
    funcName: '[method]pollable.ready',
    paramCount: 1,
    async: false,
    postReturn: false
  });
  return ret ? 1 : 0;
}


let lowered_import_11_metadata = {
  qualifiedImportFn: 'wasi:io/poll@0.2.0#[method]pollable.block',
  moduleIdx: null,
};


function trampoline25(arg0) {
  var handle1 = arg0;
  var rep2 = handleTable1[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable1.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Pollable.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:io/poll@0.2.0", function="[method]pollable.block"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.block._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'block',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret; rsc0.block();
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  _debugLog('[iface="wasi:io/poll@0.2.0", function="[method]pollable.block"][Instruction::Return]', {
    funcName: '[method]pollable.block',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_12_metadata = {
  qualifiedImportFn: 'wasi:filesystem/types@0.2.0#[method]descriptor.is-same-object',
  moduleIdx: null,
};

const handleTable6 = [T_FLAG, 0];
const captureTable6= new Map();
let captureCnt6 = 0;
handleTables[6] = handleTable6;

function trampoline26(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable6.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Descriptor.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  var handle4 = arg1;
  var rep5 = handleTable6[(handle4 << 1) + 1] & ~T_FLAG;
  var rsc3 = captureTable6.get(rep5);
  if (!rsc3) {
    rsc3 = Object.create(Descriptor.prototype);
    Object.defineProperty(rsc3, symbolRscHandle, { writable: true, value: handle4});
    Object.defineProperty(rsc3, symbolRscRep, { writable: true, value: rep5});
  }
  curResourceBorrows.push(rsc3);
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.is-same-object"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.isSameObject._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'isSameObject',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  rsc0.isSameObject(rsc3);
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.is-same-object"][Instruction::Return]', {
    funcName: '[method]descriptor.is-same-object',
    paramCount: 1,
    async: false,
    postReturn: false
  });
  return ret ? 1 : 0;
}


let lowered_import_13_metadata = {
  qualifiedImportFn: 'wasi:sockets/instance-network@0.2.0#instance-network',
  moduleIdx: null,
};

const handleTable8 = [T_FLAG, 0];
const captureTable8= new Map();
let captureCnt8 = 0;
handleTables[8] = handleTable8;

function trampoline27() {
  _debugLog('[iface="wasi:sockets/instance-network@0.2.0", function="instance-network"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = instanceNetwork._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'instanceNetwork',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  instanceNetwork();
  endCurrentTask(0);
  if (!(ret instanceof Network)) {
    throw new TypeError('Resource error: Not a valid "Network" resource.');
  }
  var handle0 = ret[symbolRscHandle];
  if (!handle0) {
    const rep = ret[symbolRscRep] || ++captureCnt8;
    captureTable8.set(rep, ret);
    handle0 = rscTableCreateOwn(handleTable8, rep);
  }
  _debugLog('[iface="wasi:sockets/instance-network@0.2.0", function="instance-network"][Instruction::Return]', {
    funcName: 'instance-network',
    paramCount: 1,
    async: false,
    postReturn: false
  });
  return handle0;
}


let lowered_import_14_metadata = {
  qualifiedImportFn: 'wasi:sockets/udp@0.2.0#[method]udp-socket.address-family',
  moduleIdx: null,
};

const handleTable9 = [T_FLAG, 0];
const captureTable9= new Map();
let captureCnt9 = 0;
handleTables[9] = handleTable9;

function trampoline28(arg0) {
  var handle1 = arg0;
  var rep2 = handleTable9[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable9.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(UdpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/udp@0.2.0", function="[method]udp-socket.address-family"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.addressFamily._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'addressFamily',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  rsc0.addressFamily();
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var val3 = ret;
  let enum3;
  switch (val3) {
    case 'ipv4': {
      enum3 = 0;
      break;
    }
    case 'ipv6': {
      enum3 = 1;
      break;
    }
    default: {
      if ((ret) instanceof Error) {
        console.error(ret);
      }
      
      throw new TypeError(`"${val3}" is not one of the cases of ip-address-family`);
    }
  }
  _debugLog('[iface="wasi:sockets/udp@0.2.0", function="[method]udp-socket.address-family"][Instruction::Return]', {
    funcName: '[method]udp-socket.address-family',
    paramCount: 1,
    async: false,
    postReturn: false
  });
  return enum3;
}


let lowered_import_15_metadata = {
  qualifiedImportFn: 'wasi:sockets/udp@0.2.0#[method]udp-socket.subscribe',
  moduleIdx: null,
};


function trampoline29(arg0) {
  var handle1 = arg0;
  var rep2 = handleTable9[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable9.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(UdpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/udp@0.2.0", function="[method]udp-socket.subscribe"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.subscribe._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'subscribe',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  rsc0.subscribe();
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  if (!(ret instanceof Pollable)) {
    throw new TypeError('Resource error: Not a valid "Pollable" resource.');
  }
  var handle3 = ret[symbolRscHandle];
  if (!handle3) {
    const rep = ret[symbolRscRep] || ++captureCnt1;
    captureTable1.set(rep, ret);
    handle3 = rscTableCreateOwn(handleTable1, rep);
  }
  _debugLog('[iface="wasi:sockets/udp@0.2.0", function="[method]udp-socket.subscribe"][Instruction::Return]', {
    funcName: '[method]udp-socket.subscribe',
    paramCount: 1,
    async: false,
    postReturn: false
  });
  return handle3;
}


let lowered_import_16_metadata = {
  qualifiedImportFn: 'wasi:sockets/udp@0.2.0#[method]incoming-datagram-stream.subscribe',
  moduleIdx: null,
};

const handleTable10 = [T_FLAG, 0];
const captureTable10= new Map();
let captureCnt10 = 0;
handleTables[10] = handleTable10;

function trampoline30(arg0) {
  var handle1 = arg0;
  var rep2 = handleTable10[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable10.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(IncomingDatagramStream.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/udp@0.2.0", function="[method]incoming-datagram-stream.subscribe"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.subscribe._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'subscribe',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  rsc0.subscribe();
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  if (!(ret instanceof Pollable)) {
    throw new TypeError('Resource error: Not a valid "Pollable" resource.');
  }
  var handle3 = ret[symbolRscHandle];
  if (!handle3) {
    const rep = ret[symbolRscRep] || ++captureCnt1;
    captureTable1.set(rep, ret);
    handle3 = rscTableCreateOwn(handleTable1, rep);
  }
  _debugLog('[iface="wasi:sockets/udp@0.2.0", function="[method]incoming-datagram-stream.subscribe"][Instruction::Return]', {
    funcName: '[method]incoming-datagram-stream.subscribe',
    paramCount: 1,
    async: false,
    postReturn: false
  });
  return handle3;
}


let lowered_import_17_metadata = {
  qualifiedImportFn: 'wasi:sockets/udp@0.2.0#[method]outgoing-datagram-stream.subscribe',
  moduleIdx: null,
};

const handleTable11 = [T_FLAG, 0];
const captureTable11= new Map();
let captureCnt11 = 0;
handleTables[11] = handleTable11;

function trampoline31(arg0) {
  var handle1 = arg0;
  var rep2 = handleTable11[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable11.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(OutgoingDatagramStream.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/udp@0.2.0", function="[method]outgoing-datagram-stream.subscribe"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.subscribe._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'subscribe',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  rsc0.subscribe();
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  if (!(ret instanceof Pollable)) {
    throw new TypeError('Resource error: Not a valid "Pollable" resource.');
  }
  var handle3 = ret[symbolRscHandle];
  if (!handle3) {
    const rep = ret[symbolRscRep] || ++captureCnt1;
    captureTable1.set(rep, ret);
    handle3 = rscTableCreateOwn(handleTable1, rep);
  }
  _debugLog('[iface="wasi:sockets/udp@0.2.0", function="[method]outgoing-datagram-stream.subscribe"][Instruction::Return]', {
    funcName: '[method]outgoing-datagram-stream.subscribe',
    paramCount: 1,
    async: false,
    postReturn: false
  });
  return handle3;
}


let lowered_import_18_metadata = {
  qualifiedImportFn: 'wasi:sockets/tcp@0.2.0#[method]tcp-socket.is-listening',
  moduleIdx: null,
};

const handleTable12 = [T_FLAG, 0];
const captureTable12= new Map();
let captureCnt12 = 0;
handleTables[12] = handleTable12;

function trampoline32(arg0) {
  var handle1 = arg0;
  var rep2 = handleTable12[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable12.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(TcpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.is-listening"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.isListening._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'isListening',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  rsc0.isListening();
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.is-listening"][Instruction::Return]', {
    funcName: '[method]tcp-socket.is-listening',
    paramCount: 1,
    async: false,
    postReturn: false
  });
  return ret ? 1 : 0;
}


let lowered_import_19_metadata = {
  qualifiedImportFn: 'wasi:sockets/tcp@0.2.0#[method]tcp-socket.address-family',
  moduleIdx: null,
};


function trampoline33(arg0) {
  var handle1 = arg0;
  var rep2 = handleTable12[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable12.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(TcpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.address-family"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.addressFamily._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'addressFamily',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  rsc0.addressFamily();
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var val3 = ret;
  let enum3;
  switch (val3) {
    case 'ipv4': {
      enum3 = 0;
      break;
    }
    case 'ipv6': {
      enum3 = 1;
      break;
    }
    default: {
      if ((ret) instanceof Error) {
        console.error(ret);
      }
      
      throw new TypeError(`"${val3}" is not one of the cases of ip-address-family`);
    }
  }
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.address-family"][Instruction::Return]', {
    funcName: '[method]tcp-socket.address-family',
    paramCount: 1,
    async: false,
    postReturn: false
  });
  return enum3;
}


let lowered_import_20_metadata = {
  qualifiedImportFn: 'wasi:sockets/tcp@0.2.0#[method]tcp-socket.subscribe',
  moduleIdx: null,
};


function trampoline34(arg0) {
  var handle1 = arg0;
  var rep2 = handleTable12[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable12.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(TcpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.subscribe"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.subscribe._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'subscribe',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  rsc0.subscribe();
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  if (!(ret instanceof Pollable)) {
    throw new TypeError('Resource error: Not a valid "Pollable" resource.');
  }
  var handle3 = ret[symbolRscHandle];
  if (!handle3) {
    const rep = ret[symbolRscRep] || ++captureCnt1;
    captureTable1.set(rep, ret);
    handle3 = rscTableCreateOwn(handleTable1, rep);
  }
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.subscribe"][Instruction::Return]', {
    funcName: '[method]tcp-socket.subscribe',
    paramCount: 1,
    async: false,
    postReturn: false
  });
  return handle3;
}


let lowered_import_21_metadata = {
  qualifiedImportFn: 'wasi:sockets/ip-name-lookup@0.2.0#[method]resolve-address-stream.subscribe',
  moduleIdx: null,
};

const handleTable13 = [T_FLAG, 0];
const captureTable13= new Map();
let captureCnt13 = 0;
handleTables[13] = handleTable13;

function trampoline35(arg0) {
  var handle1 = arg0;
  var rep2 = handleTable13[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable13.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(ResolveAddressStream.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/ip-name-lookup@0.2.0", function="[method]resolve-address-stream.subscribe"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.subscribe._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'subscribe',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  rsc0.subscribe();
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  if (!(ret instanceof Pollable)) {
    throw new TypeError('Resource error: Not a valid "Pollable" resource.');
  }
  var handle3 = ret[symbolRscHandle];
  if (!handle3) {
    const rep = ret[symbolRscRep] || ++captureCnt1;
    captureTable1.set(rep, ret);
    handle3 = rscTableCreateOwn(handleTable1, rep);
  }
  _debugLog('[iface="wasi:sockets/ip-name-lookup@0.2.0", function="[method]resolve-address-stream.subscribe"][Instruction::Return]', {
    funcName: '[method]resolve-address-stream.subscribe',
    paramCount: 1,
    async: false,
    postReturn: false
  });
  return handle3;
}


let lowered_import_22_metadata = {
  qualifiedImportFn: 'wasi:random/random@0.2.0#get-random-u64',
  moduleIdx: null,
};


function trampoline36() {
  _debugLog('[iface="wasi:random/random@0.2.0", function="get-random-u64"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = getRandomU64._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'getRandomU64',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  getRandomU64();
  endCurrentTask(0);
  _debugLog('[iface="wasi:random/random@0.2.0", function="get-random-u64"][Instruction::Return]', {
    funcName: 'get-random-u64',
    paramCount: 1,
    async: false,
    postReturn: false
  });
  return toUint64(ret);
}


let lowered_import_23_metadata = {
  qualifiedImportFn: 'wasi:random/insecure@0.2.0#get-insecure-random-u64',
  moduleIdx: null,
};


function trampoline37() {
  _debugLog('[iface="wasi:random/insecure@0.2.0", function="get-insecure-random-u64"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = getInsecureRandomU64._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'getInsecureRandomU64',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  getInsecureRandomU64();
  endCurrentTask(0);
  _debugLog('[iface="wasi:random/insecure@0.2.0", function="get-insecure-random-u64"][Instruction::Return]', {
    funcName: 'get-insecure-random-u64',
    paramCount: 1,
    async: false,
    postReturn: false
  });
  return toUint64(ret);
}

let exports4;
let exports5;
let exports6;
let exports7;
let exports8;
let exports9;
let exports10;

let lowered_import_24_metadata = {
  qualifiedImportFn: 'eryx:net/tcp@0.1.0#close',
  moduleIdx: null,
};


function trampoline44(arg0) {
  _debugLog('[iface="eryx:net/tcp@0.1.0", function="close"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = close._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'close',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret; close(arg0 >>> 0);
  endCurrentTask(0);
  _debugLog('[iface="eryx:net/tcp@0.1.0", function="close"][Instruction::Return]', {
    funcName: 'close',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_25_metadata = {
  qualifiedImportFn: 'eryx:net/tls@0.1.0#close',
  moduleIdx: null,
};


function trampoline45(arg0) {
  _debugLog('[iface="eryx:net/tls@0.1.0", function="close"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = close$1._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'close$1',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret; close$1(arg0 >>> 0);
  endCurrentTask(0);
  _debugLog('[iface="eryx:net/tls@0.1.0", function="close"][Instruction::Return]', {
    funcName: 'close',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}

let exports11;
let memory0;
let realloc0;
let realloc1;
let realloc2;

let lowered_import_26_metadata = {
  qualifiedImportFn: 'wasi:filesystem/preopens@0.2.0#get-directories',
  moduleIdx: null,
};


function trampoline47(arg0) {
  _debugLog('[iface="wasi:filesystem/preopens@0.2.0", function="get-directories"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = getDirectories._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'getDirectories',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  getDirectories();
  endCurrentTask(0);
  var vec3 = ret;
  var len3 = vec3.length;
  var result3 = realloc0(0, 0, 4, len3 * 12);
  for (let i = 0; i < vec3.length; i++) {
    const e = vec3[i];
    const base = result3 + i * 12;var [tuple0_0, tuple0_1] = e;
    if (!(tuple0_0 instanceof Descriptor)) {
      throw new TypeError('Resource error: Not a valid "Descriptor" resource.');
    }
    var handle1 = tuple0_0[symbolRscHandle];
    if (!handle1) {
      const rep = tuple0_0[symbolRscRep] || ++captureCnt6;
      captureTable6.set(rep, tuple0_0);
      handle1 = rscTableCreateOwn(handleTable6, rep);
    }
    dataView(memory0).setInt32(base + 0, handle1, true);
    
    var encodeRes = _utf8AllocateAndEncode(tuple0_1, realloc0, memory0);
    var ptr2= encodeRes.ptr;
    var len2 = encodeRes.len;
    
    dataView(memory0).setUint32(base + 8, len2, true);
    dataView(memory0).setUint32(base + 4, ptr2, true);
  }
  dataView(memory0).setUint32(arg0 + 4, len3, true);
  dataView(memory0).setUint32(arg0 + 0, result3, true);
  _debugLog('[iface="wasi:filesystem/preopens@0.2.0", function="get-directories"][Instruction::Return]', {
    funcName: 'get-directories',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_27_metadata = {
  qualifiedImportFn: 'wasi:clocks/wall-clock@0.2.0#resolution',
  moduleIdx: null,
};


function trampoline48(arg0) {
  _debugLog('[iface="wasi:clocks/wall-clock@0.2.0", function="resolution"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = resolution$1._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'resolution$1',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  resolution$1();
  endCurrentTask(0);
  var {seconds: v0_0, nanoseconds: v0_1 } = ret;
  dataView(memory0).setBigInt64(arg0 + 0, toUint64(v0_0), true);
  dataView(memory0).setInt32(arg0 + 8, toUint32(v0_1), true);
  _debugLog('[iface="wasi:clocks/wall-clock@0.2.0", function="resolution"][Instruction::Return]', {
    funcName: 'resolution',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_28_metadata = {
  qualifiedImportFn: 'wasi:clocks/wall-clock@0.2.0#now',
  moduleIdx: null,
};


function trampoline49(arg0) {
  _debugLog('[iface="wasi:clocks/wall-clock@0.2.0", function="now"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = now$1._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'now$1',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  now$1();
  endCurrentTask(0);
  var {seconds: v0_0, nanoseconds: v0_1 } = ret;
  dataView(memory0).setBigInt64(arg0 + 0, toUint64(v0_0), true);
  dataView(memory0).setInt32(arg0 + 8, toUint32(v0_1), true);
  _debugLog('[iface="wasi:clocks/wall-clock@0.2.0", function="now"][Instruction::Return]', {
    funcName: 'now',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_29_metadata = {
  qualifiedImportFn: 'wasi:filesystem/types@0.2.0#[method]descriptor.advise',
  moduleIdx: null,
};


function trampoline50(arg0, arg1, arg2, arg3, arg4) {
  var handle1 = arg0;
  var rep2 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable6.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Descriptor.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  let enum3;
  switch (arg3) {
    case 0: {
      enum3 = 'normal';
      break;
    }
    case 1: {
      enum3 = 'sequential';
      break;
    }
    case 2: {
      enum3 = 'random';
      break;
    }
    case 3: {
      enum3 = 'will-need';
      break;
    }
    case 4: {
      enum3 = 'dont-need';
      break;
    }
    case 5: {
      enum3 = 'no-reuse';
      break;
    }
    default: {
      throw new TypeError('invalid discriminant specified for Advice');
    }
  }
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.advise"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.advise._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'advise',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.advise(BigInt.asUintN(64, arg1), BigInt.asUintN(64, arg2), enum3)};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant5 = ret;
  switch (variant5.tag) {
    case 'ok': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg4 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg4 + 0, 1, true);
      var val4 = e;
      let enum4;
      switch (val4) {
        case 'access': {
          enum4 = 0;
          break;
        }
        case 'would-block': {
          enum4 = 1;
          break;
        }
        case 'already': {
          enum4 = 2;
          break;
        }
        case 'bad-descriptor': {
          enum4 = 3;
          break;
        }
        case 'busy': {
          enum4 = 4;
          break;
        }
        case 'deadlock': {
          enum4 = 5;
          break;
        }
        case 'quota': {
          enum4 = 6;
          break;
        }
        case 'exist': {
          enum4 = 7;
          break;
        }
        case 'file-too-large': {
          enum4 = 8;
          break;
        }
        case 'illegal-byte-sequence': {
          enum4 = 9;
          break;
        }
        case 'in-progress': {
          enum4 = 10;
          break;
        }
        case 'interrupted': {
          enum4 = 11;
          break;
        }
        case 'invalid': {
          enum4 = 12;
          break;
        }
        case 'io': {
          enum4 = 13;
          break;
        }
        case 'is-directory': {
          enum4 = 14;
          break;
        }
        case 'loop': {
          enum4 = 15;
          break;
        }
        case 'too-many-links': {
          enum4 = 16;
          break;
        }
        case 'message-size': {
          enum4 = 17;
          break;
        }
        case 'name-too-long': {
          enum4 = 18;
          break;
        }
        case 'no-device': {
          enum4 = 19;
          break;
        }
        case 'no-entry': {
          enum4 = 20;
          break;
        }
        case 'no-lock': {
          enum4 = 21;
          break;
        }
        case 'insufficient-memory': {
          enum4 = 22;
          break;
        }
        case 'insufficient-space': {
          enum4 = 23;
          break;
        }
        case 'not-directory': {
          enum4 = 24;
          break;
        }
        case 'not-empty': {
          enum4 = 25;
          break;
        }
        case 'not-recoverable': {
          enum4 = 26;
          break;
        }
        case 'unsupported': {
          enum4 = 27;
          break;
        }
        case 'no-tty': {
          enum4 = 28;
          break;
        }
        case 'no-such-device': {
          enum4 = 29;
          break;
        }
        case 'overflow': {
          enum4 = 30;
          break;
        }
        case 'not-permitted': {
          enum4 = 31;
          break;
        }
        case 'pipe': {
          enum4 = 32;
          break;
        }
        case 'read-only': {
          enum4 = 33;
          break;
        }
        case 'invalid-seek': {
          enum4 = 34;
          break;
        }
        case 'text-file-busy': {
          enum4 = 35;
          break;
        }
        case 'cross-device': {
          enum4 = 36;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val4}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg4 + 1, enum4, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.advise"][Instruction::Return]', {
    funcName: '[method]descriptor.advise',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_30_metadata = {
  qualifiedImportFn: 'wasi:filesystem/types@0.2.0#[method]descriptor.sync-data',
  moduleIdx: null,
};


function trampoline51(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable6.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Descriptor.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.sync-data"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.syncData._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'syncData',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.syncData()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant4 = ret;
  switch (variant4.tag) {
    case 'ok': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val3 = e;
      let enum3;
      switch (val3) {
        case 'access': {
          enum3 = 0;
          break;
        }
        case 'would-block': {
          enum3 = 1;
          break;
        }
        case 'already': {
          enum3 = 2;
          break;
        }
        case 'bad-descriptor': {
          enum3 = 3;
          break;
        }
        case 'busy': {
          enum3 = 4;
          break;
        }
        case 'deadlock': {
          enum3 = 5;
          break;
        }
        case 'quota': {
          enum3 = 6;
          break;
        }
        case 'exist': {
          enum3 = 7;
          break;
        }
        case 'file-too-large': {
          enum3 = 8;
          break;
        }
        case 'illegal-byte-sequence': {
          enum3 = 9;
          break;
        }
        case 'in-progress': {
          enum3 = 10;
          break;
        }
        case 'interrupted': {
          enum3 = 11;
          break;
        }
        case 'invalid': {
          enum3 = 12;
          break;
        }
        case 'io': {
          enum3 = 13;
          break;
        }
        case 'is-directory': {
          enum3 = 14;
          break;
        }
        case 'loop': {
          enum3 = 15;
          break;
        }
        case 'too-many-links': {
          enum3 = 16;
          break;
        }
        case 'message-size': {
          enum3 = 17;
          break;
        }
        case 'name-too-long': {
          enum3 = 18;
          break;
        }
        case 'no-device': {
          enum3 = 19;
          break;
        }
        case 'no-entry': {
          enum3 = 20;
          break;
        }
        case 'no-lock': {
          enum3 = 21;
          break;
        }
        case 'insufficient-memory': {
          enum3 = 22;
          break;
        }
        case 'insufficient-space': {
          enum3 = 23;
          break;
        }
        case 'not-directory': {
          enum3 = 24;
          break;
        }
        case 'not-empty': {
          enum3 = 25;
          break;
        }
        case 'not-recoverable': {
          enum3 = 26;
          break;
        }
        case 'unsupported': {
          enum3 = 27;
          break;
        }
        case 'no-tty': {
          enum3 = 28;
          break;
        }
        case 'no-such-device': {
          enum3 = 29;
          break;
        }
        case 'overflow': {
          enum3 = 30;
          break;
        }
        case 'not-permitted': {
          enum3 = 31;
          break;
        }
        case 'pipe': {
          enum3 = 32;
          break;
        }
        case 'read-only': {
          enum3 = 33;
          break;
        }
        case 'invalid-seek': {
          enum3 = 34;
          break;
        }
        case 'text-file-busy': {
          enum3 = 35;
          break;
        }
        case 'cross-device': {
          enum3 = 36;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val3}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 1, enum3, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.sync-data"][Instruction::Return]', {
    funcName: '[method]descriptor.sync-data',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_31_metadata = {
  qualifiedImportFn: 'wasi:filesystem/types@0.2.0#[method]descriptor.get-type',
  moduleIdx: null,
};


function trampoline52(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable6.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Descriptor.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.get-type"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.getType._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'getType',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.getType()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant5 = ret;
  switch (variant5.tag) {
    case 'ok': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      var val3 = e;
      let enum3;
      switch (val3) {
        case 'unknown': {
          enum3 = 0;
          break;
        }
        case 'block-device': {
          enum3 = 1;
          break;
        }
        case 'character-device': {
          enum3 = 2;
          break;
        }
        case 'directory': {
          enum3 = 3;
          break;
        }
        case 'fifo': {
          enum3 = 4;
          break;
        }
        case 'symbolic-link': {
          enum3 = 5;
          break;
        }
        case 'regular-file': {
          enum3 = 6;
          break;
        }
        case 'socket': {
          enum3 = 7;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val3}" is not one of the cases of descriptor-type`);
        }
      }
      dataView(memory0).setInt8(arg1 + 1, enum3, true);
      break;
    }
    case 'err': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val4 = e;
      let enum4;
      switch (val4) {
        case 'access': {
          enum4 = 0;
          break;
        }
        case 'would-block': {
          enum4 = 1;
          break;
        }
        case 'already': {
          enum4 = 2;
          break;
        }
        case 'bad-descriptor': {
          enum4 = 3;
          break;
        }
        case 'busy': {
          enum4 = 4;
          break;
        }
        case 'deadlock': {
          enum4 = 5;
          break;
        }
        case 'quota': {
          enum4 = 6;
          break;
        }
        case 'exist': {
          enum4 = 7;
          break;
        }
        case 'file-too-large': {
          enum4 = 8;
          break;
        }
        case 'illegal-byte-sequence': {
          enum4 = 9;
          break;
        }
        case 'in-progress': {
          enum4 = 10;
          break;
        }
        case 'interrupted': {
          enum4 = 11;
          break;
        }
        case 'invalid': {
          enum4 = 12;
          break;
        }
        case 'io': {
          enum4 = 13;
          break;
        }
        case 'is-directory': {
          enum4 = 14;
          break;
        }
        case 'loop': {
          enum4 = 15;
          break;
        }
        case 'too-many-links': {
          enum4 = 16;
          break;
        }
        case 'message-size': {
          enum4 = 17;
          break;
        }
        case 'name-too-long': {
          enum4 = 18;
          break;
        }
        case 'no-device': {
          enum4 = 19;
          break;
        }
        case 'no-entry': {
          enum4 = 20;
          break;
        }
        case 'no-lock': {
          enum4 = 21;
          break;
        }
        case 'insufficient-memory': {
          enum4 = 22;
          break;
        }
        case 'insufficient-space': {
          enum4 = 23;
          break;
        }
        case 'not-directory': {
          enum4 = 24;
          break;
        }
        case 'not-empty': {
          enum4 = 25;
          break;
        }
        case 'not-recoverable': {
          enum4 = 26;
          break;
        }
        case 'unsupported': {
          enum4 = 27;
          break;
        }
        case 'no-tty': {
          enum4 = 28;
          break;
        }
        case 'no-such-device': {
          enum4 = 29;
          break;
        }
        case 'overflow': {
          enum4 = 30;
          break;
        }
        case 'not-permitted': {
          enum4 = 31;
          break;
        }
        case 'pipe': {
          enum4 = 32;
          break;
        }
        case 'read-only': {
          enum4 = 33;
          break;
        }
        case 'invalid-seek': {
          enum4 = 34;
          break;
        }
        case 'text-file-busy': {
          enum4 = 35;
          break;
        }
        case 'cross-device': {
          enum4 = 36;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val4}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 1, enum4, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.get-type"][Instruction::Return]', {
    funcName: '[method]descriptor.get-type',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_32_metadata = {
  qualifiedImportFn: 'wasi:filesystem/types@0.2.0#[method]descriptor.set-size',
  moduleIdx: null,
};


function trampoline53(arg0, arg1, arg2) {
  var handle1 = arg0;
  var rep2 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable6.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Descriptor.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.set-size"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.setSize._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'setSize',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.setSize(BigInt.asUintN(64, arg1))};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant4 = ret;
  switch (variant4.tag) {
    case 'ok': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg2 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg2 + 0, 1, true);
      var val3 = e;
      let enum3;
      switch (val3) {
        case 'access': {
          enum3 = 0;
          break;
        }
        case 'would-block': {
          enum3 = 1;
          break;
        }
        case 'already': {
          enum3 = 2;
          break;
        }
        case 'bad-descriptor': {
          enum3 = 3;
          break;
        }
        case 'busy': {
          enum3 = 4;
          break;
        }
        case 'deadlock': {
          enum3 = 5;
          break;
        }
        case 'quota': {
          enum3 = 6;
          break;
        }
        case 'exist': {
          enum3 = 7;
          break;
        }
        case 'file-too-large': {
          enum3 = 8;
          break;
        }
        case 'illegal-byte-sequence': {
          enum3 = 9;
          break;
        }
        case 'in-progress': {
          enum3 = 10;
          break;
        }
        case 'interrupted': {
          enum3 = 11;
          break;
        }
        case 'invalid': {
          enum3 = 12;
          break;
        }
        case 'io': {
          enum3 = 13;
          break;
        }
        case 'is-directory': {
          enum3 = 14;
          break;
        }
        case 'loop': {
          enum3 = 15;
          break;
        }
        case 'too-many-links': {
          enum3 = 16;
          break;
        }
        case 'message-size': {
          enum3 = 17;
          break;
        }
        case 'name-too-long': {
          enum3 = 18;
          break;
        }
        case 'no-device': {
          enum3 = 19;
          break;
        }
        case 'no-entry': {
          enum3 = 20;
          break;
        }
        case 'no-lock': {
          enum3 = 21;
          break;
        }
        case 'insufficient-memory': {
          enum3 = 22;
          break;
        }
        case 'insufficient-space': {
          enum3 = 23;
          break;
        }
        case 'not-directory': {
          enum3 = 24;
          break;
        }
        case 'not-empty': {
          enum3 = 25;
          break;
        }
        case 'not-recoverable': {
          enum3 = 26;
          break;
        }
        case 'unsupported': {
          enum3 = 27;
          break;
        }
        case 'no-tty': {
          enum3 = 28;
          break;
        }
        case 'no-such-device': {
          enum3 = 29;
          break;
        }
        case 'overflow': {
          enum3 = 30;
          break;
        }
        case 'not-permitted': {
          enum3 = 31;
          break;
        }
        case 'pipe': {
          enum3 = 32;
          break;
        }
        case 'read-only': {
          enum3 = 33;
          break;
        }
        case 'invalid-seek': {
          enum3 = 34;
          break;
        }
        case 'text-file-busy': {
          enum3 = 35;
          break;
        }
        case 'cross-device': {
          enum3 = 36;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val3}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg2 + 1, enum3, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.set-size"][Instruction::Return]', {
    funcName: '[method]descriptor.set-size',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_33_metadata = {
  qualifiedImportFn: 'wasi:filesystem/types@0.2.0#[method]descriptor.write',
  moduleIdx: null,
};


function trampoline54(arg0, arg1, arg2, arg3, arg4) {
  var handle1 = arg0;
  var rep2 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable6.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Descriptor.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  var ptr3 = arg1;
  var len3 = arg2;
  var result3 = new Uint8Array(memory0.buffer.slice(ptr3, ptr3 + len3 * 1));
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.write"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.write._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'write',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.write(result3, BigInt.asUintN(64, arg3))};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant5 = ret;
  switch (variant5.tag) {
    case 'ok': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg4 + 0, 0, true);
      dataView(memory0).setBigInt64(arg4 + 8, toUint64(e), true);
      break;
    }
    case 'err': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg4 + 0, 1, true);
      var val4 = e;
      let enum4;
      switch (val4) {
        case 'access': {
          enum4 = 0;
          break;
        }
        case 'would-block': {
          enum4 = 1;
          break;
        }
        case 'already': {
          enum4 = 2;
          break;
        }
        case 'bad-descriptor': {
          enum4 = 3;
          break;
        }
        case 'busy': {
          enum4 = 4;
          break;
        }
        case 'deadlock': {
          enum4 = 5;
          break;
        }
        case 'quota': {
          enum4 = 6;
          break;
        }
        case 'exist': {
          enum4 = 7;
          break;
        }
        case 'file-too-large': {
          enum4 = 8;
          break;
        }
        case 'illegal-byte-sequence': {
          enum4 = 9;
          break;
        }
        case 'in-progress': {
          enum4 = 10;
          break;
        }
        case 'interrupted': {
          enum4 = 11;
          break;
        }
        case 'invalid': {
          enum4 = 12;
          break;
        }
        case 'io': {
          enum4 = 13;
          break;
        }
        case 'is-directory': {
          enum4 = 14;
          break;
        }
        case 'loop': {
          enum4 = 15;
          break;
        }
        case 'too-many-links': {
          enum4 = 16;
          break;
        }
        case 'message-size': {
          enum4 = 17;
          break;
        }
        case 'name-too-long': {
          enum4 = 18;
          break;
        }
        case 'no-device': {
          enum4 = 19;
          break;
        }
        case 'no-entry': {
          enum4 = 20;
          break;
        }
        case 'no-lock': {
          enum4 = 21;
          break;
        }
        case 'insufficient-memory': {
          enum4 = 22;
          break;
        }
        case 'insufficient-space': {
          enum4 = 23;
          break;
        }
        case 'not-directory': {
          enum4 = 24;
          break;
        }
        case 'not-empty': {
          enum4 = 25;
          break;
        }
        case 'not-recoverable': {
          enum4 = 26;
          break;
        }
        case 'unsupported': {
          enum4 = 27;
          break;
        }
        case 'no-tty': {
          enum4 = 28;
          break;
        }
        case 'no-such-device': {
          enum4 = 29;
          break;
        }
        case 'overflow': {
          enum4 = 30;
          break;
        }
        case 'not-permitted': {
          enum4 = 31;
          break;
        }
        case 'pipe': {
          enum4 = 32;
          break;
        }
        case 'read-only': {
          enum4 = 33;
          break;
        }
        case 'invalid-seek': {
          enum4 = 34;
          break;
        }
        case 'text-file-busy': {
          enum4 = 35;
          break;
        }
        case 'cross-device': {
          enum4 = 36;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val4}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg4 + 8, enum4, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.write"][Instruction::Return]', {
    funcName: '[method]descriptor.write',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_34_metadata = {
  qualifiedImportFn: 'wasi:filesystem/types@0.2.0#filesystem-error-code',
  moduleIdx: null,
};

const handleTable0 = [T_FLAG, 0];
const captureTable0= new Map();
let captureCnt0 = 0;
handleTables[0] = handleTable0;

function trampoline55(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable0[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable0.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Error$1.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="filesystem-error-code"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = filesystemErrorCode._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'filesystemErrorCode',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  filesystemErrorCode(rsc0);
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant4 = ret;
  if (variant4 === null || variant4=== undefined) {
    dataView(memory0).setInt8(arg1 + 0, 0, true);
  } else {
    const e = variant4;
    dataView(memory0).setInt8(arg1 + 0, 1, true);
    var val3 = e;
    let enum3;
    switch (val3) {
      case 'access': {
        enum3 = 0;
        break;
      }
      case 'would-block': {
        enum3 = 1;
        break;
      }
      case 'already': {
        enum3 = 2;
        break;
      }
      case 'bad-descriptor': {
        enum3 = 3;
        break;
      }
      case 'busy': {
        enum3 = 4;
        break;
      }
      case 'deadlock': {
        enum3 = 5;
        break;
      }
      case 'quota': {
        enum3 = 6;
        break;
      }
      case 'exist': {
        enum3 = 7;
        break;
      }
      case 'file-too-large': {
        enum3 = 8;
        break;
      }
      case 'illegal-byte-sequence': {
        enum3 = 9;
        break;
      }
      case 'in-progress': {
        enum3 = 10;
        break;
      }
      case 'interrupted': {
        enum3 = 11;
        break;
      }
      case 'invalid': {
        enum3 = 12;
        break;
      }
      case 'io': {
        enum3 = 13;
        break;
      }
      case 'is-directory': {
        enum3 = 14;
        break;
      }
      case 'loop': {
        enum3 = 15;
        break;
      }
      case 'too-many-links': {
        enum3 = 16;
        break;
      }
      case 'message-size': {
        enum3 = 17;
        break;
      }
      case 'name-too-long': {
        enum3 = 18;
        break;
      }
      case 'no-device': {
        enum3 = 19;
        break;
      }
      case 'no-entry': {
        enum3 = 20;
        break;
      }
      case 'no-lock': {
        enum3 = 21;
        break;
      }
      case 'insufficient-memory': {
        enum3 = 22;
        break;
      }
      case 'insufficient-space': {
        enum3 = 23;
        break;
      }
      case 'not-directory': {
        enum3 = 24;
        break;
      }
      case 'not-empty': {
        enum3 = 25;
        break;
      }
      case 'not-recoverable': {
        enum3 = 26;
        break;
      }
      case 'unsupported': {
        enum3 = 27;
        break;
      }
      case 'no-tty': {
        enum3 = 28;
        break;
      }
      case 'no-such-device': {
        enum3 = 29;
        break;
      }
      case 'overflow': {
        enum3 = 30;
        break;
      }
      case 'not-permitted': {
        enum3 = 31;
        break;
      }
      case 'pipe': {
        enum3 = 32;
        break;
      }
      case 'read-only': {
        enum3 = 33;
        break;
      }
      case 'invalid-seek': {
        enum3 = 34;
        break;
      }
      case 'text-file-busy': {
        enum3 = 35;
        break;
      }
      case 'cross-device': {
        enum3 = 36;
        break;
      }
      default: {
        if ((e) instanceof Error) {
          console.error(e);
        }
        
        throw new TypeError(`"${val3}" is not one of the cases of error-code`);
      }
    }
    dataView(memory0).setInt8(arg1 + 1, enum3, true);
  }
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="filesystem-error-code"][Instruction::Return]', {
    funcName: 'filesystem-error-code',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_35_metadata = {
  qualifiedImportFn: 'wasi:filesystem/types@0.2.0#[method]descriptor.read-directory',
  moduleIdx: null,
};

const handleTable7 = [T_FLAG, 0];
const captureTable7= new Map();
let captureCnt7 = 0;
handleTables[7] = handleTable7;

function trampoline56(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable6.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Descriptor.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.read-directory"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.readDirectory._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'readDirectory',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.readDirectory()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant5 = ret;
  switch (variant5.tag) {
    case 'ok': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      if (!(e instanceof DirectoryEntryStream)) {
        throw new TypeError('Resource error: Not a valid "DirectoryEntryStream" resource.');
      }
      var handle3 = e[symbolRscHandle];
      if (!handle3) {
        const rep = e[symbolRscRep] || ++captureCnt7;
        captureTable7.set(rep, e);
        handle3 = rscTableCreateOwn(handleTable7, rep);
      }
      dataView(memory0).setInt32(arg1 + 4, handle3, true);
      break;
    }
    case 'err': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val4 = e;
      let enum4;
      switch (val4) {
        case 'access': {
          enum4 = 0;
          break;
        }
        case 'would-block': {
          enum4 = 1;
          break;
        }
        case 'already': {
          enum4 = 2;
          break;
        }
        case 'bad-descriptor': {
          enum4 = 3;
          break;
        }
        case 'busy': {
          enum4 = 4;
          break;
        }
        case 'deadlock': {
          enum4 = 5;
          break;
        }
        case 'quota': {
          enum4 = 6;
          break;
        }
        case 'exist': {
          enum4 = 7;
          break;
        }
        case 'file-too-large': {
          enum4 = 8;
          break;
        }
        case 'illegal-byte-sequence': {
          enum4 = 9;
          break;
        }
        case 'in-progress': {
          enum4 = 10;
          break;
        }
        case 'interrupted': {
          enum4 = 11;
          break;
        }
        case 'invalid': {
          enum4 = 12;
          break;
        }
        case 'io': {
          enum4 = 13;
          break;
        }
        case 'is-directory': {
          enum4 = 14;
          break;
        }
        case 'loop': {
          enum4 = 15;
          break;
        }
        case 'too-many-links': {
          enum4 = 16;
          break;
        }
        case 'message-size': {
          enum4 = 17;
          break;
        }
        case 'name-too-long': {
          enum4 = 18;
          break;
        }
        case 'no-device': {
          enum4 = 19;
          break;
        }
        case 'no-entry': {
          enum4 = 20;
          break;
        }
        case 'no-lock': {
          enum4 = 21;
          break;
        }
        case 'insufficient-memory': {
          enum4 = 22;
          break;
        }
        case 'insufficient-space': {
          enum4 = 23;
          break;
        }
        case 'not-directory': {
          enum4 = 24;
          break;
        }
        case 'not-empty': {
          enum4 = 25;
          break;
        }
        case 'not-recoverable': {
          enum4 = 26;
          break;
        }
        case 'unsupported': {
          enum4 = 27;
          break;
        }
        case 'no-tty': {
          enum4 = 28;
          break;
        }
        case 'no-such-device': {
          enum4 = 29;
          break;
        }
        case 'overflow': {
          enum4 = 30;
          break;
        }
        case 'not-permitted': {
          enum4 = 31;
          break;
        }
        case 'pipe': {
          enum4 = 32;
          break;
        }
        case 'read-only': {
          enum4 = 33;
          break;
        }
        case 'invalid-seek': {
          enum4 = 34;
          break;
        }
        case 'text-file-busy': {
          enum4 = 35;
          break;
        }
        case 'cross-device': {
          enum4 = 36;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val4}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 4, enum4, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.read-directory"][Instruction::Return]', {
    funcName: '[method]descriptor.read-directory',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_36_metadata = {
  qualifiedImportFn: 'wasi:filesystem/types@0.2.0#[method]descriptor.sync',
  moduleIdx: null,
};


function trampoline57(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable6.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Descriptor.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.sync"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.sync._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'sync',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.sync()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant4 = ret;
  switch (variant4.tag) {
    case 'ok': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val3 = e;
      let enum3;
      switch (val3) {
        case 'access': {
          enum3 = 0;
          break;
        }
        case 'would-block': {
          enum3 = 1;
          break;
        }
        case 'already': {
          enum3 = 2;
          break;
        }
        case 'bad-descriptor': {
          enum3 = 3;
          break;
        }
        case 'busy': {
          enum3 = 4;
          break;
        }
        case 'deadlock': {
          enum3 = 5;
          break;
        }
        case 'quota': {
          enum3 = 6;
          break;
        }
        case 'exist': {
          enum3 = 7;
          break;
        }
        case 'file-too-large': {
          enum3 = 8;
          break;
        }
        case 'illegal-byte-sequence': {
          enum3 = 9;
          break;
        }
        case 'in-progress': {
          enum3 = 10;
          break;
        }
        case 'interrupted': {
          enum3 = 11;
          break;
        }
        case 'invalid': {
          enum3 = 12;
          break;
        }
        case 'io': {
          enum3 = 13;
          break;
        }
        case 'is-directory': {
          enum3 = 14;
          break;
        }
        case 'loop': {
          enum3 = 15;
          break;
        }
        case 'too-many-links': {
          enum3 = 16;
          break;
        }
        case 'message-size': {
          enum3 = 17;
          break;
        }
        case 'name-too-long': {
          enum3 = 18;
          break;
        }
        case 'no-device': {
          enum3 = 19;
          break;
        }
        case 'no-entry': {
          enum3 = 20;
          break;
        }
        case 'no-lock': {
          enum3 = 21;
          break;
        }
        case 'insufficient-memory': {
          enum3 = 22;
          break;
        }
        case 'insufficient-space': {
          enum3 = 23;
          break;
        }
        case 'not-directory': {
          enum3 = 24;
          break;
        }
        case 'not-empty': {
          enum3 = 25;
          break;
        }
        case 'not-recoverable': {
          enum3 = 26;
          break;
        }
        case 'unsupported': {
          enum3 = 27;
          break;
        }
        case 'no-tty': {
          enum3 = 28;
          break;
        }
        case 'no-such-device': {
          enum3 = 29;
          break;
        }
        case 'overflow': {
          enum3 = 30;
          break;
        }
        case 'not-permitted': {
          enum3 = 31;
          break;
        }
        case 'pipe': {
          enum3 = 32;
          break;
        }
        case 'read-only': {
          enum3 = 33;
          break;
        }
        case 'invalid-seek': {
          enum3 = 34;
          break;
        }
        case 'text-file-busy': {
          enum3 = 35;
          break;
        }
        case 'cross-device': {
          enum3 = 36;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val3}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 1, enum3, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.sync"][Instruction::Return]', {
    funcName: '[method]descriptor.sync',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_37_metadata = {
  qualifiedImportFn: 'wasi:filesystem/types@0.2.0#[method]descriptor.create-directory-at',
  moduleIdx: null,
};


function trampoline58(arg0, arg1, arg2, arg3) {
  var handle1 = arg0;
  var rep2 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable6.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Descriptor.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  var ptr3 = arg1;
  var len3 = arg2;
  var result3 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr3, len3));
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.create-directory-at"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.createDirectoryAt._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'createDirectoryAt',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.createDirectoryAt(result3)};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant5 = ret;
  switch (variant5.tag) {
    case 'ok': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg3 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg3 + 0, 1, true);
      var val4 = e;
      let enum4;
      switch (val4) {
        case 'access': {
          enum4 = 0;
          break;
        }
        case 'would-block': {
          enum4 = 1;
          break;
        }
        case 'already': {
          enum4 = 2;
          break;
        }
        case 'bad-descriptor': {
          enum4 = 3;
          break;
        }
        case 'busy': {
          enum4 = 4;
          break;
        }
        case 'deadlock': {
          enum4 = 5;
          break;
        }
        case 'quota': {
          enum4 = 6;
          break;
        }
        case 'exist': {
          enum4 = 7;
          break;
        }
        case 'file-too-large': {
          enum4 = 8;
          break;
        }
        case 'illegal-byte-sequence': {
          enum4 = 9;
          break;
        }
        case 'in-progress': {
          enum4 = 10;
          break;
        }
        case 'interrupted': {
          enum4 = 11;
          break;
        }
        case 'invalid': {
          enum4 = 12;
          break;
        }
        case 'io': {
          enum4 = 13;
          break;
        }
        case 'is-directory': {
          enum4 = 14;
          break;
        }
        case 'loop': {
          enum4 = 15;
          break;
        }
        case 'too-many-links': {
          enum4 = 16;
          break;
        }
        case 'message-size': {
          enum4 = 17;
          break;
        }
        case 'name-too-long': {
          enum4 = 18;
          break;
        }
        case 'no-device': {
          enum4 = 19;
          break;
        }
        case 'no-entry': {
          enum4 = 20;
          break;
        }
        case 'no-lock': {
          enum4 = 21;
          break;
        }
        case 'insufficient-memory': {
          enum4 = 22;
          break;
        }
        case 'insufficient-space': {
          enum4 = 23;
          break;
        }
        case 'not-directory': {
          enum4 = 24;
          break;
        }
        case 'not-empty': {
          enum4 = 25;
          break;
        }
        case 'not-recoverable': {
          enum4 = 26;
          break;
        }
        case 'unsupported': {
          enum4 = 27;
          break;
        }
        case 'no-tty': {
          enum4 = 28;
          break;
        }
        case 'no-such-device': {
          enum4 = 29;
          break;
        }
        case 'overflow': {
          enum4 = 30;
          break;
        }
        case 'not-permitted': {
          enum4 = 31;
          break;
        }
        case 'pipe': {
          enum4 = 32;
          break;
        }
        case 'read-only': {
          enum4 = 33;
          break;
        }
        case 'invalid-seek': {
          enum4 = 34;
          break;
        }
        case 'text-file-busy': {
          enum4 = 35;
          break;
        }
        case 'cross-device': {
          enum4 = 36;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val4}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg3 + 1, enum4, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.create-directory-at"][Instruction::Return]', {
    funcName: '[method]descriptor.create-directory-at',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_38_metadata = {
  qualifiedImportFn: 'wasi:filesystem/types@0.2.0#[method]descriptor.remove-directory-at',
  moduleIdx: null,
};


function trampoline59(arg0, arg1, arg2, arg3) {
  var handle1 = arg0;
  var rep2 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable6.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Descriptor.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  var ptr3 = arg1;
  var len3 = arg2;
  var result3 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr3, len3));
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.remove-directory-at"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.removeDirectoryAt._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'removeDirectoryAt',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.removeDirectoryAt(result3)};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant5 = ret;
  switch (variant5.tag) {
    case 'ok': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg3 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg3 + 0, 1, true);
      var val4 = e;
      let enum4;
      switch (val4) {
        case 'access': {
          enum4 = 0;
          break;
        }
        case 'would-block': {
          enum4 = 1;
          break;
        }
        case 'already': {
          enum4 = 2;
          break;
        }
        case 'bad-descriptor': {
          enum4 = 3;
          break;
        }
        case 'busy': {
          enum4 = 4;
          break;
        }
        case 'deadlock': {
          enum4 = 5;
          break;
        }
        case 'quota': {
          enum4 = 6;
          break;
        }
        case 'exist': {
          enum4 = 7;
          break;
        }
        case 'file-too-large': {
          enum4 = 8;
          break;
        }
        case 'illegal-byte-sequence': {
          enum4 = 9;
          break;
        }
        case 'in-progress': {
          enum4 = 10;
          break;
        }
        case 'interrupted': {
          enum4 = 11;
          break;
        }
        case 'invalid': {
          enum4 = 12;
          break;
        }
        case 'io': {
          enum4 = 13;
          break;
        }
        case 'is-directory': {
          enum4 = 14;
          break;
        }
        case 'loop': {
          enum4 = 15;
          break;
        }
        case 'too-many-links': {
          enum4 = 16;
          break;
        }
        case 'message-size': {
          enum4 = 17;
          break;
        }
        case 'name-too-long': {
          enum4 = 18;
          break;
        }
        case 'no-device': {
          enum4 = 19;
          break;
        }
        case 'no-entry': {
          enum4 = 20;
          break;
        }
        case 'no-lock': {
          enum4 = 21;
          break;
        }
        case 'insufficient-memory': {
          enum4 = 22;
          break;
        }
        case 'insufficient-space': {
          enum4 = 23;
          break;
        }
        case 'not-directory': {
          enum4 = 24;
          break;
        }
        case 'not-empty': {
          enum4 = 25;
          break;
        }
        case 'not-recoverable': {
          enum4 = 26;
          break;
        }
        case 'unsupported': {
          enum4 = 27;
          break;
        }
        case 'no-tty': {
          enum4 = 28;
          break;
        }
        case 'no-such-device': {
          enum4 = 29;
          break;
        }
        case 'overflow': {
          enum4 = 30;
          break;
        }
        case 'not-permitted': {
          enum4 = 31;
          break;
        }
        case 'pipe': {
          enum4 = 32;
          break;
        }
        case 'read-only': {
          enum4 = 33;
          break;
        }
        case 'invalid-seek': {
          enum4 = 34;
          break;
        }
        case 'text-file-busy': {
          enum4 = 35;
          break;
        }
        case 'cross-device': {
          enum4 = 36;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val4}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg3 + 1, enum4, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.remove-directory-at"][Instruction::Return]', {
    funcName: '[method]descriptor.remove-directory-at',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_39_metadata = {
  qualifiedImportFn: 'wasi:filesystem/types@0.2.0#[method]descriptor.rename-at',
  moduleIdx: null,
};


function trampoline60(arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
  var handle1 = arg0;
  var rep2 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable6.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Descriptor.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  var ptr3 = arg1;
  var len3 = arg2;
  var result3 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr3, len3));
  var handle5 = arg3;
  var rep6 = handleTable6[(handle5 << 1) + 1] & ~T_FLAG;
  var rsc4 = captureTable6.get(rep6);
  if (!rsc4) {
    rsc4 = Object.create(Descriptor.prototype);
    Object.defineProperty(rsc4, symbolRscHandle, { writable: true, value: handle5});
    Object.defineProperty(rsc4, symbolRscRep, { writable: true, value: rep6});
  }
  curResourceBorrows.push(rsc4);
  var ptr7 = arg4;
  var len7 = arg5;
  var result7 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr7, len7));
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.rename-at"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.renameAt._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'renameAt',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.renameAt(result3, rsc4, result7)};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant9 = ret;
  switch (variant9.tag) {
    case 'ok': {
      const e = variant9.val;
      dataView(memory0).setInt8(arg6 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant9.val;
      dataView(memory0).setInt8(arg6 + 0, 1, true);
      var val8 = e;
      let enum8;
      switch (val8) {
        case 'access': {
          enum8 = 0;
          break;
        }
        case 'would-block': {
          enum8 = 1;
          break;
        }
        case 'already': {
          enum8 = 2;
          break;
        }
        case 'bad-descriptor': {
          enum8 = 3;
          break;
        }
        case 'busy': {
          enum8 = 4;
          break;
        }
        case 'deadlock': {
          enum8 = 5;
          break;
        }
        case 'quota': {
          enum8 = 6;
          break;
        }
        case 'exist': {
          enum8 = 7;
          break;
        }
        case 'file-too-large': {
          enum8 = 8;
          break;
        }
        case 'illegal-byte-sequence': {
          enum8 = 9;
          break;
        }
        case 'in-progress': {
          enum8 = 10;
          break;
        }
        case 'interrupted': {
          enum8 = 11;
          break;
        }
        case 'invalid': {
          enum8 = 12;
          break;
        }
        case 'io': {
          enum8 = 13;
          break;
        }
        case 'is-directory': {
          enum8 = 14;
          break;
        }
        case 'loop': {
          enum8 = 15;
          break;
        }
        case 'too-many-links': {
          enum8 = 16;
          break;
        }
        case 'message-size': {
          enum8 = 17;
          break;
        }
        case 'name-too-long': {
          enum8 = 18;
          break;
        }
        case 'no-device': {
          enum8 = 19;
          break;
        }
        case 'no-entry': {
          enum8 = 20;
          break;
        }
        case 'no-lock': {
          enum8 = 21;
          break;
        }
        case 'insufficient-memory': {
          enum8 = 22;
          break;
        }
        case 'insufficient-space': {
          enum8 = 23;
          break;
        }
        case 'not-directory': {
          enum8 = 24;
          break;
        }
        case 'not-empty': {
          enum8 = 25;
          break;
        }
        case 'not-recoverable': {
          enum8 = 26;
          break;
        }
        case 'unsupported': {
          enum8 = 27;
          break;
        }
        case 'no-tty': {
          enum8 = 28;
          break;
        }
        case 'no-such-device': {
          enum8 = 29;
          break;
        }
        case 'overflow': {
          enum8 = 30;
          break;
        }
        case 'not-permitted': {
          enum8 = 31;
          break;
        }
        case 'pipe': {
          enum8 = 32;
          break;
        }
        case 'read-only': {
          enum8 = 33;
          break;
        }
        case 'invalid-seek': {
          enum8 = 34;
          break;
        }
        case 'text-file-busy': {
          enum8 = 35;
          break;
        }
        case 'cross-device': {
          enum8 = 36;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val8}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg6 + 1, enum8, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.rename-at"][Instruction::Return]', {
    funcName: '[method]descriptor.rename-at',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_40_metadata = {
  qualifiedImportFn: 'wasi:filesystem/types@0.2.0#[method]descriptor.symlink-at',
  moduleIdx: null,
};


function trampoline61(arg0, arg1, arg2, arg3, arg4, arg5) {
  var handle1 = arg0;
  var rep2 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable6.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Descriptor.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  var ptr3 = arg1;
  var len3 = arg2;
  var result3 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr3, len3));
  var ptr4 = arg3;
  var len4 = arg4;
  var result4 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr4, len4));
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.symlink-at"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.symlinkAt._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'symlinkAt',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.symlinkAt(result3, result4)};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant6 = ret;
  switch (variant6.tag) {
    case 'ok': {
      const e = variant6.val;
      dataView(memory0).setInt8(arg5 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant6.val;
      dataView(memory0).setInt8(arg5 + 0, 1, true);
      var val5 = e;
      let enum5;
      switch (val5) {
        case 'access': {
          enum5 = 0;
          break;
        }
        case 'would-block': {
          enum5 = 1;
          break;
        }
        case 'already': {
          enum5 = 2;
          break;
        }
        case 'bad-descriptor': {
          enum5 = 3;
          break;
        }
        case 'busy': {
          enum5 = 4;
          break;
        }
        case 'deadlock': {
          enum5 = 5;
          break;
        }
        case 'quota': {
          enum5 = 6;
          break;
        }
        case 'exist': {
          enum5 = 7;
          break;
        }
        case 'file-too-large': {
          enum5 = 8;
          break;
        }
        case 'illegal-byte-sequence': {
          enum5 = 9;
          break;
        }
        case 'in-progress': {
          enum5 = 10;
          break;
        }
        case 'interrupted': {
          enum5 = 11;
          break;
        }
        case 'invalid': {
          enum5 = 12;
          break;
        }
        case 'io': {
          enum5 = 13;
          break;
        }
        case 'is-directory': {
          enum5 = 14;
          break;
        }
        case 'loop': {
          enum5 = 15;
          break;
        }
        case 'too-many-links': {
          enum5 = 16;
          break;
        }
        case 'message-size': {
          enum5 = 17;
          break;
        }
        case 'name-too-long': {
          enum5 = 18;
          break;
        }
        case 'no-device': {
          enum5 = 19;
          break;
        }
        case 'no-entry': {
          enum5 = 20;
          break;
        }
        case 'no-lock': {
          enum5 = 21;
          break;
        }
        case 'insufficient-memory': {
          enum5 = 22;
          break;
        }
        case 'insufficient-space': {
          enum5 = 23;
          break;
        }
        case 'not-directory': {
          enum5 = 24;
          break;
        }
        case 'not-empty': {
          enum5 = 25;
          break;
        }
        case 'not-recoverable': {
          enum5 = 26;
          break;
        }
        case 'unsupported': {
          enum5 = 27;
          break;
        }
        case 'no-tty': {
          enum5 = 28;
          break;
        }
        case 'no-such-device': {
          enum5 = 29;
          break;
        }
        case 'overflow': {
          enum5 = 30;
          break;
        }
        case 'not-permitted': {
          enum5 = 31;
          break;
        }
        case 'pipe': {
          enum5 = 32;
          break;
        }
        case 'read-only': {
          enum5 = 33;
          break;
        }
        case 'invalid-seek': {
          enum5 = 34;
          break;
        }
        case 'text-file-busy': {
          enum5 = 35;
          break;
        }
        case 'cross-device': {
          enum5 = 36;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val5}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg5 + 1, enum5, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.symlink-at"][Instruction::Return]', {
    funcName: '[method]descriptor.symlink-at',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_41_metadata = {
  qualifiedImportFn: 'wasi:filesystem/types@0.2.0#[method]descriptor.unlink-file-at',
  moduleIdx: null,
};


function trampoline62(arg0, arg1, arg2, arg3) {
  var handle1 = arg0;
  var rep2 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable6.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Descriptor.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  var ptr3 = arg1;
  var len3 = arg2;
  var result3 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr3, len3));
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.unlink-file-at"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.unlinkFileAt._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'unlinkFileAt',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.unlinkFileAt(result3)};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant5 = ret;
  switch (variant5.tag) {
    case 'ok': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg3 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg3 + 0, 1, true);
      var val4 = e;
      let enum4;
      switch (val4) {
        case 'access': {
          enum4 = 0;
          break;
        }
        case 'would-block': {
          enum4 = 1;
          break;
        }
        case 'already': {
          enum4 = 2;
          break;
        }
        case 'bad-descriptor': {
          enum4 = 3;
          break;
        }
        case 'busy': {
          enum4 = 4;
          break;
        }
        case 'deadlock': {
          enum4 = 5;
          break;
        }
        case 'quota': {
          enum4 = 6;
          break;
        }
        case 'exist': {
          enum4 = 7;
          break;
        }
        case 'file-too-large': {
          enum4 = 8;
          break;
        }
        case 'illegal-byte-sequence': {
          enum4 = 9;
          break;
        }
        case 'in-progress': {
          enum4 = 10;
          break;
        }
        case 'interrupted': {
          enum4 = 11;
          break;
        }
        case 'invalid': {
          enum4 = 12;
          break;
        }
        case 'io': {
          enum4 = 13;
          break;
        }
        case 'is-directory': {
          enum4 = 14;
          break;
        }
        case 'loop': {
          enum4 = 15;
          break;
        }
        case 'too-many-links': {
          enum4 = 16;
          break;
        }
        case 'message-size': {
          enum4 = 17;
          break;
        }
        case 'name-too-long': {
          enum4 = 18;
          break;
        }
        case 'no-device': {
          enum4 = 19;
          break;
        }
        case 'no-entry': {
          enum4 = 20;
          break;
        }
        case 'no-lock': {
          enum4 = 21;
          break;
        }
        case 'insufficient-memory': {
          enum4 = 22;
          break;
        }
        case 'insufficient-space': {
          enum4 = 23;
          break;
        }
        case 'not-directory': {
          enum4 = 24;
          break;
        }
        case 'not-empty': {
          enum4 = 25;
          break;
        }
        case 'not-recoverable': {
          enum4 = 26;
          break;
        }
        case 'unsupported': {
          enum4 = 27;
          break;
        }
        case 'no-tty': {
          enum4 = 28;
          break;
        }
        case 'no-such-device': {
          enum4 = 29;
          break;
        }
        case 'overflow': {
          enum4 = 30;
          break;
        }
        case 'not-permitted': {
          enum4 = 31;
          break;
        }
        case 'pipe': {
          enum4 = 32;
          break;
        }
        case 'read-only': {
          enum4 = 33;
          break;
        }
        case 'invalid-seek': {
          enum4 = 34;
          break;
        }
        case 'text-file-busy': {
          enum4 = 35;
          break;
        }
        case 'cross-device': {
          enum4 = 36;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val4}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg3 + 1, enum4, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.unlink-file-at"][Instruction::Return]', {
    funcName: '[method]descriptor.unlink-file-at',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_42_metadata = {
  qualifiedImportFn: 'wasi:filesystem/types@0.2.0#[method]descriptor.read-via-stream',
  moduleIdx: null,
};


function trampoline63(arg0, arg1, arg2) {
  var handle1 = arg0;
  var rep2 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable6.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Descriptor.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.read-via-stream"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.readViaStream._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'readViaStream',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.readViaStream(BigInt.asUintN(64, arg1))};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant5 = ret;
  switch (variant5.tag) {
    case 'ok': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg2 + 0, 0, true);
      if (!(e instanceof InputStream)) {
        throw new TypeError('Resource error: Not a valid "InputStream" resource.');
      }
      var handle3 = e[symbolRscHandle];
      if (!handle3) {
        const rep = e[symbolRscRep] || ++captureCnt2;
        captureTable2.set(rep, e);
        handle3 = rscTableCreateOwn(handleTable2, rep);
      }
      dataView(memory0).setInt32(arg2 + 4, handle3, true);
      break;
    }
    case 'err': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg2 + 0, 1, true);
      var val4 = e;
      let enum4;
      switch (val4) {
        case 'access': {
          enum4 = 0;
          break;
        }
        case 'would-block': {
          enum4 = 1;
          break;
        }
        case 'already': {
          enum4 = 2;
          break;
        }
        case 'bad-descriptor': {
          enum4 = 3;
          break;
        }
        case 'busy': {
          enum4 = 4;
          break;
        }
        case 'deadlock': {
          enum4 = 5;
          break;
        }
        case 'quota': {
          enum4 = 6;
          break;
        }
        case 'exist': {
          enum4 = 7;
          break;
        }
        case 'file-too-large': {
          enum4 = 8;
          break;
        }
        case 'illegal-byte-sequence': {
          enum4 = 9;
          break;
        }
        case 'in-progress': {
          enum4 = 10;
          break;
        }
        case 'interrupted': {
          enum4 = 11;
          break;
        }
        case 'invalid': {
          enum4 = 12;
          break;
        }
        case 'io': {
          enum4 = 13;
          break;
        }
        case 'is-directory': {
          enum4 = 14;
          break;
        }
        case 'loop': {
          enum4 = 15;
          break;
        }
        case 'too-many-links': {
          enum4 = 16;
          break;
        }
        case 'message-size': {
          enum4 = 17;
          break;
        }
        case 'name-too-long': {
          enum4 = 18;
          break;
        }
        case 'no-device': {
          enum4 = 19;
          break;
        }
        case 'no-entry': {
          enum4 = 20;
          break;
        }
        case 'no-lock': {
          enum4 = 21;
          break;
        }
        case 'insufficient-memory': {
          enum4 = 22;
          break;
        }
        case 'insufficient-space': {
          enum4 = 23;
          break;
        }
        case 'not-directory': {
          enum4 = 24;
          break;
        }
        case 'not-empty': {
          enum4 = 25;
          break;
        }
        case 'not-recoverable': {
          enum4 = 26;
          break;
        }
        case 'unsupported': {
          enum4 = 27;
          break;
        }
        case 'no-tty': {
          enum4 = 28;
          break;
        }
        case 'no-such-device': {
          enum4 = 29;
          break;
        }
        case 'overflow': {
          enum4 = 30;
          break;
        }
        case 'not-permitted': {
          enum4 = 31;
          break;
        }
        case 'pipe': {
          enum4 = 32;
          break;
        }
        case 'read-only': {
          enum4 = 33;
          break;
        }
        case 'invalid-seek': {
          enum4 = 34;
          break;
        }
        case 'text-file-busy': {
          enum4 = 35;
          break;
        }
        case 'cross-device': {
          enum4 = 36;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val4}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg2 + 4, enum4, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.read-via-stream"][Instruction::Return]', {
    funcName: '[method]descriptor.read-via-stream',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_43_metadata = {
  qualifiedImportFn: 'wasi:filesystem/types@0.2.0#[method]descriptor.write-via-stream',
  moduleIdx: null,
};


function trampoline64(arg0, arg1, arg2) {
  var handle1 = arg0;
  var rep2 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable6.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Descriptor.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.write-via-stream"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.writeViaStream._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'writeViaStream',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.writeViaStream(BigInt.asUintN(64, arg1))};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant5 = ret;
  switch (variant5.tag) {
    case 'ok': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg2 + 0, 0, true);
      if (!(e instanceof OutputStream)) {
        throw new TypeError('Resource error: Not a valid "OutputStream" resource.');
      }
      var handle3 = e[symbolRscHandle];
      if (!handle3) {
        const rep = e[symbolRscRep] || ++captureCnt3;
        captureTable3.set(rep, e);
        handle3 = rscTableCreateOwn(handleTable3, rep);
      }
      dataView(memory0).setInt32(arg2 + 4, handle3, true);
      break;
    }
    case 'err': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg2 + 0, 1, true);
      var val4 = e;
      let enum4;
      switch (val4) {
        case 'access': {
          enum4 = 0;
          break;
        }
        case 'would-block': {
          enum4 = 1;
          break;
        }
        case 'already': {
          enum4 = 2;
          break;
        }
        case 'bad-descriptor': {
          enum4 = 3;
          break;
        }
        case 'busy': {
          enum4 = 4;
          break;
        }
        case 'deadlock': {
          enum4 = 5;
          break;
        }
        case 'quota': {
          enum4 = 6;
          break;
        }
        case 'exist': {
          enum4 = 7;
          break;
        }
        case 'file-too-large': {
          enum4 = 8;
          break;
        }
        case 'illegal-byte-sequence': {
          enum4 = 9;
          break;
        }
        case 'in-progress': {
          enum4 = 10;
          break;
        }
        case 'interrupted': {
          enum4 = 11;
          break;
        }
        case 'invalid': {
          enum4 = 12;
          break;
        }
        case 'io': {
          enum4 = 13;
          break;
        }
        case 'is-directory': {
          enum4 = 14;
          break;
        }
        case 'loop': {
          enum4 = 15;
          break;
        }
        case 'too-many-links': {
          enum4 = 16;
          break;
        }
        case 'message-size': {
          enum4 = 17;
          break;
        }
        case 'name-too-long': {
          enum4 = 18;
          break;
        }
        case 'no-device': {
          enum4 = 19;
          break;
        }
        case 'no-entry': {
          enum4 = 20;
          break;
        }
        case 'no-lock': {
          enum4 = 21;
          break;
        }
        case 'insufficient-memory': {
          enum4 = 22;
          break;
        }
        case 'insufficient-space': {
          enum4 = 23;
          break;
        }
        case 'not-directory': {
          enum4 = 24;
          break;
        }
        case 'not-empty': {
          enum4 = 25;
          break;
        }
        case 'not-recoverable': {
          enum4 = 26;
          break;
        }
        case 'unsupported': {
          enum4 = 27;
          break;
        }
        case 'no-tty': {
          enum4 = 28;
          break;
        }
        case 'no-such-device': {
          enum4 = 29;
          break;
        }
        case 'overflow': {
          enum4 = 30;
          break;
        }
        case 'not-permitted': {
          enum4 = 31;
          break;
        }
        case 'pipe': {
          enum4 = 32;
          break;
        }
        case 'read-only': {
          enum4 = 33;
          break;
        }
        case 'invalid-seek': {
          enum4 = 34;
          break;
        }
        case 'text-file-busy': {
          enum4 = 35;
          break;
        }
        case 'cross-device': {
          enum4 = 36;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val4}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg2 + 4, enum4, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.write-via-stream"][Instruction::Return]', {
    funcName: '[method]descriptor.write-via-stream',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_44_metadata = {
  qualifiedImportFn: 'wasi:filesystem/types@0.2.0#[method]descriptor.append-via-stream',
  moduleIdx: null,
};


function trampoline65(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable6.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Descriptor.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.append-via-stream"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.appendViaStream._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'appendViaStream',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.appendViaStream()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant5 = ret;
  switch (variant5.tag) {
    case 'ok': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      if (!(e instanceof OutputStream)) {
        throw new TypeError('Resource error: Not a valid "OutputStream" resource.');
      }
      var handle3 = e[symbolRscHandle];
      if (!handle3) {
        const rep = e[symbolRscRep] || ++captureCnt3;
        captureTable3.set(rep, e);
        handle3 = rscTableCreateOwn(handleTable3, rep);
      }
      dataView(memory0).setInt32(arg1 + 4, handle3, true);
      break;
    }
    case 'err': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val4 = e;
      let enum4;
      switch (val4) {
        case 'access': {
          enum4 = 0;
          break;
        }
        case 'would-block': {
          enum4 = 1;
          break;
        }
        case 'already': {
          enum4 = 2;
          break;
        }
        case 'bad-descriptor': {
          enum4 = 3;
          break;
        }
        case 'busy': {
          enum4 = 4;
          break;
        }
        case 'deadlock': {
          enum4 = 5;
          break;
        }
        case 'quota': {
          enum4 = 6;
          break;
        }
        case 'exist': {
          enum4 = 7;
          break;
        }
        case 'file-too-large': {
          enum4 = 8;
          break;
        }
        case 'illegal-byte-sequence': {
          enum4 = 9;
          break;
        }
        case 'in-progress': {
          enum4 = 10;
          break;
        }
        case 'interrupted': {
          enum4 = 11;
          break;
        }
        case 'invalid': {
          enum4 = 12;
          break;
        }
        case 'io': {
          enum4 = 13;
          break;
        }
        case 'is-directory': {
          enum4 = 14;
          break;
        }
        case 'loop': {
          enum4 = 15;
          break;
        }
        case 'too-many-links': {
          enum4 = 16;
          break;
        }
        case 'message-size': {
          enum4 = 17;
          break;
        }
        case 'name-too-long': {
          enum4 = 18;
          break;
        }
        case 'no-device': {
          enum4 = 19;
          break;
        }
        case 'no-entry': {
          enum4 = 20;
          break;
        }
        case 'no-lock': {
          enum4 = 21;
          break;
        }
        case 'insufficient-memory': {
          enum4 = 22;
          break;
        }
        case 'insufficient-space': {
          enum4 = 23;
          break;
        }
        case 'not-directory': {
          enum4 = 24;
          break;
        }
        case 'not-empty': {
          enum4 = 25;
          break;
        }
        case 'not-recoverable': {
          enum4 = 26;
          break;
        }
        case 'unsupported': {
          enum4 = 27;
          break;
        }
        case 'no-tty': {
          enum4 = 28;
          break;
        }
        case 'no-such-device': {
          enum4 = 29;
          break;
        }
        case 'overflow': {
          enum4 = 30;
          break;
        }
        case 'not-permitted': {
          enum4 = 31;
          break;
        }
        case 'pipe': {
          enum4 = 32;
          break;
        }
        case 'read-only': {
          enum4 = 33;
          break;
        }
        case 'invalid-seek': {
          enum4 = 34;
          break;
        }
        case 'text-file-busy': {
          enum4 = 35;
          break;
        }
        case 'cross-device': {
          enum4 = 36;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val4}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 4, enum4, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.append-via-stream"][Instruction::Return]', {
    funcName: '[method]descriptor.append-via-stream',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_45_metadata = {
  qualifiedImportFn: 'wasi:filesystem/types@0.2.0#[method]descriptor.get-flags',
  moduleIdx: null,
};


function trampoline66(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable6.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Descriptor.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.get-flags"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.getFlags._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'getFlags',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.getFlags()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant5 = ret;
  switch (variant5.tag) {
    case 'ok': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      let flags3 = 0;
      if (typeof e === 'object' && e !== null) {
        flags3 = Boolean(e.read) << 0 | Boolean(e.write) << 1 | Boolean(e.fileIntegritySync) << 2 | Boolean(e.dataIntegritySync) << 3 | Boolean(e.requestedWriteSync) << 4 | Boolean(e.mutateDirectory) << 5;
      } else if (e !== null && e!== undefined) {
        throw new TypeError('only an object, undefined or null can be converted to flags');
      }
      dataView(memory0).setInt8(arg1 + 1, flags3, true);
      break;
    }
    case 'err': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val4 = e;
      let enum4;
      switch (val4) {
        case 'access': {
          enum4 = 0;
          break;
        }
        case 'would-block': {
          enum4 = 1;
          break;
        }
        case 'already': {
          enum4 = 2;
          break;
        }
        case 'bad-descriptor': {
          enum4 = 3;
          break;
        }
        case 'busy': {
          enum4 = 4;
          break;
        }
        case 'deadlock': {
          enum4 = 5;
          break;
        }
        case 'quota': {
          enum4 = 6;
          break;
        }
        case 'exist': {
          enum4 = 7;
          break;
        }
        case 'file-too-large': {
          enum4 = 8;
          break;
        }
        case 'illegal-byte-sequence': {
          enum4 = 9;
          break;
        }
        case 'in-progress': {
          enum4 = 10;
          break;
        }
        case 'interrupted': {
          enum4 = 11;
          break;
        }
        case 'invalid': {
          enum4 = 12;
          break;
        }
        case 'io': {
          enum4 = 13;
          break;
        }
        case 'is-directory': {
          enum4 = 14;
          break;
        }
        case 'loop': {
          enum4 = 15;
          break;
        }
        case 'too-many-links': {
          enum4 = 16;
          break;
        }
        case 'message-size': {
          enum4 = 17;
          break;
        }
        case 'name-too-long': {
          enum4 = 18;
          break;
        }
        case 'no-device': {
          enum4 = 19;
          break;
        }
        case 'no-entry': {
          enum4 = 20;
          break;
        }
        case 'no-lock': {
          enum4 = 21;
          break;
        }
        case 'insufficient-memory': {
          enum4 = 22;
          break;
        }
        case 'insufficient-space': {
          enum4 = 23;
          break;
        }
        case 'not-directory': {
          enum4 = 24;
          break;
        }
        case 'not-empty': {
          enum4 = 25;
          break;
        }
        case 'not-recoverable': {
          enum4 = 26;
          break;
        }
        case 'unsupported': {
          enum4 = 27;
          break;
        }
        case 'no-tty': {
          enum4 = 28;
          break;
        }
        case 'no-such-device': {
          enum4 = 29;
          break;
        }
        case 'overflow': {
          enum4 = 30;
          break;
        }
        case 'not-permitted': {
          enum4 = 31;
          break;
        }
        case 'pipe': {
          enum4 = 32;
          break;
        }
        case 'read-only': {
          enum4 = 33;
          break;
        }
        case 'invalid-seek': {
          enum4 = 34;
          break;
        }
        case 'text-file-busy': {
          enum4 = 35;
          break;
        }
        case 'cross-device': {
          enum4 = 36;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val4}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 1, enum4, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.get-flags"][Instruction::Return]', {
    funcName: '[method]descriptor.get-flags',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_46_metadata = {
  qualifiedImportFn: 'wasi:filesystem/types@0.2.0#[method]descriptor.set-times',
  moduleIdx: null,
};


function trampoline67(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
  var handle1 = arg0;
  var rep2 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable6.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Descriptor.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  let variant3;
  switch (arg1) {
    case 0: {
      variant3= {
        tag: 'no-change',
      };
      break;
    }
    case 1: {
      variant3= {
        tag: 'now',
      };
      break;
    }
    case 2: {
      variant3= {
        tag: 'timestamp',
        val: {
          seconds: BigInt.asUintN(64, arg2),
          nanoseconds: arg3 >>> 0,
        }
      };
      break;
    }
    default: {
      throw new TypeError('invalid variant discriminant for NewTimestamp');
    }
  }
  let variant4;
  switch (arg4) {
    case 0: {
      variant4= {
        tag: 'no-change',
      };
      break;
    }
    case 1: {
      variant4= {
        tag: 'now',
      };
      break;
    }
    case 2: {
      variant4= {
        tag: 'timestamp',
        val: {
          seconds: BigInt.asUintN(64, arg5),
          nanoseconds: arg6 >>> 0,
        }
      };
      break;
    }
    default: {
      throw new TypeError('invalid variant discriminant for NewTimestamp');
    }
  }
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.set-times"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.setTimes._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'setTimes',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.setTimes(variant3, variant4)};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant6 = ret;
  switch (variant6.tag) {
    case 'ok': {
      const e = variant6.val;
      dataView(memory0).setInt8(arg7 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant6.val;
      dataView(memory0).setInt8(arg7 + 0, 1, true);
      var val5 = e;
      let enum5;
      switch (val5) {
        case 'access': {
          enum5 = 0;
          break;
        }
        case 'would-block': {
          enum5 = 1;
          break;
        }
        case 'already': {
          enum5 = 2;
          break;
        }
        case 'bad-descriptor': {
          enum5 = 3;
          break;
        }
        case 'busy': {
          enum5 = 4;
          break;
        }
        case 'deadlock': {
          enum5 = 5;
          break;
        }
        case 'quota': {
          enum5 = 6;
          break;
        }
        case 'exist': {
          enum5 = 7;
          break;
        }
        case 'file-too-large': {
          enum5 = 8;
          break;
        }
        case 'illegal-byte-sequence': {
          enum5 = 9;
          break;
        }
        case 'in-progress': {
          enum5 = 10;
          break;
        }
        case 'interrupted': {
          enum5 = 11;
          break;
        }
        case 'invalid': {
          enum5 = 12;
          break;
        }
        case 'io': {
          enum5 = 13;
          break;
        }
        case 'is-directory': {
          enum5 = 14;
          break;
        }
        case 'loop': {
          enum5 = 15;
          break;
        }
        case 'too-many-links': {
          enum5 = 16;
          break;
        }
        case 'message-size': {
          enum5 = 17;
          break;
        }
        case 'name-too-long': {
          enum5 = 18;
          break;
        }
        case 'no-device': {
          enum5 = 19;
          break;
        }
        case 'no-entry': {
          enum5 = 20;
          break;
        }
        case 'no-lock': {
          enum5 = 21;
          break;
        }
        case 'insufficient-memory': {
          enum5 = 22;
          break;
        }
        case 'insufficient-space': {
          enum5 = 23;
          break;
        }
        case 'not-directory': {
          enum5 = 24;
          break;
        }
        case 'not-empty': {
          enum5 = 25;
          break;
        }
        case 'not-recoverable': {
          enum5 = 26;
          break;
        }
        case 'unsupported': {
          enum5 = 27;
          break;
        }
        case 'no-tty': {
          enum5 = 28;
          break;
        }
        case 'no-such-device': {
          enum5 = 29;
          break;
        }
        case 'overflow': {
          enum5 = 30;
          break;
        }
        case 'not-permitted': {
          enum5 = 31;
          break;
        }
        case 'pipe': {
          enum5 = 32;
          break;
        }
        case 'read-only': {
          enum5 = 33;
          break;
        }
        case 'invalid-seek': {
          enum5 = 34;
          break;
        }
        case 'text-file-busy': {
          enum5 = 35;
          break;
        }
        case 'cross-device': {
          enum5 = 36;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val5}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg7 + 1, enum5, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.set-times"][Instruction::Return]', {
    funcName: '[method]descriptor.set-times',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_47_metadata = {
  qualifiedImportFn: 'wasi:filesystem/types@0.2.0#[method]descriptor.read',
  moduleIdx: null,
};


function trampoline68(arg0, arg1, arg2, arg3) {
  var handle1 = arg0;
  var rep2 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable6.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Descriptor.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.read"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.read._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'read',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.read(BigInt.asUintN(64, arg1), BigInt.asUintN(64, arg2))};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant6 = ret;
  switch (variant6.tag) {
    case 'ok': {
      const e = variant6.val;
      dataView(memory0).setInt8(arg3 + 0, 0, true);
      var [tuple3_0, tuple3_1] = e;
      var val4 = tuple3_0;
      var len4 = val4.byteLength;
      var ptr4 = realloc0(0, 0, 1, len4 * 1);
      var src4 = new Uint8Array(val4.buffer || val4, val4.byteOffset, len4 * 1);
      (new Uint8Array(memory0.buffer, ptr4, len4 * 1)).set(src4);
      dataView(memory0).setUint32(arg3 + 8, len4, true);
      dataView(memory0).setUint32(arg3 + 4, ptr4, true);
      dataView(memory0).setInt8(arg3 + 12, tuple3_1 ? 1 : 0, true);
      break;
    }
    case 'err': {
      const e = variant6.val;
      dataView(memory0).setInt8(arg3 + 0, 1, true);
      var val5 = e;
      let enum5;
      switch (val5) {
        case 'access': {
          enum5 = 0;
          break;
        }
        case 'would-block': {
          enum5 = 1;
          break;
        }
        case 'already': {
          enum5 = 2;
          break;
        }
        case 'bad-descriptor': {
          enum5 = 3;
          break;
        }
        case 'busy': {
          enum5 = 4;
          break;
        }
        case 'deadlock': {
          enum5 = 5;
          break;
        }
        case 'quota': {
          enum5 = 6;
          break;
        }
        case 'exist': {
          enum5 = 7;
          break;
        }
        case 'file-too-large': {
          enum5 = 8;
          break;
        }
        case 'illegal-byte-sequence': {
          enum5 = 9;
          break;
        }
        case 'in-progress': {
          enum5 = 10;
          break;
        }
        case 'interrupted': {
          enum5 = 11;
          break;
        }
        case 'invalid': {
          enum5 = 12;
          break;
        }
        case 'io': {
          enum5 = 13;
          break;
        }
        case 'is-directory': {
          enum5 = 14;
          break;
        }
        case 'loop': {
          enum5 = 15;
          break;
        }
        case 'too-many-links': {
          enum5 = 16;
          break;
        }
        case 'message-size': {
          enum5 = 17;
          break;
        }
        case 'name-too-long': {
          enum5 = 18;
          break;
        }
        case 'no-device': {
          enum5 = 19;
          break;
        }
        case 'no-entry': {
          enum5 = 20;
          break;
        }
        case 'no-lock': {
          enum5 = 21;
          break;
        }
        case 'insufficient-memory': {
          enum5 = 22;
          break;
        }
        case 'insufficient-space': {
          enum5 = 23;
          break;
        }
        case 'not-directory': {
          enum5 = 24;
          break;
        }
        case 'not-empty': {
          enum5 = 25;
          break;
        }
        case 'not-recoverable': {
          enum5 = 26;
          break;
        }
        case 'unsupported': {
          enum5 = 27;
          break;
        }
        case 'no-tty': {
          enum5 = 28;
          break;
        }
        case 'no-such-device': {
          enum5 = 29;
          break;
        }
        case 'overflow': {
          enum5 = 30;
          break;
        }
        case 'not-permitted': {
          enum5 = 31;
          break;
        }
        case 'pipe': {
          enum5 = 32;
          break;
        }
        case 'read-only': {
          enum5 = 33;
          break;
        }
        case 'invalid-seek': {
          enum5 = 34;
          break;
        }
        case 'text-file-busy': {
          enum5 = 35;
          break;
        }
        case 'cross-device': {
          enum5 = 36;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val5}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg3 + 4, enum5, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.read"][Instruction::Return]', {
    funcName: '[method]descriptor.read',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_48_metadata = {
  qualifiedImportFn: 'wasi:filesystem/types@0.2.0#[method]descriptor.stat',
  moduleIdx: null,
};


function trampoline69(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable6.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Descriptor.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.stat"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.stat._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'stat',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.stat()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant12 = ret;
  switch (variant12.tag) {
    case 'ok': {
      const e = variant12.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      var {type: v3_0, linkCount: v3_1, size: v3_2, dataAccessTimestamp: v3_3, dataModificationTimestamp: v3_4, statusChangeTimestamp: v3_5 } = e;
      var val4 = v3_0;
      let enum4;
      switch (val4) {
        case 'unknown': {
          enum4 = 0;
          break;
        }
        case 'block-device': {
          enum4 = 1;
          break;
        }
        case 'character-device': {
          enum4 = 2;
          break;
        }
        case 'directory': {
          enum4 = 3;
          break;
        }
        case 'fifo': {
          enum4 = 4;
          break;
        }
        case 'symbolic-link': {
          enum4 = 5;
          break;
        }
        case 'regular-file': {
          enum4 = 6;
          break;
        }
        case 'socket': {
          enum4 = 7;
          break;
        }
        default: {
          if ((v3_0) instanceof Error) {
            console.error(v3_0);
          }
          
          throw new TypeError(`"${val4}" is not one of the cases of descriptor-type`);
        }
      }
      dataView(memory0).setInt8(arg1 + 8, enum4, true);
      dataView(memory0).setBigInt64(arg1 + 16, toUint64(v3_1), true);
      dataView(memory0).setBigInt64(arg1 + 24, toUint64(v3_2), true);
      var variant6 = v3_3;
      if (variant6 === null || variant6=== undefined) {
        dataView(memory0).setInt8(arg1 + 32, 0, true);
      } else {
        const e = variant6;
        dataView(memory0).setInt8(arg1 + 32, 1, true);
        var {seconds: v5_0, nanoseconds: v5_1 } = e;
        dataView(memory0).setBigInt64(arg1 + 40, toUint64(v5_0), true);
        dataView(memory0).setInt32(arg1 + 48, toUint32(v5_1), true);
      }
      var variant8 = v3_4;
      if (variant8 === null || variant8=== undefined) {
        dataView(memory0).setInt8(arg1 + 56, 0, true);
      } else {
        const e = variant8;
        dataView(memory0).setInt8(arg1 + 56, 1, true);
        var {seconds: v7_0, nanoseconds: v7_1 } = e;
        dataView(memory0).setBigInt64(arg1 + 64, toUint64(v7_0), true);
        dataView(memory0).setInt32(arg1 + 72, toUint32(v7_1), true);
      }
      var variant10 = v3_5;
      if (variant10 === null || variant10=== undefined) {
        dataView(memory0).setInt8(arg1 + 80, 0, true);
      } else {
        const e = variant10;
        dataView(memory0).setInt8(arg1 + 80, 1, true);
        var {seconds: v9_0, nanoseconds: v9_1 } = e;
        dataView(memory0).setBigInt64(arg1 + 88, toUint64(v9_0), true);
        dataView(memory0).setInt32(arg1 + 96, toUint32(v9_1), true);
      }
      break;
    }
    case 'err': {
      const e = variant12.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val11 = e;
      let enum11;
      switch (val11) {
        case 'access': {
          enum11 = 0;
          break;
        }
        case 'would-block': {
          enum11 = 1;
          break;
        }
        case 'already': {
          enum11 = 2;
          break;
        }
        case 'bad-descriptor': {
          enum11 = 3;
          break;
        }
        case 'busy': {
          enum11 = 4;
          break;
        }
        case 'deadlock': {
          enum11 = 5;
          break;
        }
        case 'quota': {
          enum11 = 6;
          break;
        }
        case 'exist': {
          enum11 = 7;
          break;
        }
        case 'file-too-large': {
          enum11 = 8;
          break;
        }
        case 'illegal-byte-sequence': {
          enum11 = 9;
          break;
        }
        case 'in-progress': {
          enum11 = 10;
          break;
        }
        case 'interrupted': {
          enum11 = 11;
          break;
        }
        case 'invalid': {
          enum11 = 12;
          break;
        }
        case 'io': {
          enum11 = 13;
          break;
        }
        case 'is-directory': {
          enum11 = 14;
          break;
        }
        case 'loop': {
          enum11 = 15;
          break;
        }
        case 'too-many-links': {
          enum11 = 16;
          break;
        }
        case 'message-size': {
          enum11 = 17;
          break;
        }
        case 'name-too-long': {
          enum11 = 18;
          break;
        }
        case 'no-device': {
          enum11 = 19;
          break;
        }
        case 'no-entry': {
          enum11 = 20;
          break;
        }
        case 'no-lock': {
          enum11 = 21;
          break;
        }
        case 'insufficient-memory': {
          enum11 = 22;
          break;
        }
        case 'insufficient-space': {
          enum11 = 23;
          break;
        }
        case 'not-directory': {
          enum11 = 24;
          break;
        }
        case 'not-empty': {
          enum11 = 25;
          break;
        }
        case 'not-recoverable': {
          enum11 = 26;
          break;
        }
        case 'unsupported': {
          enum11 = 27;
          break;
        }
        case 'no-tty': {
          enum11 = 28;
          break;
        }
        case 'no-such-device': {
          enum11 = 29;
          break;
        }
        case 'overflow': {
          enum11 = 30;
          break;
        }
        case 'not-permitted': {
          enum11 = 31;
          break;
        }
        case 'pipe': {
          enum11 = 32;
          break;
        }
        case 'read-only': {
          enum11 = 33;
          break;
        }
        case 'invalid-seek': {
          enum11 = 34;
          break;
        }
        case 'text-file-busy': {
          enum11 = 35;
          break;
        }
        case 'cross-device': {
          enum11 = 36;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val11}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 8, enum11, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.stat"][Instruction::Return]', {
    funcName: '[method]descriptor.stat',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_49_metadata = {
  qualifiedImportFn: 'wasi:filesystem/types@0.2.0#[method]descriptor.stat-at',
  moduleIdx: null,
};


function trampoline70(arg0, arg1, arg2, arg3, arg4) {
  var handle1 = arg0;
  var rep2 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable6.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Descriptor.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  if ((arg1 & 4294967294) !== 0) {
    throw new TypeError('flags have extraneous bits set');
  }
  var flags3 = {
    symlinkFollow: Boolean(arg1 & 1),
  };
  var ptr4 = arg2;
  var len4 = arg3;
  var result4 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr4, len4));
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.stat-at"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.statAt._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'statAt',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.statAt(flags3, result4)};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant14 = ret;
  switch (variant14.tag) {
    case 'ok': {
      const e = variant14.val;
      dataView(memory0).setInt8(arg4 + 0, 0, true);
      var {type: v5_0, linkCount: v5_1, size: v5_2, dataAccessTimestamp: v5_3, dataModificationTimestamp: v5_4, statusChangeTimestamp: v5_5 } = e;
      var val6 = v5_0;
      let enum6;
      switch (val6) {
        case 'unknown': {
          enum6 = 0;
          break;
        }
        case 'block-device': {
          enum6 = 1;
          break;
        }
        case 'character-device': {
          enum6 = 2;
          break;
        }
        case 'directory': {
          enum6 = 3;
          break;
        }
        case 'fifo': {
          enum6 = 4;
          break;
        }
        case 'symbolic-link': {
          enum6 = 5;
          break;
        }
        case 'regular-file': {
          enum6 = 6;
          break;
        }
        case 'socket': {
          enum6 = 7;
          break;
        }
        default: {
          if ((v5_0) instanceof Error) {
            console.error(v5_0);
          }
          
          throw new TypeError(`"${val6}" is not one of the cases of descriptor-type`);
        }
      }
      dataView(memory0).setInt8(arg4 + 8, enum6, true);
      dataView(memory0).setBigInt64(arg4 + 16, toUint64(v5_1), true);
      dataView(memory0).setBigInt64(arg4 + 24, toUint64(v5_2), true);
      var variant8 = v5_3;
      if (variant8 === null || variant8=== undefined) {
        dataView(memory0).setInt8(arg4 + 32, 0, true);
      } else {
        const e = variant8;
        dataView(memory0).setInt8(arg4 + 32, 1, true);
        var {seconds: v7_0, nanoseconds: v7_1 } = e;
        dataView(memory0).setBigInt64(arg4 + 40, toUint64(v7_0), true);
        dataView(memory0).setInt32(arg4 + 48, toUint32(v7_1), true);
      }
      var variant10 = v5_4;
      if (variant10 === null || variant10=== undefined) {
        dataView(memory0).setInt8(arg4 + 56, 0, true);
      } else {
        const e = variant10;
        dataView(memory0).setInt8(arg4 + 56, 1, true);
        var {seconds: v9_0, nanoseconds: v9_1 } = e;
        dataView(memory0).setBigInt64(arg4 + 64, toUint64(v9_0), true);
        dataView(memory0).setInt32(arg4 + 72, toUint32(v9_1), true);
      }
      var variant12 = v5_5;
      if (variant12 === null || variant12=== undefined) {
        dataView(memory0).setInt8(arg4 + 80, 0, true);
      } else {
        const e = variant12;
        dataView(memory0).setInt8(arg4 + 80, 1, true);
        var {seconds: v11_0, nanoseconds: v11_1 } = e;
        dataView(memory0).setBigInt64(arg4 + 88, toUint64(v11_0), true);
        dataView(memory0).setInt32(arg4 + 96, toUint32(v11_1), true);
      }
      break;
    }
    case 'err': {
      const e = variant14.val;
      dataView(memory0).setInt8(arg4 + 0, 1, true);
      var val13 = e;
      let enum13;
      switch (val13) {
        case 'access': {
          enum13 = 0;
          break;
        }
        case 'would-block': {
          enum13 = 1;
          break;
        }
        case 'already': {
          enum13 = 2;
          break;
        }
        case 'bad-descriptor': {
          enum13 = 3;
          break;
        }
        case 'busy': {
          enum13 = 4;
          break;
        }
        case 'deadlock': {
          enum13 = 5;
          break;
        }
        case 'quota': {
          enum13 = 6;
          break;
        }
        case 'exist': {
          enum13 = 7;
          break;
        }
        case 'file-too-large': {
          enum13 = 8;
          break;
        }
        case 'illegal-byte-sequence': {
          enum13 = 9;
          break;
        }
        case 'in-progress': {
          enum13 = 10;
          break;
        }
        case 'interrupted': {
          enum13 = 11;
          break;
        }
        case 'invalid': {
          enum13 = 12;
          break;
        }
        case 'io': {
          enum13 = 13;
          break;
        }
        case 'is-directory': {
          enum13 = 14;
          break;
        }
        case 'loop': {
          enum13 = 15;
          break;
        }
        case 'too-many-links': {
          enum13 = 16;
          break;
        }
        case 'message-size': {
          enum13 = 17;
          break;
        }
        case 'name-too-long': {
          enum13 = 18;
          break;
        }
        case 'no-device': {
          enum13 = 19;
          break;
        }
        case 'no-entry': {
          enum13 = 20;
          break;
        }
        case 'no-lock': {
          enum13 = 21;
          break;
        }
        case 'insufficient-memory': {
          enum13 = 22;
          break;
        }
        case 'insufficient-space': {
          enum13 = 23;
          break;
        }
        case 'not-directory': {
          enum13 = 24;
          break;
        }
        case 'not-empty': {
          enum13 = 25;
          break;
        }
        case 'not-recoverable': {
          enum13 = 26;
          break;
        }
        case 'unsupported': {
          enum13 = 27;
          break;
        }
        case 'no-tty': {
          enum13 = 28;
          break;
        }
        case 'no-such-device': {
          enum13 = 29;
          break;
        }
        case 'overflow': {
          enum13 = 30;
          break;
        }
        case 'not-permitted': {
          enum13 = 31;
          break;
        }
        case 'pipe': {
          enum13 = 32;
          break;
        }
        case 'read-only': {
          enum13 = 33;
          break;
        }
        case 'invalid-seek': {
          enum13 = 34;
          break;
        }
        case 'text-file-busy': {
          enum13 = 35;
          break;
        }
        case 'cross-device': {
          enum13 = 36;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val13}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg4 + 8, enum13, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.stat-at"][Instruction::Return]', {
    funcName: '[method]descriptor.stat-at',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_50_metadata = {
  qualifiedImportFn: 'wasi:filesystem/types@0.2.0#[method]descriptor.set-times-at',
  moduleIdx: null,
};


function trampoline71(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10) {
  var handle1 = arg0;
  var rep2 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable6.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Descriptor.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  if ((arg1 & 4294967294) !== 0) {
    throw new TypeError('flags have extraneous bits set');
  }
  var flags3 = {
    symlinkFollow: Boolean(arg1 & 1),
  };
  var ptr4 = arg2;
  var len4 = arg3;
  var result4 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr4, len4));
  let variant5;
  switch (arg4) {
    case 0: {
      variant5= {
        tag: 'no-change',
      };
      break;
    }
    case 1: {
      variant5= {
        tag: 'now',
      };
      break;
    }
    case 2: {
      variant5= {
        tag: 'timestamp',
        val: {
          seconds: BigInt.asUintN(64, arg5),
          nanoseconds: arg6 >>> 0,
        }
      };
      break;
    }
    default: {
      throw new TypeError('invalid variant discriminant for NewTimestamp');
    }
  }
  let variant6;
  switch (arg7) {
    case 0: {
      variant6= {
        tag: 'no-change',
      };
      break;
    }
    case 1: {
      variant6= {
        tag: 'now',
      };
      break;
    }
    case 2: {
      variant6= {
        tag: 'timestamp',
        val: {
          seconds: BigInt.asUintN(64, arg8),
          nanoseconds: arg9 >>> 0,
        }
      };
      break;
    }
    default: {
      throw new TypeError('invalid variant discriminant for NewTimestamp');
    }
  }
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.set-times-at"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.setTimesAt._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'setTimesAt',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.setTimesAt(flags3, result4, variant5, variant6)};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant8 = ret;
  switch (variant8.tag) {
    case 'ok': {
      const e = variant8.val;
      dataView(memory0).setInt8(arg10 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant8.val;
      dataView(memory0).setInt8(arg10 + 0, 1, true);
      var val7 = e;
      let enum7;
      switch (val7) {
        case 'access': {
          enum7 = 0;
          break;
        }
        case 'would-block': {
          enum7 = 1;
          break;
        }
        case 'already': {
          enum7 = 2;
          break;
        }
        case 'bad-descriptor': {
          enum7 = 3;
          break;
        }
        case 'busy': {
          enum7 = 4;
          break;
        }
        case 'deadlock': {
          enum7 = 5;
          break;
        }
        case 'quota': {
          enum7 = 6;
          break;
        }
        case 'exist': {
          enum7 = 7;
          break;
        }
        case 'file-too-large': {
          enum7 = 8;
          break;
        }
        case 'illegal-byte-sequence': {
          enum7 = 9;
          break;
        }
        case 'in-progress': {
          enum7 = 10;
          break;
        }
        case 'interrupted': {
          enum7 = 11;
          break;
        }
        case 'invalid': {
          enum7 = 12;
          break;
        }
        case 'io': {
          enum7 = 13;
          break;
        }
        case 'is-directory': {
          enum7 = 14;
          break;
        }
        case 'loop': {
          enum7 = 15;
          break;
        }
        case 'too-many-links': {
          enum7 = 16;
          break;
        }
        case 'message-size': {
          enum7 = 17;
          break;
        }
        case 'name-too-long': {
          enum7 = 18;
          break;
        }
        case 'no-device': {
          enum7 = 19;
          break;
        }
        case 'no-entry': {
          enum7 = 20;
          break;
        }
        case 'no-lock': {
          enum7 = 21;
          break;
        }
        case 'insufficient-memory': {
          enum7 = 22;
          break;
        }
        case 'insufficient-space': {
          enum7 = 23;
          break;
        }
        case 'not-directory': {
          enum7 = 24;
          break;
        }
        case 'not-empty': {
          enum7 = 25;
          break;
        }
        case 'not-recoverable': {
          enum7 = 26;
          break;
        }
        case 'unsupported': {
          enum7 = 27;
          break;
        }
        case 'no-tty': {
          enum7 = 28;
          break;
        }
        case 'no-such-device': {
          enum7 = 29;
          break;
        }
        case 'overflow': {
          enum7 = 30;
          break;
        }
        case 'not-permitted': {
          enum7 = 31;
          break;
        }
        case 'pipe': {
          enum7 = 32;
          break;
        }
        case 'read-only': {
          enum7 = 33;
          break;
        }
        case 'invalid-seek': {
          enum7 = 34;
          break;
        }
        case 'text-file-busy': {
          enum7 = 35;
          break;
        }
        case 'cross-device': {
          enum7 = 36;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val7}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg10 + 1, enum7, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.set-times-at"][Instruction::Return]', {
    funcName: '[method]descriptor.set-times-at',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_51_metadata = {
  qualifiedImportFn: 'wasi:filesystem/types@0.2.0#[method]descriptor.link-at',
  moduleIdx: null,
};


function trampoline72(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
  var handle1 = arg0;
  var rep2 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable6.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Descriptor.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  if ((arg1 & 4294967294) !== 0) {
    throw new TypeError('flags have extraneous bits set');
  }
  var flags3 = {
    symlinkFollow: Boolean(arg1 & 1),
  };
  var ptr4 = arg2;
  var len4 = arg3;
  var result4 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr4, len4));
  var handle6 = arg4;
  var rep7 = handleTable6[(handle6 << 1) + 1] & ~T_FLAG;
  var rsc5 = captureTable6.get(rep7);
  if (!rsc5) {
    rsc5 = Object.create(Descriptor.prototype);
    Object.defineProperty(rsc5, symbolRscHandle, { writable: true, value: handle6});
    Object.defineProperty(rsc5, symbolRscRep, { writable: true, value: rep7});
  }
  curResourceBorrows.push(rsc5);
  var ptr8 = arg5;
  var len8 = arg6;
  var result8 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr8, len8));
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.link-at"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.linkAt._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'linkAt',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.linkAt(flags3, result4, rsc5, result8)};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant10 = ret;
  switch (variant10.tag) {
    case 'ok': {
      const e = variant10.val;
      dataView(memory0).setInt8(arg7 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant10.val;
      dataView(memory0).setInt8(arg7 + 0, 1, true);
      var val9 = e;
      let enum9;
      switch (val9) {
        case 'access': {
          enum9 = 0;
          break;
        }
        case 'would-block': {
          enum9 = 1;
          break;
        }
        case 'already': {
          enum9 = 2;
          break;
        }
        case 'bad-descriptor': {
          enum9 = 3;
          break;
        }
        case 'busy': {
          enum9 = 4;
          break;
        }
        case 'deadlock': {
          enum9 = 5;
          break;
        }
        case 'quota': {
          enum9 = 6;
          break;
        }
        case 'exist': {
          enum9 = 7;
          break;
        }
        case 'file-too-large': {
          enum9 = 8;
          break;
        }
        case 'illegal-byte-sequence': {
          enum9 = 9;
          break;
        }
        case 'in-progress': {
          enum9 = 10;
          break;
        }
        case 'interrupted': {
          enum9 = 11;
          break;
        }
        case 'invalid': {
          enum9 = 12;
          break;
        }
        case 'io': {
          enum9 = 13;
          break;
        }
        case 'is-directory': {
          enum9 = 14;
          break;
        }
        case 'loop': {
          enum9 = 15;
          break;
        }
        case 'too-many-links': {
          enum9 = 16;
          break;
        }
        case 'message-size': {
          enum9 = 17;
          break;
        }
        case 'name-too-long': {
          enum9 = 18;
          break;
        }
        case 'no-device': {
          enum9 = 19;
          break;
        }
        case 'no-entry': {
          enum9 = 20;
          break;
        }
        case 'no-lock': {
          enum9 = 21;
          break;
        }
        case 'insufficient-memory': {
          enum9 = 22;
          break;
        }
        case 'insufficient-space': {
          enum9 = 23;
          break;
        }
        case 'not-directory': {
          enum9 = 24;
          break;
        }
        case 'not-empty': {
          enum9 = 25;
          break;
        }
        case 'not-recoverable': {
          enum9 = 26;
          break;
        }
        case 'unsupported': {
          enum9 = 27;
          break;
        }
        case 'no-tty': {
          enum9 = 28;
          break;
        }
        case 'no-such-device': {
          enum9 = 29;
          break;
        }
        case 'overflow': {
          enum9 = 30;
          break;
        }
        case 'not-permitted': {
          enum9 = 31;
          break;
        }
        case 'pipe': {
          enum9 = 32;
          break;
        }
        case 'read-only': {
          enum9 = 33;
          break;
        }
        case 'invalid-seek': {
          enum9 = 34;
          break;
        }
        case 'text-file-busy': {
          enum9 = 35;
          break;
        }
        case 'cross-device': {
          enum9 = 36;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val9}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg7 + 1, enum9, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.link-at"][Instruction::Return]', {
    funcName: '[method]descriptor.link-at',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_52_metadata = {
  qualifiedImportFn: 'wasi:filesystem/types@0.2.0#[method]descriptor.open-at',
  moduleIdx: null,
};


function trampoline73(arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
  var handle1 = arg0;
  var rep2 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable6.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Descriptor.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  if ((arg1 & 4294967294) !== 0) {
    throw new TypeError('flags have extraneous bits set');
  }
  var flags3 = {
    symlinkFollow: Boolean(arg1 & 1),
  };
  var ptr4 = arg2;
  var len4 = arg3;
  var result4 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr4, len4));
  if ((arg4 & 4294967280) !== 0) {
    throw new TypeError('flags have extraneous bits set');
  }
  var flags5 = {
    create: Boolean(arg4 & 1),
    directory: Boolean(arg4 & 2),
    exclusive: Boolean(arg4 & 4),
    truncate: Boolean(arg4 & 8),
  };
  if ((arg5 & 4294967232) !== 0) {
    throw new TypeError('flags have extraneous bits set');
  }
  var flags6 = {
    read: Boolean(arg5 & 1),
    write: Boolean(arg5 & 2),
    fileIntegritySync: Boolean(arg5 & 4),
    dataIntegritySync: Boolean(arg5 & 8),
    requestedWriteSync: Boolean(arg5 & 16),
    mutateDirectory: Boolean(arg5 & 32),
  };
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.open-at"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.openAt._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'openAt',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.openAt(flags3, result4, flags5, flags6)};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant9 = ret;
  switch (variant9.tag) {
    case 'ok': {
      const e = variant9.val;
      dataView(memory0).setInt8(arg6 + 0, 0, true);
      if (!(e instanceof Descriptor)) {
        throw new TypeError('Resource error: Not a valid "Descriptor" resource.');
      }
      var handle7 = e[symbolRscHandle];
      if (!handle7) {
        const rep = e[symbolRscRep] || ++captureCnt6;
        captureTable6.set(rep, e);
        handle7 = rscTableCreateOwn(handleTable6, rep);
      }
      dataView(memory0).setInt32(arg6 + 4, handle7, true);
      break;
    }
    case 'err': {
      const e = variant9.val;
      dataView(memory0).setInt8(arg6 + 0, 1, true);
      var val8 = e;
      let enum8;
      switch (val8) {
        case 'access': {
          enum8 = 0;
          break;
        }
        case 'would-block': {
          enum8 = 1;
          break;
        }
        case 'already': {
          enum8 = 2;
          break;
        }
        case 'bad-descriptor': {
          enum8 = 3;
          break;
        }
        case 'busy': {
          enum8 = 4;
          break;
        }
        case 'deadlock': {
          enum8 = 5;
          break;
        }
        case 'quota': {
          enum8 = 6;
          break;
        }
        case 'exist': {
          enum8 = 7;
          break;
        }
        case 'file-too-large': {
          enum8 = 8;
          break;
        }
        case 'illegal-byte-sequence': {
          enum8 = 9;
          break;
        }
        case 'in-progress': {
          enum8 = 10;
          break;
        }
        case 'interrupted': {
          enum8 = 11;
          break;
        }
        case 'invalid': {
          enum8 = 12;
          break;
        }
        case 'io': {
          enum8 = 13;
          break;
        }
        case 'is-directory': {
          enum8 = 14;
          break;
        }
        case 'loop': {
          enum8 = 15;
          break;
        }
        case 'too-many-links': {
          enum8 = 16;
          break;
        }
        case 'message-size': {
          enum8 = 17;
          break;
        }
        case 'name-too-long': {
          enum8 = 18;
          break;
        }
        case 'no-device': {
          enum8 = 19;
          break;
        }
        case 'no-entry': {
          enum8 = 20;
          break;
        }
        case 'no-lock': {
          enum8 = 21;
          break;
        }
        case 'insufficient-memory': {
          enum8 = 22;
          break;
        }
        case 'insufficient-space': {
          enum8 = 23;
          break;
        }
        case 'not-directory': {
          enum8 = 24;
          break;
        }
        case 'not-empty': {
          enum8 = 25;
          break;
        }
        case 'not-recoverable': {
          enum8 = 26;
          break;
        }
        case 'unsupported': {
          enum8 = 27;
          break;
        }
        case 'no-tty': {
          enum8 = 28;
          break;
        }
        case 'no-such-device': {
          enum8 = 29;
          break;
        }
        case 'overflow': {
          enum8 = 30;
          break;
        }
        case 'not-permitted': {
          enum8 = 31;
          break;
        }
        case 'pipe': {
          enum8 = 32;
          break;
        }
        case 'read-only': {
          enum8 = 33;
          break;
        }
        case 'invalid-seek': {
          enum8 = 34;
          break;
        }
        case 'text-file-busy': {
          enum8 = 35;
          break;
        }
        case 'cross-device': {
          enum8 = 36;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val8}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg6 + 4, enum8, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.open-at"][Instruction::Return]', {
    funcName: '[method]descriptor.open-at',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_53_metadata = {
  qualifiedImportFn: 'wasi:filesystem/types@0.2.0#[method]descriptor.readlink-at',
  moduleIdx: null,
};


function trampoline74(arg0, arg1, arg2, arg3) {
  var handle1 = arg0;
  var rep2 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable6.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Descriptor.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  var ptr3 = arg1;
  var len3 = arg2;
  var result3 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr3, len3));
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.readlink-at"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.readlinkAt._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'readlinkAt',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.readlinkAt(result3)};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant6 = ret;
  switch (variant6.tag) {
    case 'ok': {
      const e = variant6.val;
      dataView(memory0).setInt8(arg3 + 0, 0, true);
      
      var encodeRes = _utf8AllocateAndEncode(e, realloc0, memory0);
      var ptr4= encodeRes.ptr;
      var len4 = encodeRes.len;
      
      dataView(memory0).setUint32(arg3 + 8, len4, true);
      dataView(memory0).setUint32(arg3 + 4, ptr4, true);
      break;
    }
    case 'err': {
      const e = variant6.val;
      dataView(memory0).setInt8(arg3 + 0, 1, true);
      var val5 = e;
      let enum5;
      switch (val5) {
        case 'access': {
          enum5 = 0;
          break;
        }
        case 'would-block': {
          enum5 = 1;
          break;
        }
        case 'already': {
          enum5 = 2;
          break;
        }
        case 'bad-descriptor': {
          enum5 = 3;
          break;
        }
        case 'busy': {
          enum5 = 4;
          break;
        }
        case 'deadlock': {
          enum5 = 5;
          break;
        }
        case 'quota': {
          enum5 = 6;
          break;
        }
        case 'exist': {
          enum5 = 7;
          break;
        }
        case 'file-too-large': {
          enum5 = 8;
          break;
        }
        case 'illegal-byte-sequence': {
          enum5 = 9;
          break;
        }
        case 'in-progress': {
          enum5 = 10;
          break;
        }
        case 'interrupted': {
          enum5 = 11;
          break;
        }
        case 'invalid': {
          enum5 = 12;
          break;
        }
        case 'io': {
          enum5 = 13;
          break;
        }
        case 'is-directory': {
          enum5 = 14;
          break;
        }
        case 'loop': {
          enum5 = 15;
          break;
        }
        case 'too-many-links': {
          enum5 = 16;
          break;
        }
        case 'message-size': {
          enum5 = 17;
          break;
        }
        case 'name-too-long': {
          enum5 = 18;
          break;
        }
        case 'no-device': {
          enum5 = 19;
          break;
        }
        case 'no-entry': {
          enum5 = 20;
          break;
        }
        case 'no-lock': {
          enum5 = 21;
          break;
        }
        case 'insufficient-memory': {
          enum5 = 22;
          break;
        }
        case 'insufficient-space': {
          enum5 = 23;
          break;
        }
        case 'not-directory': {
          enum5 = 24;
          break;
        }
        case 'not-empty': {
          enum5 = 25;
          break;
        }
        case 'not-recoverable': {
          enum5 = 26;
          break;
        }
        case 'unsupported': {
          enum5 = 27;
          break;
        }
        case 'no-tty': {
          enum5 = 28;
          break;
        }
        case 'no-such-device': {
          enum5 = 29;
          break;
        }
        case 'overflow': {
          enum5 = 30;
          break;
        }
        case 'not-permitted': {
          enum5 = 31;
          break;
        }
        case 'pipe': {
          enum5 = 32;
          break;
        }
        case 'read-only': {
          enum5 = 33;
          break;
        }
        case 'invalid-seek': {
          enum5 = 34;
          break;
        }
        case 'text-file-busy': {
          enum5 = 35;
          break;
        }
        case 'cross-device': {
          enum5 = 36;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val5}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg3 + 4, enum5, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.readlink-at"][Instruction::Return]', {
    funcName: '[method]descriptor.readlink-at',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_54_metadata = {
  qualifiedImportFn: 'wasi:filesystem/types@0.2.0#[method]descriptor.metadata-hash',
  moduleIdx: null,
};


function trampoline75(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable6.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Descriptor.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.metadata-hash"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.metadataHash._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'metadataHash',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.metadataHash()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant5 = ret;
  switch (variant5.tag) {
    case 'ok': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      var {lower: v3_0, upper: v3_1 } = e;
      dataView(memory0).setBigInt64(arg1 + 8, toUint64(v3_0), true);
      dataView(memory0).setBigInt64(arg1 + 16, toUint64(v3_1), true);
      break;
    }
    case 'err': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val4 = e;
      let enum4;
      switch (val4) {
        case 'access': {
          enum4 = 0;
          break;
        }
        case 'would-block': {
          enum4 = 1;
          break;
        }
        case 'already': {
          enum4 = 2;
          break;
        }
        case 'bad-descriptor': {
          enum4 = 3;
          break;
        }
        case 'busy': {
          enum4 = 4;
          break;
        }
        case 'deadlock': {
          enum4 = 5;
          break;
        }
        case 'quota': {
          enum4 = 6;
          break;
        }
        case 'exist': {
          enum4 = 7;
          break;
        }
        case 'file-too-large': {
          enum4 = 8;
          break;
        }
        case 'illegal-byte-sequence': {
          enum4 = 9;
          break;
        }
        case 'in-progress': {
          enum4 = 10;
          break;
        }
        case 'interrupted': {
          enum4 = 11;
          break;
        }
        case 'invalid': {
          enum4 = 12;
          break;
        }
        case 'io': {
          enum4 = 13;
          break;
        }
        case 'is-directory': {
          enum4 = 14;
          break;
        }
        case 'loop': {
          enum4 = 15;
          break;
        }
        case 'too-many-links': {
          enum4 = 16;
          break;
        }
        case 'message-size': {
          enum4 = 17;
          break;
        }
        case 'name-too-long': {
          enum4 = 18;
          break;
        }
        case 'no-device': {
          enum4 = 19;
          break;
        }
        case 'no-entry': {
          enum4 = 20;
          break;
        }
        case 'no-lock': {
          enum4 = 21;
          break;
        }
        case 'insufficient-memory': {
          enum4 = 22;
          break;
        }
        case 'insufficient-space': {
          enum4 = 23;
          break;
        }
        case 'not-directory': {
          enum4 = 24;
          break;
        }
        case 'not-empty': {
          enum4 = 25;
          break;
        }
        case 'not-recoverable': {
          enum4 = 26;
          break;
        }
        case 'unsupported': {
          enum4 = 27;
          break;
        }
        case 'no-tty': {
          enum4 = 28;
          break;
        }
        case 'no-such-device': {
          enum4 = 29;
          break;
        }
        case 'overflow': {
          enum4 = 30;
          break;
        }
        case 'not-permitted': {
          enum4 = 31;
          break;
        }
        case 'pipe': {
          enum4 = 32;
          break;
        }
        case 'read-only': {
          enum4 = 33;
          break;
        }
        case 'invalid-seek': {
          enum4 = 34;
          break;
        }
        case 'text-file-busy': {
          enum4 = 35;
          break;
        }
        case 'cross-device': {
          enum4 = 36;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val4}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 8, enum4, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.metadata-hash"][Instruction::Return]', {
    funcName: '[method]descriptor.metadata-hash',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_55_metadata = {
  qualifiedImportFn: 'wasi:filesystem/types@0.2.0#[method]descriptor.metadata-hash-at',
  moduleIdx: null,
};


function trampoline76(arg0, arg1, arg2, arg3, arg4) {
  var handle1 = arg0;
  var rep2 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable6.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Descriptor.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  if ((arg1 & 4294967294) !== 0) {
    throw new TypeError('flags have extraneous bits set');
  }
  var flags3 = {
    symlinkFollow: Boolean(arg1 & 1),
  };
  var ptr4 = arg2;
  var len4 = arg3;
  var result4 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr4, len4));
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.metadata-hash-at"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.metadataHashAt._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'metadataHashAt',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.metadataHashAt(flags3, result4)};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant7 = ret;
  switch (variant7.tag) {
    case 'ok': {
      const e = variant7.val;
      dataView(memory0).setInt8(arg4 + 0, 0, true);
      var {lower: v5_0, upper: v5_1 } = e;
      dataView(memory0).setBigInt64(arg4 + 8, toUint64(v5_0), true);
      dataView(memory0).setBigInt64(arg4 + 16, toUint64(v5_1), true);
      break;
    }
    case 'err': {
      const e = variant7.val;
      dataView(memory0).setInt8(arg4 + 0, 1, true);
      var val6 = e;
      let enum6;
      switch (val6) {
        case 'access': {
          enum6 = 0;
          break;
        }
        case 'would-block': {
          enum6 = 1;
          break;
        }
        case 'already': {
          enum6 = 2;
          break;
        }
        case 'bad-descriptor': {
          enum6 = 3;
          break;
        }
        case 'busy': {
          enum6 = 4;
          break;
        }
        case 'deadlock': {
          enum6 = 5;
          break;
        }
        case 'quota': {
          enum6 = 6;
          break;
        }
        case 'exist': {
          enum6 = 7;
          break;
        }
        case 'file-too-large': {
          enum6 = 8;
          break;
        }
        case 'illegal-byte-sequence': {
          enum6 = 9;
          break;
        }
        case 'in-progress': {
          enum6 = 10;
          break;
        }
        case 'interrupted': {
          enum6 = 11;
          break;
        }
        case 'invalid': {
          enum6 = 12;
          break;
        }
        case 'io': {
          enum6 = 13;
          break;
        }
        case 'is-directory': {
          enum6 = 14;
          break;
        }
        case 'loop': {
          enum6 = 15;
          break;
        }
        case 'too-many-links': {
          enum6 = 16;
          break;
        }
        case 'message-size': {
          enum6 = 17;
          break;
        }
        case 'name-too-long': {
          enum6 = 18;
          break;
        }
        case 'no-device': {
          enum6 = 19;
          break;
        }
        case 'no-entry': {
          enum6 = 20;
          break;
        }
        case 'no-lock': {
          enum6 = 21;
          break;
        }
        case 'insufficient-memory': {
          enum6 = 22;
          break;
        }
        case 'insufficient-space': {
          enum6 = 23;
          break;
        }
        case 'not-directory': {
          enum6 = 24;
          break;
        }
        case 'not-empty': {
          enum6 = 25;
          break;
        }
        case 'not-recoverable': {
          enum6 = 26;
          break;
        }
        case 'unsupported': {
          enum6 = 27;
          break;
        }
        case 'no-tty': {
          enum6 = 28;
          break;
        }
        case 'no-such-device': {
          enum6 = 29;
          break;
        }
        case 'overflow': {
          enum6 = 30;
          break;
        }
        case 'not-permitted': {
          enum6 = 31;
          break;
        }
        case 'pipe': {
          enum6 = 32;
          break;
        }
        case 'read-only': {
          enum6 = 33;
          break;
        }
        case 'invalid-seek': {
          enum6 = 34;
          break;
        }
        case 'text-file-busy': {
          enum6 = 35;
          break;
        }
        case 'cross-device': {
          enum6 = 36;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val6}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg4 + 8, enum6, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.metadata-hash-at"][Instruction::Return]', {
    funcName: '[method]descriptor.metadata-hash-at',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_56_metadata = {
  qualifiedImportFn: 'wasi:filesystem/types@0.2.0#[method]directory-entry-stream.read-directory-entry',
  moduleIdx: null,
};


function trampoline77(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable7[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable7.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(DirectoryEntryStream.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]directory-entry-stream.read-directory-entry"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.readDirectoryEntry._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'readDirectoryEntry',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.readDirectoryEntry()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant8 = ret;
  switch (variant8.tag) {
    case 'ok': {
      const e = variant8.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      var variant6 = e;
      if (variant6 === null || variant6=== undefined) {
        dataView(memory0).setInt8(arg1 + 4, 0, true);
      } else {
        const e = variant6;
        dataView(memory0).setInt8(arg1 + 4, 1, true);
        var {type: v3_0, name: v3_1 } = e;
        var val4 = v3_0;
        let enum4;
        switch (val4) {
          case 'unknown': {
            enum4 = 0;
            break;
          }
          case 'block-device': {
            enum4 = 1;
            break;
          }
          case 'character-device': {
            enum4 = 2;
            break;
          }
          case 'directory': {
            enum4 = 3;
            break;
          }
          case 'fifo': {
            enum4 = 4;
            break;
          }
          case 'symbolic-link': {
            enum4 = 5;
            break;
          }
          case 'regular-file': {
            enum4 = 6;
            break;
          }
          case 'socket': {
            enum4 = 7;
            break;
          }
          default: {
            if ((v3_0) instanceof Error) {
              console.error(v3_0);
            }
            
            throw new TypeError(`"${val4}" is not one of the cases of descriptor-type`);
          }
        }
        dataView(memory0).setInt8(arg1 + 8, enum4, true);
        
        var encodeRes = _utf8AllocateAndEncode(v3_1, realloc0, memory0);
        var ptr5= encodeRes.ptr;
        var len5 = encodeRes.len;
        
        dataView(memory0).setUint32(arg1 + 16, len5, true);
        dataView(memory0).setUint32(arg1 + 12, ptr5, true);
      }
      break;
    }
    case 'err': {
      const e = variant8.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val7 = e;
      let enum7;
      switch (val7) {
        case 'access': {
          enum7 = 0;
          break;
        }
        case 'would-block': {
          enum7 = 1;
          break;
        }
        case 'already': {
          enum7 = 2;
          break;
        }
        case 'bad-descriptor': {
          enum7 = 3;
          break;
        }
        case 'busy': {
          enum7 = 4;
          break;
        }
        case 'deadlock': {
          enum7 = 5;
          break;
        }
        case 'quota': {
          enum7 = 6;
          break;
        }
        case 'exist': {
          enum7 = 7;
          break;
        }
        case 'file-too-large': {
          enum7 = 8;
          break;
        }
        case 'illegal-byte-sequence': {
          enum7 = 9;
          break;
        }
        case 'in-progress': {
          enum7 = 10;
          break;
        }
        case 'interrupted': {
          enum7 = 11;
          break;
        }
        case 'invalid': {
          enum7 = 12;
          break;
        }
        case 'io': {
          enum7 = 13;
          break;
        }
        case 'is-directory': {
          enum7 = 14;
          break;
        }
        case 'loop': {
          enum7 = 15;
          break;
        }
        case 'too-many-links': {
          enum7 = 16;
          break;
        }
        case 'message-size': {
          enum7 = 17;
          break;
        }
        case 'name-too-long': {
          enum7 = 18;
          break;
        }
        case 'no-device': {
          enum7 = 19;
          break;
        }
        case 'no-entry': {
          enum7 = 20;
          break;
        }
        case 'no-lock': {
          enum7 = 21;
          break;
        }
        case 'insufficient-memory': {
          enum7 = 22;
          break;
        }
        case 'insufficient-space': {
          enum7 = 23;
          break;
        }
        case 'not-directory': {
          enum7 = 24;
          break;
        }
        case 'not-empty': {
          enum7 = 25;
          break;
        }
        case 'not-recoverable': {
          enum7 = 26;
          break;
        }
        case 'unsupported': {
          enum7 = 27;
          break;
        }
        case 'no-tty': {
          enum7 = 28;
          break;
        }
        case 'no-such-device': {
          enum7 = 29;
          break;
        }
        case 'overflow': {
          enum7 = 30;
          break;
        }
        case 'not-permitted': {
          enum7 = 31;
          break;
        }
        case 'pipe': {
          enum7 = 32;
          break;
        }
        case 'read-only': {
          enum7 = 33;
          break;
        }
        case 'invalid-seek': {
          enum7 = 34;
          break;
        }
        case 'text-file-busy': {
          enum7 = 35;
          break;
        }
        case 'cross-device': {
          enum7 = 36;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val7}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 4, enum7, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]directory-entry-stream.read-directory-entry"][Instruction::Return]', {
    funcName: '[method]directory-entry-stream.read-directory-entry',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_57_metadata = {
  qualifiedImportFn: 'wasi:io/streams@0.2.0#[method]input-stream.read',
  moduleIdx: null,
};


function trampoline78(arg0, arg1, arg2) {
  var handle1 = arg0;
  var rep2 = handleTable2[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable2.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(InputStream.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:io/streams@0.2.0", function="[method]input-stream.read"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.read._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'read',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.read(BigInt.asUintN(64, arg1))};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant6 = ret;
  switch (variant6.tag) {
    case 'ok': {
      const e = variant6.val;
      dataView(memory0).setInt8(arg2 + 0, 0, true);
      var val3 = e;
      var len3 = val3.byteLength;
      var ptr3 = realloc0(0, 0, 1, len3 * 1);
      var src3 = new Uint8Array(val3.buffer || val3, val3.byteOffset, len3 * 1);
      (new Uint8Array(memory0.buffer, ptr3, len3 * 1)).set(src3);
      dataView(memory0).setUint32(arg2 + 8, len3, true);
      dataView(memory0).setUint32(arg2 + 4, ptr3, true);
      break;
    }
    case 'err': {
      const e = variant6.val;
      dataView(memory0).setInt8(arg2 + 0, 1, true);
      var variant5 = e;
      switch (variant5.tag) {
        case 'last-operation-failed': {
          const e = variant5.val;
          dataView(memory0).setInt8(arg2 + 4, 0, true);
          if (!(e instanceof Error$1)) {
            throw new TypeError('Resource error: Not a valid "Error" resource.');
          }
          var handle4 = e[symbolRscHandle];
          if (!handle4) {
            const rep = e[symbolRscRep] || ++captureCnt0;
            captureTable0.set(rep, e);
            handle4 = rscTableCreateOwn(handleTable0, rep);
          }
          dataView(memory0).setInt32(arg2 + 8, handle4, true);
          break;
        }
        case 'closed': {
          dataView(memory0).setInt8(arg2 + 4, 1, true);
          break;
        }
        default: {
          throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant5.tag)}\` (received \`${variant5}\`) specified for \`StreamError\``);
        }
      }
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:io/streams@0.2.0", function="[method]input-stream.read"][Instruction::Return]', {
    funcName: '[method]input-stream.read',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_58_metadata = {
  qualifiedImportFn: 'wasi:io/streams@0.2.0#[method]input-stream.blocking-read',
  moduleIdx: null,
};


function trampoline79(arg0, arg1, arg2) {
  var handle1 = arg0;
  var rep2 = handleTable2[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable2.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(InputStream.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:io/streams@0.2.0", function="[method]input-stream.blocking-read"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.blockingRead._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'blockingRead',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.blockingRead(BigInt.asUintN(64, arg1))};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant6 = ret;
  switch (variant6.tag) {
    case 'ok': {
      const e = variant6.val;
      dataView(memory0).setInt8(arg2 + 0, 0, true);
      var val3 = e;
      var len3 = val3.byteLength;
      var ptr3 = realloc0(0, 0, 1, len3 * 1);
      var src3 = new Uint8Array(val3.buffer || val3, val3.byteOffset, len3 * 1);
      (new Uint8Array(memory0.buffer, ptr3, len3 * 1)).set(src3);
      dataView(memory0).setUint32(arg2 + 8, len3, true);
      dataView(memory0).setUint32(arg2 + 4, ptr3, true);
      break;
    }
    case 'err': {
      const e = variant6.val;
      dataView(memory0).setInt8(arg2 + 0, 1, true);
      var variant5 = e;
      switch (variant5.tag) {
        case 'last-operation-failed': {
          const e = variant5.val;
          dataView(memory0).setInt8(arg2 + 4, 0, true);
          if (!(e instanceof Error$1)) {
            throw new TypeError('Resource error: Not a valid "Error" resource.');
          }
          var handle4 = e[symbolRscHandle];
          if (!handle4) {
            const rep = e[symbolRscRep] || ++captureCnt0;
            captureTable0.set(rep, e);
            handle4 = rscTableCreateOwn(handleTable0, rep);
          }
          dataView(memory0).setInt32(arg2 + 8, handle4, true);
          break;
        }
        case 'closed': {
          dataView(memory0).setInt8(arg2 + 4, 1, true);
          break;
        }
        default: {
          throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant5.tag)}\` (received \`${variant5}\`) specified for \`StreamError\``);
        }
      }
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:io/streams@0.2.0", function="[method]input-stream.blocking-read"][Instruction::Return]', {
    funcName: '[method]input-stream.blocking-read',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_59_metadata = {
  qualifiedImportFn: 'wasi:io/streams@0.2.0#[method]output-stream.check-write',
  moduleIdx: null,
};


function trampoline80(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable3[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable3.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(OutputStream.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:io/streams@0.2.0", function="[method]output-stream.check-write"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.checkWrite._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'checkWrite',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.checkWrite()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant5 = ret;
  switch (variant5.tag) {
    case 'ok': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      dataView(memory0).setBigInt64(arg1 + 8, toUint64(e), true);
      break;
    }
    case 'err': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var variant4 = e;
      switch (variant4.tag) {
        case 'last-operation-failed': {
          const e = variant4.val;
          dataView(memory0).setInt8(arg1 + 8, 0, true);
          if (!(e instanceof Error$1)) {
            throw new TypeError('Resource error: Not a valid "Error" resource.');
          }
          var handle3 = e[symbolRscHandle];
          if (!handle3) {
            const rep = e[symbolRscRep] || ++captureCnt0;
            captureTable0.set(rep, e);
            handle3 = rscTableCreateOwn(handleTable0, rep);
          }
          dataView(memory0).setInt32(arg1 + 12, handle3, true);
          break;
        }
        case 'closed': {
          dataView(memory0).setInt8(arg1 + 8, 1, true);
          break;
        }
        default: {
          throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant4.tag)}\` (received \`${variant4}\`) specified for \`StreamError\``);
        }
      }
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:io/streams@0.2.0", function="[method]output-stream.check-write"][Instruction::Return]', {
    funcName: '[method]output-stream.check-write',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_60_metadata = {
  qualifiedImportFn: 'wasi:io/streams@0.2.0#[method]output-stream.write',
  moduleIdx: null,
};


function trampoline81(arg0, arg1, arg2, arg3) {
  var handle1 = arg0;
  var rep2 = handleTable3[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable3.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(OutputStream.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  var ptr3 = arg1;
  var len3 = arg2;
  var result3 = new Uint8Array(memory0.buffer.slice(ptr3, ptr3 + len3 * 1));
  _debugLog('[iface="wasi:io/streams@0.2.0", function="[method]output-stream.write"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.write._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'write',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.write(result3)};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant6 = ret;
  switch (variant6.tag) {
    case 'ok': {
      const e = variant6.val;
      dataView(memory0).setInt8(arg3 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant6.val;
      dataView(memory0).setInt8(arg3 + 0, 1, true);
      var variant5 = e;
      switch (variant5.tag) {
        case 'last-operation-failed': {
          const e = variant5.val;
          dataView(memory0).setInt8(arg3 + 4, 0, true);
          if (!(e instanceof Error$1)) {
            throw new TypeError('Resource error: Not a valid "Error" resource.');
          }
          var handle4 = e[symbolRscHandle];
          if (!handle4) {
            const rep = e[symbolRscRep] || ++captureCnt0;
            captureTable0.set(rep, e);
            handle4 = rscTableCreateOwn(handleTable0, rep);
          }
          dataView(memory0).setInt32(arg3 + 8, handle4, true);
          break;
        }
        case 'closed': {
          dataView(memory0).setInt8(arg3 + 4, 1, true);
          break;
        }
        default: {
          throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant5.tag)}\` (received \`${variant5}\`) specified for \`StreamError\``);
        }
      }
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:io/streams@0.2.0", function="[method]output-stream.write"][Instruction::Return]', {
    funcName: '[method]output-stream.write',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_61_metadata = {
  qualifiedImportFn: 'wasi:io/streams@0.2.0#[method]output-stream.blocking-write-and-flush',
  moduleIdx: null,
};


function trampoline82(arg0, arg1, arg2, arg3) {
  var handle1 = arg0;
  var rep2 = handleTable3[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable3.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(OutputStream.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  var ptr3 = arg1;
  var len3 = arg2;
  var result3 = new Uint8Array(memory0.buffer.slice(ptr3, ptr3 + len3 * 1));
  _debugLog('[iface="wasi:io/streams@0.2.0", function="[method]output-stream.blocking-write-and-flush"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.blockingWriteAndFlush._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'blockingWriteAndFlush',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.blockingWriteAndFlush(result3)};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant6 = ret;
  switch (variant6.tag) {
    case 'ok': {
      const e = variant6.val;
      dataView(memory0).setInt8(arg3 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant6.val;
      dataView(memory0).setInt8(arg3 + 0, 1, true);
      var variant5 = e;
      switch (variant5.tag) {
        case 'last-operation-failed': {
          const e = variant5.val;
          dataView(memory0).setInt8(arg3 + 4, 0, true);
          if (!(e instanceof Error$1)) {
            throw new TypeError('Resource error: Not a valid "Error" resource.');
          }
          var handle4 = e[symbolRscHandle];
          if (!handle4) {
            const rep = e[symbolRscRep] || ++captureCnt0;
            captureTable0.set(rep, e);
            handle4 = rscTableCreateOwn(handleTable0, rep);
          }
          dataView(memory0).setInt32(arg3 + 8, handle4, true);
          break;
        }
        case 'closed': {
          dataView(memory0).setInt8(arg3 + 4, 1, true);
          break;
        }
        default: {
          throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant5.tag)}\` (received \`${variant5}\`) specified for \`StreamError\``);
        }
      }
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:io/streams@0.2.0", function="[method]output-stream.blocking-write-and-flush"][Instruction::Return]', {
    funcName: '[method]output-stream.blocking-write-and-flush',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_62_metadata = {
  qualifiedImportFn: 'wasi:io/streams@0.2.0#[method]output-stream.blocking-flush',
  moduleIdx: null,
};


function trampoline83(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable3[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable3.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(OutputStream.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:io/streams@0.2.0", function="[method]output-stream.blocking-flush"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.blockingFlush._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'blockingFlush',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.blockingFlush()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant5 = ret;
  switch (variant5.tag) {
    case 'ok': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var variant4 = e;
      switch (variant4.tag) {
        case 'last-operation-failed': {
          const e = variant4.val;
          dataView(memory0).setInt8(arg1 + 4, 0, true);
          if (!(e instanceof Error$1)) {
            throw new TypeError('Resource error: Not a valid "Error" resource.');
          }
          var handle3 = e[symbolRscHandle];
          if (!handle3) {
            const rep = e[symbolRscRep] || ++captureCnt0;
            captureTable0.set(rep, e);
            handle3 = rscTableCreateOwn(handleTable0, rep);
          }
          dataView(memory0).setInt32(arg1 + 8, handle3, true);
          break;
        }
        case 'closed': {
          dataView(memory0).setInt8(arg1 + 4, 1, true);
          break;
        }
        default: {
          throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant4.tag)}\` (received \`${variant4}\`) specified for \`StreamError\``);
        }
      }
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:io/streams@0.2.0", function="[method]output-stream.blocking-flush"][Instruction::Return]', {
    funcName: '[method]output-stream.blocking-flush',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_63_metadata = {
  qualifiedImportFn: 'wasi:io/poll@0.2.0#poll',
  moduleIdx: null,
};


function trampoline84(arg0, arg1, arg2) {
  var len3 = arg1;
  var base3 = arg0;
  var result3 = [];
  for (let i = 0; i < len3; i++) {
    const base = base3 + i * 4;
    var handle1 = dataView(memory0).getInt32(base + 0, true);
    var rep2 = handleTable1[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable1.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Pollable.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    result3.push(rsc0);
  }
  _debugLog('[iface="wasi:io/poll@0.2.0", function="poll"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = poll._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'poll',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  poll(result3);
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var val4 = ret;
  var len4 = val4.length;
  var ptr4 = realloc0(0, 0, 4, len4 * 4);
  var src4 = new Uint8Array(val4.buffer, val4.byteOffset, len4 * 4);
  (new Uint8Array(memory0.buffer, ptr4, len4 * 4)).set(src4);
  dataView(memory0).setUint32(arg2 + 4, len4, true);
  dataView(memory0).setUint32(arg2 + 0, ptr4, true);
  _debugLog('[iface="wasi:io/poll@0.2.0", function="poll"][Instruction::Return]', {
    funcName: 'poll',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_64_metadata = {
  qualifiedImportFn: 'wasi:random/random@0.2.0#get-random-bytes',
  moduleIdx: null,
};


function trampoline85(arg0, arg1) {
  _debugLog('[iface="wasi:random/random@0.2.0", function="get-random-bytes"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = getRandomBytes._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'getRandomBytes',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  getRandomBytes(BigInt.asUintN(64, arg0));
  endCurrentTask(0);
  var val0 = ret;
  var len0 = val0.byteLength;
  var ptr0 = realloc0(0, 0, 1, len0 * 1);
  var src0 = new Uint8Array(val0.buffer || val0, val0.byteOffset, len0 * 1);
  (new Uint8Array(memory0.buffer, ptr0, len0 * 1)).set(src0);
  dataView(memory0).setUint32(arg1 + 4, len0, true);
  dataView(memory0).setUint32(arg1 + 0, ptr0, true);
  _debugLog('[iface="wasi:random/random@0.2.0", function="get-random-bytes"][Instruction::Return]', {
    funcName: 'get-random-bytes',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_65_metadata = {
  qualifiedImportFn: 'wasi:cli/environment@0.2.0#get-environment',
  moduleIdx: null,
};


function trampoline86(arg0) {
  _debugLog('[iface="wasi:cli/environment@0.2.0", function="get-environment"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = getEnvironment._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'getEnvironment',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  getEnvironment();
  endCurrentTask(0);
  var vec3 = ret;
  var len3 = vec3.length;
  var result3 = realloc0(0, 0, 4, len3 * 16);
  for (let i = 0; i < vec3.length; i++) {
    const e = vec3[i];
    const base = result3 + i * 16;var [tuple0_0, tuple0_1] = e;
    
    var encodeRes = _utf8AllocateAndEncode(tuple0_0, realloc0, memory0);
    var ptr1= encodeRes.ptr;
    var len1 = encodeRes.len;
    
    dataView(memory0).setUint32(base + 4, len1, true);
    dataView(memory0).setUint32(base + 0, ptr1, true);
    
    var encodeRes = _utf8AllocateAndEncode(tuple0_1, realloc0, memory0);
    var ptr2= encodeRes.ptr;
    var len2 = encodeRes.len;
    
    dataView(memory0).setUint32(base + 12, len2, true);
    dataView(memory0).setUint32(base + 8, ptr2, true);
  }
  dataView(memory0).setUint32(arg0 + 4, len3, true);
  dataView(memory0).setUint32(arg0 + 0, result3, true);
  _debugLog('[iface="wasi:cli/environment@0.2.0", function="get-environment"][Instruction::Return]', {
    funcName: 'get-environment',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_66_metadata = {
  qualifiedImportFn: 'wasi:cli/environment@0.2.0#get-arguments',
  moduleIdx: null,
};


function trampoline87(arg0) {
  _debugLog('[iface="wasi:cli/environment@0.2.0", function="get-arguments"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = getArguments._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'getArguments',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  getArguments();
  endCurrentTask(0);
  var vec1 = ret;
  var len1 = vec1.length;
  var result1 = realloc0(0, 0, 4, len1 * 8);
  for (let i = 0; i < vec1.length; i++) {
    const e = vec1[i];
    const base = result1 + i * 8;
    var encodeRes = _utf8AllocateAndEncode(e, realloc0, memory0);
    var ptr0= encodeRes.ptr;
    var len0 = encodeRes.len;
    
    dataView(memory0).setUint32(base + 4, len0, true);
    dataView(memory0).setUint32(base + 0, ptr0, true);
  }
  dataView(memory0).setUint32(arg0 + 4, len1, true);
  dataView(memory0).setUint32(arg0 + 0, result1, true);
  _debugLog('[iface="wasi:cli/environment@0.2.0", function="get-arguments"][Instruction::Return]', {
    funcName: 'get-arguments',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_67_metadata = {
  qualifiedImportFn: 'wasi:cli/terminal-stdin@0.2.0#get-terminal-stdin',
  moduleIdx: null,
};

const handleTable4 = [T_FLAG, 0];
const captureTable4= new Map();
let captureCnt4 = 0;
handleTables[4] = handleTable4;

function trampoline88(arg0) {
  _debugLog('[iface="wasi:cli/terminal-stdin@0.2.0", function="get-terminal-stdin"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = getTerminalStdin._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'getTerminalStdin',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  getTerminalStdin();
  endCurrentTask(0);
  var variant1 = ret;
  if (variant1 === null || variant1=== undefined) {
    dataView(memory0).setInt8(arg0 + 0, 0, true);
  } else {
    const e = variant1;
    dataView(memory0).setInt8(arg0 + 0, 1, true);
    if (!(e instanceof TerminalInput)) {
      throw new TypeError('Resource error: Not a valid "TerminalInput" resource.');
    }
    var handle0 = e[symbolRscHandle];
    if (!handle0) {
      const rep = e[symbolRscRep] || ++captureCnt4;
      captureTable4.set(rep, e);
      handle0 = rscTableCreateOwn(handleTable4, rep);
    }
    dataView(memory0).setInt32(arg0 + 4, handle0, true);
  }
  _debugLog('[iface="wasi:cli/terminal-stdin@0.2.0", function="get-terminal-stdin"][Instruction::Return]', {
    funcName: 'get-terminal-stdin',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_68_metadata = {
  qualifiedImportFn: 'wasi:cli/terminal-stdout@0.2.0#get-terminal-stdout',
  moduleIdx: null,
};

const handleTable5 = [T_FLAG, 0];
const captureTable5= new Map();
let captureCnt5 = 0;
handleTables[5] = handleTable5;

function trampoline89(arg0) {
  _debugLog('[iface="wasi:cli/terminal-stdout@0.2.0", function="get-terminal-stdout"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = getTerminalStdout._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'getTerminalStdout',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  getTerminalStdout();
  endCurrentTask(0);
  var variant1 = ret;
  if (variant1 === null || variant1=== undefined) {
    dataView(memory0).setInt8(arg0 + 0, 0, true);
  } else {
    const e = variant1;
    dataView(memory0).setInt8(arg0 + 0, 1, true);
    if (!(e instanceof TerminalOutput)) {
      throw new TypeError('Resource error: Not a valid "TerminalOutput" resource.');
    }
    var handle0 = e[symbolRscHandle];
    if (!handle0) {
      const rep = e[symbolRscRep] || ++captureCnt5;
      captureTable5.set(rep, e);
      handle0 = rscTableCreateOwn(handleTable5, rep);
    }
    dataView(memory0).setInt32(arg0 + 4, handle0, true);
  }
  _debugLog('[iface="wasi:cli/terminal-stdout@0.2.0", function="get-terminal-stdout"][Instruction::Return]', {
    funcName: 'get-terminal-stdout',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_69_metadata = {
  qualifiedImportFn: 'wasi:cli/terminal-stderr@0.2.0#get-terminal-stderr',
  moduleIdx: null,
};


function trampoline90(arg0) {
  _debugLog('[iface="wasi:cli/terminal-stderr@0.2.0", function="get-terminal-stderr"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = getTerminalStderr._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'getTerminalStderr',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  getTerminalStderr();
  endCurrentTask(0);
  var variant1 = ret;
  if (variant1 === null || variant1=== undefined) {
    dataView(memory0).setInt8(arg0 + 0, 0, true);
  } else {
    const e = variant1;
    dataView(memory0).setInt8(arg0 + 0, 1, true);
    if (!(e instanceof TerminalOutput)) {
      throw new TypeError('Resource error: Not a valid "TerminalOutput" resource.');
    }
    var handle0 = e[symbolRscHandle];
    if (!handle0) {
      const rep = e[symbolRscRep] || ++captureCnt5;
      captureTable5.set(rep, e);
      handle0 = rscTableCreateOwn(handleTable5, rep);
    }
    dataView(memory0).setInt32(arg0 + 4, handle0, true);
  }
  _debugLog('[iface="wasi:cli/terminal-stderr@0.2.0", function="get-terminal-stderr"][Instruction::Return]', {
    funcName: 'get-terminal-stderr',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_70_metadata = {
  qualifiedImportFn: 'wasi:io/error@0.2.0#[method]error.to-debug-string',
  moduleIdx: null,
};


function trampoline91(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable0[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable0.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Error$1.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:io/error@0.2.0", function="[method]error.to-debug-string"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.toDebugString._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'toDebugString',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  rsc0.toDebugString();
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  
  var encodeRes = _utf8AllocateAndEncode(ret, realloc1, memory0);
  var ptr3= encodeRes.ptr;
  var len3 = encodeRes.len;
  
  dataView(memory0).setUint32(arg1 + 4, len3, true);
  dataView(memory0).setUint32(arg1 + 0, ptr3, true);
  _debugLog('[iface="wasi:io/error@0.2.0", function="[method]error.to-debug-string"][Instruction::Return]', {
    funcName: '[method]error.to-debug-string',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_71_metadata = {
  qualifiedImportFn: 'wasi:io/poll@0.2.0#poll',
  moduleIdx: null,
};


function trampoline92(arg0, arg1, arg2) {
  var len3 = arg1;
  var base3 = arg0;
  var result3 = [];
  for (let i = 0; i < len3; i++) {
    const base = base3 + i * 4;
    var handle1 = dataView(memory0).getInt32(base + 0, true);
    var rep2 = handleTable1[(handle1 << 1) + 1] & ~T_FLAG;
    var rsc0 = captureTable1.get(rep2);
    if (!rsc0) {
      rsc0 = Object.create(Pollable.prototype);
      Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
      Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
    }
    curResourceBorrows.push(rsc0);
    result3.push(rsc0);
  }
  _debugLog('[iface="wasi:io/poll@0.2.0", function="poll"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = poll._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'poll',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  poll(result3);
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var val4 = ret;
  var len4 = val4.length;
  var ptr4 = realloc1(0, 0, 4, len4 * 4);
  var src4 = new Uint8Array(val4.buffer, val4.byteOffset, len4 * 4);
  (new Uint8Array(memory0.buffer, ptr4, len4 * 4)).set(src4);
  dataView(memory0).setUint32(arg2 + 4, len4, true);
  dataView(memory0).setUint32(arg2 + 0, ptr4, true);
  _debugLog('[iface="wasi:io/poll@0.2.0", function="poll"][Instruction::Return]', {
    funcName: 'poll',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_72_metadata = {
  qualifiedImportFn: 'wasi:io/streams@0.2.0#[method]input-stream.read',
  moduleIdx: null,
};


function trampoline93(arg0, arg1, arg2) {
  var handle1 = arg0;
  var rep2 = handleTable2[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable2.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(InputStream.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:io/streams@0.2.0", function="[method]input-stream.read"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.read._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'read',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.read(BigInt.asUintN(64, arg1))};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant6 = ret;
  switch (variant6.tag) {
    case 'ok': {
      const e = variant6.val;
      dataView(memory0).setInt8(arg2 + 0, 0, true);
      var val3 = e;
      var len3 = val3.byteLength;
      var ptr3 = realloc1(0, 0, 1, len3 * 1);
      var src3 = new Uint8Array(val3.buffer || val3, val3.byteOffset, len3 * 1);
      (new Uint8Array(memory0.buffer, ptr3, len3 * 1)).set(src3);
      dataView(memory0).setUint32(arg2 + 8, len3, true);
      dataView(memory0).setUint32(arg2 + 4, ptr3, true);
      break;
    }
    case 'err': {
      const e = variant6.val;
      dataView(memory0).setInt8(arg2 + 0, 1, true);
      var variant5 = e;
      switch (variant5.tag) {
        case 'last-operation-failed': {
          const e = variant5.val;
          dataView(memory0).setInt8(arg2 + 4, 0, true);
          if (!(e instanceof Error$1)) {
            throw new TypeError('Resource error: Not a valid "Error" resource.');
          }
          var handle4 = e[symbolRscHandle];
          if (!handle4) {
            const rep = e[symbolRscRep] || ++captureCnt0;
            captureTable0.set(rep, e);
            handle4 = rscTableCreateOwn(handleTable0, rep);
          }
          dataView(memory0).setInt32(arg2 + 8, handle4, true);
          break;
        }
        case 'closed': {
          dataView(memory0).setInt8(arg2 + 4, 1, true);
          break;
        }
        default: {
          throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant5.tag)}\` (received \`${variant5}\`) specified for \`StreamError\``);
        }
      }
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:io/streams@0.2.0", function="[method]input-stream.read"][Instruction::Return]', {
    funcName: '[method]input-stream.read',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_73_metadata = {
  qualifiedImportFn: 'wasi:io/streams@0.2.0#[method]input-stream.blocking-read',
  moduleIdx: null,
};


function trampoline94(arg0, arg1, arg2) {
  var handle1 = arg0;
  var rep2 = handleTable2[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable2.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(InputStream.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:io/streams@0.2.0", function="[method]input-stream.blocking-read"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.blockingRead._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'blockingRead',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.blockingRead(BigInt.asUintN(64, arg1))};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant6 = ret;
  switch (variant6.tag) {
    case 'ok': {
      const e = variant6.val;
      dataView(memory0).setInt8(arg2 + 0, 0, true);
      var val3 = e;
      var len3 = val3.byteLength;
      var ptr3 = realloc1(0, 0, 1, len3 * 1);
      var src3 = new Uint8Array(val3.buffer || val3, val3.byteOffset, len3 * 1);
      (new Uint8Array(memory0.buffer, ptr3, len3 * 1)).set(src3);
      dataView(memory0).setUint32(arg2 + 8, len3, true);
      dataView(memory0).setUint32(arg2 + 4, ptr3, true);
      break;
    }
    case 'err': {
      const e = variant6.val;
      dataView(memory0).setInt8(arg2 + 0, 1, true);
      var variant5 = e;
      switch (variant5.tag) {
        case 'last-operation-failed': {
          const e = variant5.val;
          dataView(memory0).setInt8(arg2 + 4, 0, true);
          if (!(e instanceof Error$1)) {
            throw new TypeError('Resource error: Not a valid "Error" resource.');
          }
          var handle4 = e[symbolRscHandle];
          if (!handle4) {
            const rep = e[symbolRscRep] || ++captureCnt0;
            captureTable0.set(rep, e);
            handle4 = rscTableCreateOwn(handleTable0, rep);
          }
          dataView(memory0).setInt32(arg2 + 8, handle4, true);
          break;
        }
        case 'closed': {
          dataView(memory0).setInt8(arg2 + 4, 1, true);
          break;
        }
        default: {
          throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant5.tag)}\` (received \`${variant5}\`) specified for \`StreamError\``);
        }
      }
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:io/streams@0.2.0", function="[method]input-stream.blocking-read"][Instruction::Return]', {
    funcName: '[method]input-stream.blocking-read',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_74_metadata = {
  qualifiedImportFn: 'wasi:io/streams@0.2.0#[method]input-stream.skip',
  moduleIdx: null,
};


function trampoline95(arg0, arg1, arg2) {
  var handle1 = arg0;
  var rep2 = handleTable2[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable2.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(InputStream.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:io/streams@0.2.0", function="[method]input-stream.skip"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.skip._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'skip',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.skip(BigInt.asUintN(64, arg1))};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant5 = ret;
  switch (variant5.tag) {
    case 'ok': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg2 + 0, 0, true);
      dataView(memory0).setBigInt64(arg2 + 8, toUint64(e), true);
      break;
    }
    case 'err': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg2 + 0, 1, true);
      var variant4 = e;
      switch (variant4.tag) {
        case 'last-operation-failed': {
          const e = variant4.val;
          dataView(memory0).setInt8(arg2 + 8, 0, true);
          if (!(e instanceof Error$1)) {
            throw new TypeError('Resource error: Not a valid "Error" resource.');
          }
          var handle3 = e[symbolRscHandle];
          if (!handle3) {
            const rep = e[symbolRscRep] || ++captureCnt0;
            captureTable0.set(rep, e);
            handle3 = rscTableCreateOwn(handleTable0, rep);
          }
          dataView(memory0).setInt32(arg2 + 12, handle3, true);
          break;
        }
        case 'closed': {
          dataView(memory0).setInt8(arg2 + 8, 1, true);
          break;
        }
        default: {
          throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant4.tag)}\` (received \`${variant4}\`) specified for \`StreamError\``);
        }
      }
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:io/streams@0.2.0", function="[method]input-stream.skip"][Instruction::Return]', {
    funcName: '[method]input-stream.skip',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_75_metadata = {
  qualifiedImportFn: 'wasi:io/streams@0.2.0#[method]input-stream.blocking-skip',
  moduleIdx: null,
};


function trampoline96(arg0, arg1, arg2) {
  var handle1 = arg0;
  var rep2 = handleTable2[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable2.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(InputStream.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:io/streams@0.2.0", function="[method]input-stream.blocking-skip"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.blockingSkip._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'blockingSkip',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.blockingSkip(BigInt.asUintN(64, arg1))};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant5 = ret;
  switch (variant5.tag) {
    case 'ok': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg2 + 0, 0, true);
      dataView(memory0).setBigInt64(arg2 + 8, toUint64(e), true);
      break;
    }
    case 'err': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg2 + 0, 1, true);
      var variant4 = e;
      switch (variant4.tag) {
        case 'last-operation-failed': {
          const e = variant4.val;
          dataView(memory0).setInt8(arg2 + 8, 0, true);
          if (!(e instanceof Error$1)) {
            throw new TypeError('Resource error: Not a valid "Error" resource.');
          }
          var handle3 = e[symbolRscHandle];
          if (!handle3) {
            const rep = e[symbolRscRep] || ++captureCnt0;
            captureTable0.set(rep, e);
            handle3 = rscTableCreateOwn(handleTable0, rep);
          }
          dataView(memory0).setInt32(arg2 + 12, handle3, true);
          break;
        }
        case 'closed': {
          dataView(memory0).setInt8(arg2 + 8, 1, true);
          break;
        }
        default: {
          throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant4.tag)}\` (received \`${variant4}\`) specified for \`StreamError\``);
        }
      }
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:io/streams@0.2.0", function="[method]input-stream.blocking-skip"][Instruction::Return]', {
    funcName: '[method]input-stream.blocking-skip',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_76_metadata = {
  qualifiedImportFn: 'wasi:io/streams@0.2.0#[method]output-stream.flush',
  moduleIdx: null,
};


function trampoline97(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable3[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable3.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(OutputStream.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:io/streams@0.2.0", function="[method]output-stream.flush"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.flush._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'flush',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.flush()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant5 = ret;
  switch (variant5.tag) {
    case 'ok': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var variant4 = e;
      switch (variant4.tag) {
        case 'last-operation-failed': {
          const e = variant4.val;
          dataView(memory0).setInt8(arg1 + 4, 0, true);
          if (!(e instanceof Error$1)) {
            throw new TypeError('Resource error: Not a valid "Error" resource.');
          }
          var handle3 = e[symbolRscHandle];
          if (!handle3) {
            const rep = e[symbolRscRep] || ++captureCnt0;
            captureTable0.set(rep, e);
            handle3 = rscTableCreateOwn(handleTable0, rep);
          }
          dataView(memory0).setInt32(arg1 + 8, handle3, true);
          break;
        }
        case 'closed': {
          dataView(memory0).setInt8(arg1 + 4, 1, true);
          break;
        }
        default: {
          throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant4.tag)}\` (received \`${variant4}\`) specified for \`StreamError\``);
        }
      }
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:io/streams@0.2.0", function="[method]output-stream.flush"][Instruction::Return]', {
    funcName: '[method]output-stream.flush',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_77_metadata = {
  qualifiedImportFn: 'wasi:io/streams@0.2.0#[method]output-stream.write-zeroes',
  moduleIdx: null,
};


function trampoline98(arg0, arg1, arg2) {
  var handle1 = arg0;
  var rep2 = handleTable3[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable3.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(OutputStream.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:io/streams@0.2.0", function="[method]output-stream.write-zeroes"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.writeZeroes._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'writeZeroes',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.writeZeroes(BigInt.asUintN(64, arg1))};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant5 = ret;
  switch (variant5.tag) {
    case 'ok': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg2 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg2 + 0, 1, true);
      var variant4 = e;
      switch (variant4.tag) {
        case 'last-operation-failed': {
          const e = variant4.val;
          dataView(memory0).setInt8(arg2 + 4, 0, true);
          if (!(e instanceof Error$1)) {
            throw new TypeError('Resource error: Not a valid "Error" resource.');
          }
          var handle3 = e[symbolRscHandle];
          if (!handle3) {
            const rep = e[symbolRscRep] || ++captureCnt0;
            captureTable0.set(rep, e);
            handle3 = rscTableCreateOwn(handleTable0, rep);
          }
          dataView(memory0).setInt32(arg2 + 8, handle3, true);
          break;
        }
        case 'closed': {
          dataView(memory0).setInt8(arg2 + 4, 1, true);
          break;
        }
        default: {
          throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant4.tag)}\` (received \`${variant4}\`) specified for \`StreamError\``);
        }
      }
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:io/streams@0.2.0", function="[method]output-stream.write-zeroes"][Instruction::Return]', {
    funcName: '[method]output-stream.write-zeroes',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_78_metadata = {
  qualifiedImportFn: 'wasi:io/streams@0.2.0#[method]output-stream.blocking-write-zeroes-and-flush',
  moduleIdx: null,
};


function trampoline99(arg0, arg1, arg2) {
  var handle1 = arg0;
  var rep2 = handleTable3[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable3.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(OutputStream.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:io/streams@0.2.0", function="[method]output-stream.blocking-write-zeroes-and-flush"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.blockingWriteZeroesAndFlush._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'blockingWriteZeroesAndFlush',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.blockingWriteZeroesAndFlush(BigInt.asUintN(64, arg1))};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant5 = ret;
  switch (variant5.tag) {
    case 'ok': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg2 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg2 + 0, 1, true);
      var variant4 = e;
      switch (variant4.tag) {
        case 'last-operation-failed': {
          const e = variant4.val;
          dataView(memory0).setInt8(arg2 + 4, 0, true);
          if (!(e instanceof Error$1)) {
            throw new TypeError('Resource error: Not a valid "Error" resource.');
          }
          var handle3 = e[symbolRscHandle];
          if (!handle3) {
            const rep = e[symbolRscRep] || ++captureCnt0;
            captureTable0.set(rep, e);
            handle3 = rscTableCreateOwn(handleTable0, rep);
          }
          dataView(memory0).setInt32(arg2 + 8, handle3, true);
          break;
        }
        case 'closed': {
          dataView(memory0).setInt8(arg2 + 4, 1, true);
          break;
        }
        default: {
          throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant4.tag)}\` (received \`${variant4}\`) specified for \`StreamError\``);
        }
      }
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:io/streams@0.2.0", function="[method]output-stream.blocking-write-zeroes-and-flush"][Instruction::Return]', {
    funcName: '[method]output-stream.blocking-write-zeroes-and-flush',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_79_metadata = {
  qualifiedImportFn: 'wasi:io/streams@0.2.0#[method]output-stream.splice',
  moduleIdx: null,
};


function trampoline100(arg0, arg1, arg2, arg3) {
  var handle1 = arg0;
  var rep2 = handleTable3[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable3.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(OutputStream.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  var handle4 = arg1;
  var rep5 = handleTable2[(handle4 << 1) + 1] & ~T_FLAG;
  var rsc3 = captureTable2.get(rep5);
  if (!rsc3) {
    rsc3 = Object.create(InputStream.prototype);
    Object.defineProperty(rsc3, symbolRscHandle, { writable: true, value: handle4});
    Object.defineProperty(rsc3, symbolRscRep, { writable: true, value: rep5});
  }
  curResourceBorrows.push(rsc3);
  _debugLog('[iface="wasi:io/streams@0.2.0", function="[method]output-stream.splice"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.splice._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'splice',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.splice(rsc3, BigInt.asUintN(64, arg2))};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant8 = ret;
  switch (variant8.tag) {
    case 'ok': {
      const e = variant8.val;
      dataView(memory0).setInt8(arg3 + 0, 0, true);
      dataView(memory0).setBigInt64(arg3 + 8, toUint64(e), true);
      break;
    }
    case 'err': {
      const e = variant8.val;
      dataView(memory0).setInt8(arg3 + 0, 1, true);
      var variant7 = e;
      switch (variant7.tag) {
        case 'last-operation-failed': {
          const e = variant7.val;
          dataView(memory0).setInt8(arg3 + 8, 0, true);
          if (!(e instanceof Error$1)) {
            throw new TypeError('Resource error: Not a valid "Error" resource.');
          }
          var handle6 = e[symbolRscHandle];
          if (!handle6) {
            const rep = e[symbolRscRep] || ++captureCnt0;
            captureTable0.set(rep, e);
            handle6 = rscTableCreateOwn(handleTable0, rep);
          }
          dataView(memory0).setInt32(arg3 + 12, handle6, true);
          break;
        }
        case 'closed': {
          dataView(memory0).setInt8(arg3 + 8, 1, true);
          break;
        }
        default: {
          throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant7.tag)}\` (received \`${variant7}\`) specified for \`StreamError\``);
        }
      }
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:io/streams@0.2.0", function="[method]output-stream.splice"][Instruction::Return]', {
    funcName: '[method]output-stream.splice',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_80_metadata = {
  qualifiedImportFn: 'wasi:io/streams@0.2.0#[method]output-stream.blocking-splice',
  moduleIdx: null,
};


function trampoline101(arg0, arg1, arg2, arg3) {
  var handle1 = arg0;
  var rep2 = handleTable3[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable3.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(OutputStream.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  var handle4 = arg1;
  var rep5 = handleTable2[(handle4 << 1) + 1] & ~T_FLAG;
  var rsc3 = captureTable2.get(rep5);
  if (!rsc3) {
    rsc3 = Object.create(InputStream.prototype);
    Object.defineProperty(rsc3, symbolRscHandle, { writable: true, value: handle4});
    Object.defineProperty(rsc3, symbolRscRep, { writable: true, value: rep5});
  }
  curResourceBorrows.push(rsc3);
  _debugLog('[iface="wasi:io/streams@0.2.0", function="[method]output-stream.blocking-splice"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.blockingSplice._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'blockingSplice',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.blockingSplice(rsc3, BigInt.asUintN(64, arg2))};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant8 = ret;
  switch (variant8.tag) {
    case 'ok': {
      const e = variant8.val;
      dataView(memory0).setInt8(arg3 + 0, 0, true);
      dataView(memory0).setBigInt64(arg3 + 8, toUint64(e), true);
      break;
    }
    case 'err': {
      const e = variant8.val;
      dataView(memory0).setInt8(arg3 + 0, 1, true);
      var variant7 = e;
      switch (variant7.tag) {
        case 'last-operation-failed': {
          const e = variant7.val;
          dataView(memory0).setInt8(arg3 + 8, 0, true);
          if (!(e instanceof Error$1)) {
            throw new TypeError('Resource error: Not a valid "Error" resource.');
          }
          var handle6 = e[symbolRscHandle];
          if (!handle6) {
            const rep = e[symbolRscRep] || ++captureCnt0;
            captureTable0.set(rep, e);
            handle6 = rscTableCreateOwn(handleTable0, rep);
          }
          dataView(memory0).setInt32(arg3 + 12, handle6, true);
          break;
        }
        case 'closed': {
          dataView(memory0).setInt8(arg3 + 8, 1, true);
          break;
        }
        default: {
          throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant7.tag)}\` (received \`${variant7}\`) specified for \`StreamError\``);
        }
      }
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:io/streams@0.2.0", function="[method]output-stream.blocking-splice"][Instruction::Return]', {
    funcName: '[method]output-stream.blocking-splice',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_81_metadata = {
  qualifiedImportFn: 'wasi:filesystem/types@0.2.0#[method]descriptor.read',
  moduleIdx: null,
};


function trampoline102(arg0, arg1, arg2, arg3) {
  var handle1 = arg0;
  var rep2 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable6.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Descriptor.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.read"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.read._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'read',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.read(BigInt.asUintN(64, arg1), BigInt.asUintN(64, arg2))};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant6 = ret;
  switch (variant6.tag) {
    case 'ok': {
      const e = variant6.val;
      dataView(memory0).setInt8(arg3 + 0, 0, true);
      var [tuple3_0, tuple3_1] = e;
      var val4 = tuple3_0;
      var len4 = val4.byteLength;
      var ptr4 = realloc1(0, 0, 1, len4 * 1);
      var src4 = new Uint8Array(val4.buffer || val4, val4.byteOffset, len4 * 1);
      (new Uint8Array(memory0.buffer, ptr4, len4 * 1)).set(src4);
      dataView(memory0).setUint32(arg3 + 8, len4, true);
      dataView(memory0).setUint32(arg3 + 4, ptr4, true);
      dataView(memory0).setInt8(arg3 + 12, tuple3_1 ? 1 : 0, true);
      break;
    }
    case 'err': {
      const e = variant6.val;
      dataView(memory0).setInt8(arg3 + 0, 1, true);
      var val5 = e;
      let enum5;
      switch (val5) {
        case 'access': {
          enum5 = 0;
          break;
        }
        case 'would-block': {
          enum5 = 1;
          break;
        }
        case 'already': {
          enum5 = 2;
          break;
        }
        case 'bad-descriptor': {
          enum5 = 3;
          break;
        }
        case 'busy': {
          enum5 = 4;
          break;
        }
        case 'deadlock': {
          enum5 = 5;
          break;
        }
        case 'quota': {
          enum5 = 6;
          break;
        }
        case 'exist': {
          enum5 = 7;
          break;
        }
        case 'file-too-large': {
          enum5 = 8;
          break;
        }
        case 'illegal-byte-sequence': {
          enum5 = 9;
          break;
        }
        case 'in-progress': {
          enum5 = 10;
          break;
        }
        case 'interrupted': {
          enum5 = 11;
          break;
        }
        case 'invalid': {
          enum5 = 12;
          break;
        }
        case 'io': {
          enum5 = 13;
          break;
        }
        case 'is-directory': {
          enum5 = 14;
          break;
        }
        case 'loop': {
          enum5 = 15;
          break;
        }
        case 'too-many-links': {
          enum5 = 16;
          break;
        }
        case 'message-size': {
          enum5 = 17;
          break;
        }
        case 'name-too-long': {
          enum5 = 18;
          break;
        }
        case 'no-device': {
          enum5 = 19;
          break;
        }
        case 'no-entry': {
          enum5 = 20;
          break;
        }
        case 'no-lock': {
          enum5 = 21;
          break;
        }
        case 'insufficient-memory': {
          enum5 = 22;
          break;
        }
        case 'insufficient-space': {
          enum5 = 23;
          break;
        }
        case 'not-directory': {
          enum5 = 24;
          break;
        }
        case 'not-empty': {
          enum5 = 25;
          break;
        }
        case 'not-recoverable': {
          enum5 = 26;
          break;
        }
        case 'unsupported': {
          enum5 = 27;
          break;
        }
        case 'no-tty': {
          enum5 = 28;
          break;
        }
        case 'no-such-device': {
          enum5 = 29;
          break;
        }
        case 'overflow': {
          enum5 = 30;
          break;
        }
        case 'not-permitted': {
          enum5 = 31;
          break;
        }
        case 'pipe': {
          enum5 = 32;
          break;
        }
        case 'read-only': {
          enum5 = 33;
          break;
        }
        case 'invalid-seek': {
          enum5 = 34;
          break;
        }
        case 'text-file-busy': {
          enum5 = 35;
          break;
        }
        case 'cross-device': {
          enum5 = 36;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val5}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg3 + 4, enum5, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.read"][Instruction::Return]', {
    funcName: '[method]descriptor.read',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_82_metadata = {
  qualifiedImportFn: 'wasi:filesystem/types@0.2.0#[method]descriptor.readlink-at',
  moduleIdx: null,
};


function trampoline103(arg0, arg1, arg2, arg3) {
  var handle1 = arg0;
  var rep2 = handleTable6[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable6.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Descriptor.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  var ptr3 = arg1;
  var len3 = arg2;
  var result3 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr3, len3));
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.readlink-at"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.readlinkAt._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'readlinkAt',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.readlinkAt(result3)};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant6 = ret;
  switch (variant6.tag) {
    case 'ok': {
      const e = variant6.val;
      dataView(memory0).setInt8(arg3 + 0, 0, true);
      
      var encodeRes = _utf8AllocateAndEncode(e, realloc1, memory0);
      var ptr4= encodeRes.ptr;
      var len4 = encodeRes.len;
      
      dataView(memory0).setUint32(arg3 + 8, len4, true);
      dataView(memory0).setUint32(arg3 + 4, ptr4, true);
      break;
    }
    case 'err': {
      const e = variant6.val;
      dataView(memory0).setInt8(arg3 + 0, 1, true);
      var val5 = e;
      let enum5;
      switch (val5) {
        case 'access': {
          enum5 = 0;
          break;
        }
        case 'would-block': {
          enum5 = 1;
          break;
        }
        case 'already': {
          enum5 = 2;
          break;
        }
        case 'bad-descriptor': {
          enum5 = 3;
          break;
        }
        case 'busy': {
          enum5 = 4;
          break;
        }
        case 'deadlock': {
          enum5 = 5;
          break;
        }
        case 'quota': {
          enum5 = 6;
          break;
        }
        case 'exist': {
          enum5 = 7;
          break;
        }
        case 'file-too-large': {
          enum5 = 8;
          break;
        }
        case 'illegal-byte-sequence': {
          enum5 = 9;
          break;
        }
        case 'in-progress': {
          enum5 = 10;
          break;
        }
        case 'interrupted': {
          enum5 = 11;
          break;
        }
        case 'invalid': {
          enum5 = 12;
          break;
        }
        case 'io': {
          enum5 = 13;
          break;
        }
        case 'is-directory': {
          enum5 = 14;
          break;
        }
        case 'loop': {
          enum5 = 15;
          break;
        }
        case 'too-many-links': {
          enum5 = 16;
          break;
        }
        case 'message-size': {
          enum5 = 17;
          break;
        }
        case 'name-too-long': {
          enum5 = 18;
          break;
        }
        case 'no-device': {
          enum5 = 19;
          break;
        }
        case 'no-entry': {
          enum5 = 20;
          break;
        }
        case 'no-lock': {
          enum5 = 21;
          break;
        }
        case 'insufficient-memory': {
          enum5 = 22;
          break;
        }
        case 'insufficient-space': {
          enum5 = 23;
          break;
        }
        case 'not-directory': {
          enum5 = 24;
          break;
        }
        case 'not-empty': {
          enum5 = 25;
          break;
        }
        case 'not-recoverable': {
          enum5 = 26;
          break;
        }
        case 'unsupported': {
          enum5 = 27;
          break;
        }
        case 'no-tty': {
          enum5 = 28;
          break;
        }
        case 'no-such-device': {
          enum5 = 29;
          break;
        }
        case 'overflow': {
          enum5 = 30;
          break;
        }
        case 'not-permitted': {
          enum5 = 31;
          break;
        }
        case 'pipe': {
          enum5 = 32;
          break;
        }
        case 'read-only': {
          enum5 = 33;
          break;
        }
        case 'invalid-seek': {
          enum5 = 34;
          break;
        }
        case 'text-file-busy': {
          enum5 = 35;
          break;
        }
        case 'cross-device': {
          enum5 = 36;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val5}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg3 + 4, enum5, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]descriptor.readlink-at"][Instruction::Return]', {
    funcName: '[method]descriptor.readlink-at',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_83_metadata = {
  qualifiedImportFn: 'wasi:filesystem/types@0.2.0#[method]directory-entry-stream.read-directory-entry',
  moduleIdx: null,
};


function trampoline104(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable7[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable7.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(DirectoryEntryStream.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]directory-entry-stream.read-directory-entry"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.readDirectoryEntry._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'readDirectoryEntry',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.readDirectoryEntry()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant8 = ret;
  switch (variant8.tag) {
    case 'ok': {
      const e = variant8.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      var variant6 = e;
      if (variant6 === null || variant6=== undefined) {
        dataView(memory0).setInt8(arg1 + 4, 0, true);
      } else {
        const e = variant6;
        dataView(memory0).setInt8(arg1 + 4, 1, true);
        var {type: v3_0, name: v3_1 } = e;
        var val4 = v3_0;
        let enum4;
        switch (val4) {
          case 'unknown': {
            enum4 = 0;
            break;
          }
          case 'block-device': {
            enum4 = 1;
            break;
          }
          case 'character-device': {
            enum4 = 2;
            break;
          }
          case 'directory': {
            enum4 = 3;
            break;
          }
          case 'fifo': {
            enum4 = 4;
            break;
          }
          case 'symbolic-link': {
            enum4 = 5;
            break;
          }
          case 'regular-file': {
            enum4 = 6;
            break;
          }
          case 'socket': {
            enum4 = 7;
            break;
          }
          default: {
            if ((v3_0) instanceof Error) {
              console.error(v3_0);
            }
            
            throw new TypeError(`"${val4}" is not one of the cases of descriptor-type`);
          }
        }
        dataView(memory0).setInt8(arg1 + 8, enum4, true);
        
        var encodeRes = _utf8AllocateAndEncode(v3_1, realloc1, memory0);
        var ptr5= encodeRes.ptr;
        var len5 = encodeRes.len;
        
        dataView(memory0).setUint32(arg1 + 16, len5, true);
        dataView(memory0).setUint32(arg1 + 12, ptr5, true);
      }
      break;
    }
    case 'err': {
      const e = variant8.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val7 = e;
      let enum7;
      switch (val7) {
        case 'access': {
          enum7 = 0;
          break;
        }
        case 'would-block': {
          enum7 = 1;
          break;
        }
        case 'already': {
          enum7 = 2;
          break;
        }
        case 'bad-descriptor': {
          enum7 = 3;
          break;
        }
        case 'busy': {
          enum7 = 4;
          break;
        }
        case 'deadlock': {
          enum7 = 5;
          break;
        }
        case 'quota': {
          enum7 = 6;
          break;
        }
        case 'exist': {
          enum7 = 7;
          break;
        }
        case 'file-too-large': {
          enum7 = 8;
          break;
        }
        case 'illegal-byte-sequence': {
          enum7 = 9;
          break;
        }
        case 'in-progress': {
          enum7 = 10;
          break;
        }
        case 'interrupted': {
          enum7 = 11;
          break;
        }
        case 'invalid': {
          enum7 = 12;
          break;
        }
        case 'io': {
          enum7 = 13;
          break;
        }
        case 'is-directory': {
          enum7 = 14;
          break;
        }
        case 'loop': {
          enum7 = 15;
          break;
        }
        case 'too-many-links': {
          enum7 = 16;
          break;
        }
        case 'message-size': {
          enum7 = 17;
          break;
        }
        case 'name-too-long': {
          enum7 = 18;
          break;
        }
        case 'no-device': {
          enum7 = 19;
          break;
        }
        case 'no-entry': {
          enum7 = 20;
          break;
        }
        case 'no-lock': {
          enum7 = 21;
          break;
        }
        case 'insufficient-memory': {
          enum7 = 22;
          break;
        }
        case 'insufficient-space': {
          enum7 = 23;
          break;
        }
        case 'not-directory': {
          enum7 = 24;
          break;
        }
        case 'not-empty': {
          enum7 = 25;
          break;
        }
        case 'not-recoverable': {
          enum7 = 26;
          break;
        }
        case 'unsupported': {
          enum7 = 27;
          break;
        }
        case 'no-tty': {
          enum7 = 28;
          break;
        }
        case 'no-such-device': {
          enum7 = 29;
          break;
        }
        case 'overflow': {
          enum7 = 30;
          break;
        }
        case 'not-permitted': {
          enum7 = 31;
          break;
        }
        case 'pipe': {
          enum7 = 32;
          break;
        }
        case 'read-only': {
          enum7 = 33;
          break;
        }
        case 'invalid-seek': {
          enum7 = 34;
          break;
        }
        case 'text-file-busy': {
          enum7 = 35;
          break;
        }
        case 'cross-device': {
          enum7 = 36;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val7}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 4, enum7, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:filesystem/types@0.2.0", function="[method]directory-entry-stream.read-directory-entry"][Instruction::Return]', {
    funcName: '[method]directory-entry-stream.read-directory-entry',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_84_metadata = {
  qualifiedImportFn: 'wasi:sockets/udp@0.2.0#[method]udp-socket.start-bind',
  moduleIdx: null,
};


function trampoline105(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14) {
  var handle1 = arg0;
  var rep2 = handleTable9[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable9.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(UdpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  var handle4 = arg1;
  var rep5 = handleTable8[(handle4 << 1) + 1] & ~T_FLAG;
  var rsc3 = captureTable8.get(rep5);
  if (!rsc3) {
    rsc3 = Object.create(Network.prototype);
    Object.defineProperty(rsc3, symbolRscHandle, { writable: true, value: handle4});
    Object.defineProperty(rsc3, symbolRscRep, { writable: true, value: rep5});
  }
  curResourceBorrows.push(rsc3);
  let variant6;
  switch (arg2) {
    case 0: {
      variant6= {
        tag: 'ipv4',
        val: {
          port: clampGuest(arg3, 0, 65535),
          address: [clampGuest(arg4, 0, 255), clampGuest(arg5, 0, 255), clampGuest(arg6, 0, 255), clampGuest(arg7, 0, 255)],
        }
      };
      break;
    }
    case 1: {
      variant6= {
        tag: 'ipv6',
        val: {
          port: clampGuest(arg3, 0, 65535),
          flowInfo: arg4 >>> 0,
          address: [clampGuest(arg5, 0, 65535), clampGuest(arg6, 0, 65535), clampGuest(arg7, 0, 65535), clampGuest(arg8, 0, 65535), clampGuest(arg9, 0, 65535), clampGuest(arg10, 0, 65535), clampGuest(arg11, 0, 65535), clampGuest(arg12, 0, 65535)],
          scopeId: arg13 >>> 0,
        }
      };
      break;
    }
    default: {
      throw new TypeError('invalid variant discriminant for IpSocketAddress');
    }
  }
  _debugLog('[iface="wasi:sockets/udp@0.2.0", function="[method]udp-socket.start-bind"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.startBind._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'startBind',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.startBind(rsc3, variant6)};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant8 = ret;
  switch (variant8.tag) {
    case 'ok': {
      const e = variant8.val;
      dataView(memory0).setInt8(arg14 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant8.val;
      dataView(memory0).setInt8(arg14 + 0, 1, true);
      var val7 = e;
      let enum7;
      switch (val7) {
        case 'unknown': {
          enum7 = 0;
          break;
        }
        case 'access-denied': {
          enum7 = 1;
          break;
        }
        case 'not-supported': {
          enum7 = 2;
          break;
        }
        case 'invalid-argument': {
          enum7 = 3;
          break;
        }
        case 'out-of-memory': {
          enum7 = 4;
          break;
        }
        case 'timeout': {
          enum7 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum7 = 6;
          break;
        }
        case 'not-in-progress': {
          enum7 = 7;
          break;
        }
        case 'would-block': {
          enum7 = 8;
          break;
        }
        case 'invalid-state': {
          enum7 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum7 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum7 = 11;
          break;
        }
        case 'address-in-use': {
          enum7 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum7 = 13;
          break;
        }
        case 'connection-refused': {
          enum7 = 14;
          break;
        }
        case 'connection-reset': {
          enum7 = 15;
          break;
        }
        case 'connection-aborted': {
          enum7 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum7 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum7 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum7 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum7 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val7}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg14 + 1, enum7, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/udp@0.2.0", function="[method]udp-socket.start-bind"][Instruction::Return]', {
    funcName: '[method]udp-socket.start-bind',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_85_metadata = {
  qualifiedImportFn: 'wasi:sockets/udp@0.2.0#[method]udp-socket.finish-bind',
  moduleIdx: null,
};


function trampoline106(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable9[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable9.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(UdpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/udp@0.2.0", function="[method]udp-socket.finish-bind"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.finishBind._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'finishBind',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.finishBind()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant4 = ret;
  switch (variant4.tag) {
    case 'ok': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val3 = e;
      let enum3;
      switch (val3) {
        case 'unknown': {
          enum3 = 0;
          break;
        }
        case 'access-denied': {
          enum3 = 1;
          break;
        }
        case 'not-supported': {
          enum3 = 2;
          break;
        }
        case 'invalid-argument': {
          enum3 = 3;
          break;
        }
        case 'out-of-memory': {
          enum3 = 4;
          break;
        }
        case 'timeout': {
          enum3 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum3 = 6;
          break;
        }
        case 'not-in-progress': {
          enum3 = 7;
          break;
        }
        case 'would-block': {
          enum3 = 8;
          break;
        }
        case 'invalid-state': {
          enum3 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum3 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum3 = 11;
          break;
        }
        case 'address-in-use': {
          enum3 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum3 = 13;
          break;
        }
        case 'connection-refused': {
          enum3 = 14;
          break;
        }
        case 'connection-reset': {
          enum3 = 15;
          break;
        }
        case 'connection-aborted': {
          enum3 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum3 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum3 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum3 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum3 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val3}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 1, enum3, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/udp@0.2.0", function="[method]udp-socket.finish-bind"][Instruction::Return]', {
    funcName: '[method]udp-socket.finish-bind',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_86_metadata = {
  qualifiedImportFn: 'wasi:sockets/udp@0.2.0#[method]udp-socket.stream',
  moduleIdx: null,
};


function trampoline107(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14) {
  var handle1 = arg0;
  var rep2 = handleTable9[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable9.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(UdpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  let variant4;
  switch (arg1) {
    case 0: {
      variant4 = undefined;
      break;
    }
    case 1: {
      let variant3;
      switch (arg2) {
        case 0: {
          variant3= {
            tag: 'ipv4',
            val: {
              port: clampGuest(arg3, 0, 65535),
              address: [clampGuest(arg4, 0, 255), clampGuest(arg5, 0, 255), clampGuest(arg6, 0, 255), clampGuest(arg7, 0, 255)],
            }
          };
          break;
        }
        case 1: {
          variant3= {
            tag: 'ipv6',
            val: {
              port: clampGuest(arg3, 0, 65535),
              flowInfo: arg4 >>> 0,
              address: [clampGuest(arg5, 0, 65535), clampGuest(arg6, 0, 65535), clampGuest(arg7, 0, 65535), clampGuest(arg8, 0, 65535), clampGuest(arg9, 0, 65535), clampGuest(arg10, 0, 65535), clampGuest(arg11, 0, 65535), clampGuest(arg12, 0, 65535)],
              scopeId: arg13 >>> 0,
            }
          };
          break;
        }
        default: {
          throw new TypeError('invalid variant discriminant for IpSocketAddress');
        }
      }
      variant4 = variant3;
      break;
    }
    default: {
      throw new TypeError('invalid variant discriminant for option');
    }
  }
  _debugLog('[iface="wasi:sockets/udp@0.2.0", function="[method]udp-socket.stream"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.stream._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'stream',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.stream(variant4)};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant9 = ret;
  switch (variant9.tag) {
    case 'ok': {
      const e = variant9.val;
      dataView(memory0).setInt8(arg14 + 0, 0, true);
      var [tuple5_0, tuple5_1] = e;
      if (!(tuple5_0 instanceof IncomingDatagramStream)) {
        throw new TypeError('Resource error: Not a valid "IncomingDatagramStream" resource.');
      }
      var handle6 = tuple5_0[symbolRscHandle];
      if (!handle6) {
        const rep = tuple5_0[symbolRscRep] || ++captureCnt10;
        captureTable10.set(rep, tuple5_0);
        handle6 = rscTableCreateOwn(handleTable10, rep);
      }
      dataView(memory0).setInt32(arg14 + 4, handle6, true);
      if (!(tuple5_1 instanceof OutgoingDatagramStream)) {
        throw new TypeError('Resource error: Not a valid "OutgoingDatagramStream" resource.');
      }
      var handle7 = tuple5_1[symbolRscHandle];
      if (!handle7) {
        const rep = tuple5_1[symbolRscRep] || ++captureCnt11;
        captureTable11.set(rep, tuple5_1);
        handle7 = rscTableCreateOwn(handleTable11, rep);
      }
      dataView(memory0).setInt32(arg14 + 8, handle7, true);
      break;
    }
    case 'err': {
      const e = variant9.val;
      dataView(memory0).setInt8(arg14 + 0, 1, true);
      var val8 = e;
      let enum8;
      switch (val8) {
        case 'unknown': {
          enum8 = 0;
          break;
        }
        case 'access-denied': {
          enum8 = 1;
          break;
        }
        case 'not-supported': {
          enum8 = 2;
          break;
        }
        case 'invalid-argument': {
          enum8 = 3;
          break;
        }
        case 'out-of-memory': {
          enum8 = 4;
          break;
        }
        case 'timeout': {
          enum8 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum8 = 6;
          break;
        }
        case 'not-in-progress': {
          enum8 = 7;
          break;
        }
        case 'would-block': {
          enum8 = 8;
          break;
        }
        case 'invalid-state': {
          enum8 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum8 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum8 = 11;
          break;
        }
        case 'address-in-use': {
          enum8 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum8 = 13;
          break;
        }
        case 'connection-refused': {
          enum8 = 14;
          break;
        }
        case 'connection-reset': {
          enum8 = 15;
          break;
        }
        case 'connection-aborted': {
          enum8 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum8 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum8 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum8 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum8 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val8}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg14 + 4, enum8, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/udp@0.2.0", function="[method]udp-socket.stream"][Instruction::Return]', {
    funcName: '[method]udp-socket.stream',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_87_metadata = {
  qualifiedImportFn: 'wasi:sockets/udp@0.2.0#[method]udp-socket.local-address',
  moduleIdx: null,
};


function trampoline108(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable9[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable9.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(UdpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/udp@0.2.0", function="[method]udp-socket.local-address"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.localAddress._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'localAddress',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.localAddress()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant9 = ret;
  switch (variant9.tag) {
    case 'ok': {
      const e = variant9.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      var variant7 = e;
      switch (variant7.tag) {
        case 'ipv4': {
          const e = variant7.val;
          dataView(memory0).setInt8(arg1 + 4, 0, true);
          var {port: v3_0, address: v3_1 } = e;
          dataView(memory0).setInt16(arg1 + 8, toUint16(v3_0), true);
          var [tuple4_0, tuple4_1, tuple4_2, tuple4_3] = v3_1;
          dataView(memory0).setInt8(arg1 + 10, toUint8(tuple4_0), true);
          dataView(memory0).setInt8(arg1 + 11, toUint8(tuple4_1), true);
          dataView(memory0).setInt8(arg1 + 12, toUint8(tuple4_2), true);
          dataView(memory0).setInt8(arg1 + 13, toUint8(tuple4_3), true);
          break;
        }
        case 'ipv6': {
          const e = variant7.val;
          dataView(memory0).setInt8(arg1 + 4, 1, true);
          var {port: v5_0, flowInfo: v5_1, address: v5_2, scopeId: v5_3 } = e;
          dataView(memory0).setInt16(arg1 + 8, toUint16(v5_0), true);
          dataView(memory0).setInt32(arg1 + 12, toUint32(v5_1), true);
          var [tuple6_0, tuple6_1, tuple6_2, tuple6_3, tuple6_4, tuple6_5, tuple6_6, tuple6_7] = v5_2;
          dataView(memory0).setInt16(arg1 + 16, toUint16(tuple6_0), true);
          dataView(memory0).setInt16(arg1 + 18, toUint16(tuple6_1), true);
          dataView(memory0).setInt16(arg1 + 20, toUint16(tuple6_2), true);
          dataView(memory0).setInt16(arg1 + 22, toUint16(tuple6_3), true);
          dataView(memory0).setInt16(arg1 + 24, toUint16(tuple6_4), true);
          dataView(memory0).setInt16(arg1 + 26, toUint16(tuple6_5), true);
          dataView(memory0).setInt16(arg1 + 28, toUint16(tuple6_6), true);
          dataView(memory0).setInt16(arg1 + 30, toUint16(tuple6_7), true);
          dataView(memory0).setInt32(arg1 + 32, toUint32(v5_3), true);
          break;
        }
        default: {
          throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant7.tag)}\` (received \`${variant7}\`) specified for \`IpSocketAddress\``);
        }
      }
      break;
    }
    case 'err': {
      const e = variant9.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val8 = e;
      let enum8;
      switch (val8) {
        case 'unknown': {
          enum8 = 0;
          break;
        }
        case 'access-denied': {
          enum8 = 1;
          break;
        }
        case 'not-supported': {
          enum8 = 2;
          break;
        }
        case 'invalid-argument': {
          enum8 = 3;
          break;
        }
        case 'out-of-memory': {
          enum8 = 4;
          break;
        }
        case 'timeout': {
          enum8 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum8 = 6;
          break;
        }
        case 'not-in-progress': {
          enum8 = 7;
          break;
        }
        case 'would-block': {
          enum8 = 8;
          break;
        }
        case 'invalid-state': {
          enum8 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum8 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum8 = 11;
          break;
        }
        case 'address-in-use': {
          enum8 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum8 = 13;
          break;
        }
        case 'connection-refused': {
          enum8 = 14;
          break;
        }
        case 'connection-reset': {
          enum8 = 15;
          break;
        }
        case 'connection-aborted': {
          enum8 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum8 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum8 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum8 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum8 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val8}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 4, enum8, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/udp@0.2.0", function="[method]udp-socket.local-address"][Instruction::Return]', {
    funcName: '[method]udp-socket.local-address',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_88_metadata = {
  qualifiedImportFn: 'wasi:sockets/udp@0.2.0#[method]udp-socket.remote-address',
  moduleIdx: null,
};


function trampoline109(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable9[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable9.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(UdpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/udp@0.2.0", function="[method]udp-socket.remote-address"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.remoteAddress._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'remoteAddress',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.remoteAddress()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant9 = ret;
  switch (variant9.tag) {
    case 'ok': {
      const e = variant9.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      var variant7 = e;
      switch (variant7.tag) {
        case 'ipv4': {
          const e = variant7.val;
          dataView(memory0).setInt8(arg1 + 4, 0, true);
          var {port: v3_0, address: v3_1 } = e;
          dataView(memory0).setInt16(arg1 + 8, toUint16(v3_0), true);
          var [tuple4_0, tuple4_1, tuple4_2, tuple4_3] = v3_1;
          dataView(memory0).setInt8(arg1 + 10, toUint8(tuple4_0), true);
          dataView(memory0).setInt8(arg1 + 11, toUint8(tuple4_1), true);
          dataView(memory0).setInt8(arg1 + 12, toUint8(tuple4_2), true);
          dataView(memory0).setInt8(arg1 + 13, toUint8(tuple4_3), true);
          break;
        }
        case 'ipv6': {
          const e = variant7.val;
          dataView(memory0).setInt8(arg1 + 4, 1, true);
          var {port: v5_0, flowInfo: v5_1, address: v5_2, scopeId: v5_3 } = e;
          dataView(memory0).setInt16(arg1 + 8, toUint16(v5_0), true);
          dataView(memory0).setInt32(arg1 + 12, toUint32(v5_1), true);
          var [tuple6_0, tuple6_1, tuple6_2, tuple6_3, tuple6_4, tuple6_5, tuple6_6, tuple6_7] = v5_2;
          dataView(memory0).setInt16(arg1 + 16, toUint16(tuple6_0), true);
          dataView(memory0).setInt16(arg1 + 18, toUint16(tuple6_1), true);
          dataView(memory0).setInt16(arg1 + 20, toUint16(tuple6_2), true);
          dataView(memory0).setInt16(arg1 + 22, toUint16(tuple6_3), true);
          dataView(memory0).setInt16(arg1 + 24, toUint16(tuple6_4), true);
          dataView(memory0).setInt16(arg1 + 26, toUint16(tuple6_5), true);
          dataView(memory0).setInt16(arg1 + 28, toUint16(tuple6_6), true);
          dataView(memory0).setInt16(arg1 + 30, toUint16(tuple6_7), true);
          dataView(memory0).setInt32(arg1 + 32, toUint32(v5_3), true);
          break;
        }
        default: {
          throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant7.tag)}\` (received \`${variant7}\`) specified for \`IpSocketAddress\``);
        }
      }
      break;
    }
    case 'err': {
      const e = variant9.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val8 = e;
      let enum8;
      switch (val8) {
        case 'unknown': {
          enum8 = 0;
          break;
        }
        case 'access-denied': {
          enum8 = 1;
          break;
        }
        case 'not-supported': {
          enum8 = 2;
          break;
        }
        case 'invalid-argument': {
          enum8 = 3;
          break;
        }
        case 'out-of-memory': {
          enum8 = 4;
          break;
        }
        case 'timeout': {
          enum8 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum8 = 6;
          break;
        }
        case 'not-in-progress': {
          enum8 = 7;
          break;
        }
        case 'would-block': {
          enum8 = 8;
          break;
        }
        case 'invalid-state': {
          enum8 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum8 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum8 = 11;
          break;
        }
        case 'address-in-use': {
          enum8 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum8 = 13;
          break;
        }
        case 'connection-refused': {
          enum8 = 14;
          break;
        }
        case 'connection-reset': {
          enum8 = 15;
          break;
        }
        case 'connection-aborted': {
          enum8 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum8 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum8 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum8 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum8 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val8}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 4, enum8, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/udp@0.2.0", function="[method]udp-socket.remote-address"][Instruction::Return]', {
    funcName: '[method]udp-socket.remote-address',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_89_metadata = {
  qualifiedImportFn: 'wasi:sockets/udp@0.2.0#[method]udp-socket.unicast-hop-limit',
  moduleIdx: null,
};


function trampoline110(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable9[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable9.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(UdpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/udp@0.2.0", function="[method]udp-socket.unicast-hop-limit"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.unicastHopLimit._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'unicastHopLimit',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.unicastHopLimit()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant4 = ret;
  switch (variant4.tag) {
    case 'ok': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      dataView(memory0).setInt8(arg1 + 1, toUint8(e), true);
      break;
    }
    case 'err': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val3 = e;
      let enum3;
      switch (val3) {
        case 'unknown': {
          enum3 = 0;
          break;
        }
        case 'access-denied': {
          enum3 = 1;
          break;
        }
        case 'not-supported': {
          enum3 = 2;
          break;
        }
        case 'invalid-argument': {
          enum3 = 3;
          break;
        }
        case 'out-of-memory': {
          enum3 = 4;
          break;
        }
        case 'timeout': {
          enum3 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum3 = 6;
          break;
        }
        case 'not-in-progress': {
          enum3 = 7;
          break;
        }
        case 'would-block': {
          enum3 = 8;
          break;
        }
        case 'invalid-state': {
          enum3 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum3 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum3 = 11;
          break;
        }
        case 'address-in-use': {
          enum3 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum3 = 13;
          break;
        }
        case 'connection-refused': {
          enum3 = 14;
          break;
        }
        case 'connection-reset': {
          enum3 = 15;
          break;
        }
        case 'connection-aborted': {
          enum3 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum3 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum3 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum3 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum3 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val3}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 1, enum3, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/udp@0.2.0", function="[method]udp-socket.unicast-hop-limit"][Instruction::Return]', {
    funcName: '[method]udp-socket.unicast-hop-limit',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_90_metadata = {
  qualifiedImportFn: 'wasi:sockets/udp@0.2.0#[method]udp-socket.set-unicast-hop-limit',
  moduleIdx: null,
};


function trampoline111(arg0, arg1, arg2) {
  var handle1 = arg0;
  var rep2 = handleTable9[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable9.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(UdpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/udp@0.2.0", function="[method]udp-socket.set-unicast-hop-limit"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.setUnicastHopLimit._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'setUnicastHopLimit',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.setUnicastHopLimit(clampGuest(arg1, 0, 255))};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant4 = ret;
  switch (variant4.tag) {
    case 'ok': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg2 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg2 + 0, 1, true);
      var val3 = e;
      let enum3;
      switch (val3) {
        case 'unknown': {
          enum3 = 0;
          break;
        }
        case 'access-denied': {
          enum3 = 1;
          break;
        }
        case 'not-supported': {
          enum3 = 2;
          break;
        }
        case 'invalid-argument': {
          enum3 = 3;
          break;
        }
        case 'out-of-memory': {
          enum3 = 4;
          break;
        }
        case 'timeout': {
          enum3 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum3 = 6;
          break;
        }
        case 'not-in-progress': {
          enum3 = 7;
          break;
        }
        case 'would-block': {
          enum3 = 8;
          break;
        }
        case 'invalid-state': {
          enum3 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum3 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum3 = 11;
          break;
        }
        case 'address-in-use': {
          enum3 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum3 = 13;
          break;
        }
        case 'connection-refused': {
          enum3 = 14;
          break;
        }
        case 'connection-reset': {
          enum3 = 15;
          break;
        }
        case 'connection-aborted': {
          enum3 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum3 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum3 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum3 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum3 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val3}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg2 + 1, enum3, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/udp@0.2.0", function="[method]udp-socket.set-unicast-hop-limit"][Instruction::Return]', {
    funcName: '[method]udp-socket.set-unicast-hop-limit',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_91_metadata = {
  qualifiedImportFn: 'wasi:sockets/udp@0.2.0#[method]udp-socket.receive-buffer-size',
  moduleIdx: null,
};


function trampoline112(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable9[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable9.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(UdpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/udp@0.2.0", function="[method]udp-socket.receive-buffer-size"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.receiveBufferSize._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'receiveBufferSize',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.receiveBufferSize()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant4 = ret;
  switch (variant4.tag) {
    case 'ok': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      dataView(memory0).setBigInt64(arg1 + 8, toUint64(e), true);
      break;
    }
    case 'err': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val3 = e;
      let enum3;
      switch (val3) {
        case 'unknown': {
          enum3 = 0;
          break;
        }
        case 'access-denied': {
          enum3 = 1;
          break;
        }
        case 'not-supported': {
          enum3 = 2;
          break;
        }
        case 'invalid-argument': {
          enum3 = 3;
          break;
        }
        case 'out-of-memory': {
          enum3 = 4;
          break;
        }
        case 'timeout': {
          enum3 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum3 = 6;
          break;
        }
        case 'not-in-progress': {
          enum3 = 7;
          break;
        }
        case 'would-block': {
          enum3 = 8;
          break;
        }
        case 'invalid-state': {
          enum3 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum3 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum3 = 11;
          break;
        }
        case 'address-in-use': {
          enum3 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum3 = 13;
          break;
        }
        case 'connection-refused': {
          enum3 = 14;
          break;
        }
        case 'connection-reset': {
          enum3 = 15;
          break;
        }
        case 'connection-aborted': {
          enum3 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum3 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum3 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum3 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum3 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val3}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 8, enum3, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/udp@0.2.0", function="[method]udp-socket.receive-buffer-size"][Instruction::Return]', {
    funcName: '[method]udp-socket.receive-buffer-size',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_92_metadata = {
  qualifiedImportFn: 'wasi:sockets/udp@0.2.0#[method]udp-socket.set-receive-buffer-size',
  moduleIdx: null,
};


function trampoline113(arg0, arg1, arg2) {
  var handle1 = arg0;
  var rep2 = handleTable9[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable9.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(UdpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/udp@0.2.0", function="[method]udp-socket.set-receive-buffer-size"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.setReceiveBufferSize._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'setReceiveBufferSize',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.setReceiveBufferSize(BigInt.asUintN(64, arg1))};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant4 = ret;
  switch (variant4.tag) {
    case 'ok': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg2 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg2 + 0, 1, true);
      var val3 = e;
      let enum3;
      switch (val3) {
        case 'unknown': {
          enum3 = 0;
          break;
        }
        case 'access-denied': {
          enum3 = 1;
          break;
        }
        case 'not-supported': {
          enum3 = 2;
          break;
        }
        case 'invalid-argument': {
          enum3 = 3;
          break;
        }
        case 'out-of-memory': {
          enum3 = 4;
          break;
        }
        case 'timeout': {
          enum3 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum3 = 6;
          break;
        }
        case 'not-in-progress': {
          enum3 = 7;
          break;
        }
        case 'would-block': {
          enum3 = 8;
          break;
        }
        case 'invalid-state': {
          enum3 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum3 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum3 = 11;
          break;
        }
        case 'address-in-use': {
          enum3 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum3 = 13;
          break;
        }
        case 'connection-refused': {
          enum3 = 14;
          break;
        }
        case 'connection-reset': {
          enum3 = 15;
          break;
        }
        case 'connection-aborted': {
          enum3 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum3 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum3 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum3 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum3 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val3}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg2 + 1, enum3, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/udp@0.2.0", function="[method]udp-socket.set-receive-buffer-size"][Instruction::Return]', {
    funcName: '[method]udp-socket.set-receive-buffer-size',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_93_metadata = {
  qualifiedImportFn: 'wasi:sockets/udp@0.2.0#[method]udp-socket.send-buffer-size',
  moduleIdx: null,
};


function trampoline114(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable9[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable9.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(UdpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/udp@0.2.0", function="[method]udp-socket.send-buffer-size"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.sendBufferSize._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'sendBufferSize',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.sendBufferSize()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant4 = ret;
  switch (variant4.tag) {
    case 'ok': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      dataView(memory0).setBigInt64(arg1 + 8, toUint64(e), true);
      break;
    }
    case 'err': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val3 = e;
      let enum3;
      switch (val3) {
        case 'unknown': {
          enum3 = 0;
          break;
        }
        case 'access-denied': {
          enum3 = 1;
          break;
        }
        case 'not-supported': {
          enum3 = 2;
          break;
        }
        case 'invalid-argument': {
          enum3 = 3;
          break;
        }
        case 'out-of-memory': {
          enum3 = 4;
          break;
        }
        case 'timeout': {
          enum3 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum3 = 6;
          break;
        }
        case 'not-in-progress': {
          enum3 = 7;
          break;
        }
        case 'would-block': {
          enum3 = 8;
          break;
        }
        case 'invalid-state': {
          enum3 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum3 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum3 = 11;
          break;
        }
        case 'address-in-use': {
          enum3 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum3 = 13;
          break;
        }
        case 'connection-refused': {
          enum3 = 14;
          break;
        }
        case 'connection-reset': {
          enum3 = 15;
          break;
        }
        case 'connection-aborted': {
          enum3 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum3 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum3 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum3 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum3 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val3}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 8, enum3, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/udp@0.2.0", function="[method]udp-socket.send-buffer-size"][Instruction::Return]', {
    funcName: '[method]udp-socket.send-buffer-size',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_94_metadata = {
  qualifiedImportFn: 'wasi:sockets/udp@0.2.0#[method]udp-socket.set-send-buffer-size',
  moduleIdx: null,
};


function trampoline115(arg0, arg1, arg2) {
  var handle1 = arg0;
  var rep2 = handleTable9[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable9.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(UdpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/udp@0.2.0", function="[method]udp-socket.set-send-buffer-size"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.setSendBufferSize._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'setSendBufferSize',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.setSendBufferSize(BigInt.asUintN(64, arg1))};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant4 = ret;
  switch (variant4.tag) {
    case 'ok': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg2 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg2 + 0, 1, true);
      var val3 = e;
      let enum3;
      switch (val3) {
        case 'unknown': {
          enum3 = 0;
          break;
        }
        case 'access-denied': {
          enum3 = 1;
          break;
        }
        case 'not-supported': {
          enum3 = 2;
          break;
        }
        case 'invalid-argument': {
          enum3 = 3;
          break;
        }
        case 'out-of-memory': {
          enum3 = 4;
          break;
        }
        case 'timeout': {
          enum3 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum3 = 6;
          break;
        }
        case 'not-in-progress': {
          enum3 = 7;
          break;
        }
        case 'would-block': {
          enum3 = 8;
          break;
        }
        case 'invalid-state': {
          enum3 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum3 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum3 = 11;
          break;
        }
        case 'address-in-use': {
          enum3 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum3 = 13;
          break;
        }
        case 'connection-refused': {
          enum3 = 14;
          break;
        }
        case 'connection-reset': {
          enum3 = 15;
          break;
        }
        case 'connection-aborted': {
          enum3 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum3 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum3 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum3 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum3 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val3}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg2 + 1, enum3, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/udp@0.2.0", function="[method]udp-socket.set-send-buffer-size"][Instruction::Return]', {
    funcName: '[method]udp-socket.set-send-buffer-size',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_95_metadata = {
  qualifiedImportFn: 'wasi:sockets/udp@0.2.0#[method]incoming-datagram-stream.receive',
  moduleIdx: null,
};


function trampoline116(arg0, arg1, arg2) {
  var handle1 = arg0;
  var rep2 = handleTable10[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable10.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(IncomingDatagramStream.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/udp@0.2.0", function="[method]incoming-datagram-stream.receive"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.receive._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'receive',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.receive(BigInt.asUintN(64, arg1))};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant12 = ret;
  switch (variant12.tag) {
    case 'ok': {
      const e = variant12.val;
      dataView(memory0).setInt8(arg2 + 0, 0, true);
      var vec10 = e;
      var len10 = vec10.length;
      var result10 = realloc1(0, 0, 4, len10 * 40);
      for (let i = 0; i < vec10.length; i++) {
        const e = vec10[i];
        const base = result10 + i * 40;var {data: v3_0, remoteAddress: v3_1 } = e;
        var val4 = v3_0;
        var len4 = val4.byteLength;
        var ptr4 = realloc1(0, 0, 1, len4 * 1);
        var src4 = new Uint8Array(val4.buffer || val4, val4.byteOffset, len4 * 1);
        (new Uint8Array(memory0.buffer, ptr4, len4 * 1)).set(src4);
        dataView(memory0).setUint32(base + 4, len4, true);
        dataView(memory0).setUint32(base + 0, ptr4, true);
        var variant9 = v3_1;
        switch (variant9.tag) {
          case 'ipv4': {
            const e = variant9.val;
            dataView(memory0).setInt8(base + 8, 0, true);
            var {port: v5_0, address: v5_1 } = e;
            dataView(memory0).setInt16(base + 12, toUint16(v5_0), true);
            var [tuple6_0, tuple6_1, tuple6_2, tuple6_3] = v5_1;
            dataView(memory0).setInt8(base + 14, toUint8(tuple6_0), true);
            dataView(memory0).setInt8(base + 15, toUint8(tuple6_1), true);
            dataView(memory0).setInt8(base + 16, toUint8(tuple6_2), true);
            dataView(memory0).setInt8(base + 17, toUint8(tuple6_3), true);
            break;
          }
          case 'ipv6': {
            const e = variant9.val;
            dataView(memory0).setInt8(base + 8, 1, true);
            var {port: v7_0, flowInfo: v7_1, address: v7_2, scopeId: v7_3 } = e;
            dataView(memory0).setInt16(base + 12, toUint16(v7_0), true);
            dataView(memory0).setInt32(base + 16, toUint32(v7_1), true);
            var [tuple8_0, tuple8_1, tuple8_2, tuple8_3, tuple8_4, tuple8_5, tuple8_6, tuple8_7] = v7_2;
            dataView(memory0).setInt16(base + 20, toUint16(tuple8_0), true);
            dataView(memory0).setInt16(base + 22, toUint16(tuple8_1), true);
            dataView(memory0).setInt16(base + 24, toUint16(tuple8_2), true);
            dataView(memory0).setInt16(base + 26, toUint16(tuple8_3), true);
            dataView(memory0).setInt16(base + 28, toUint16(tuple8_4), true);
            dataView(memory0).setInt16(base + 30, toUint16(tuple8_5), true);
            dataView(memory0).setInt16(base + 32, toUint16(tuple8_6), true);
            dataView(memory0).setInt16(base + 34, toUint16(tuple8_7), true);
            dataView(memory0).setInt32(base + 36, toUint32(v7_3), true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant9.tag)}\` (received \`${variant9}\`) specified for \`IpSocketAddress\``);
          }
        }
      }
      dataView(memory0).setUint32(arg2 + 8, len10, true);
      dataView(memory0).setUint32(arg2 + 4, result10, true);
      break;
    }
    case 'err': {
      const e = variant12.val;
      dataView(memory0).setInt8(arg2 + 0, 1, true);
      var val11 = e;
      let enum11;
      switch (val11) {
        case 'unknown': {
          enum11 = 0;
          break;
        }
        case 'access-denied': {
          enum11 = 1;
          break;
        }
        case 'not-supported': {
          enum11 = 2;
          break;
        }
        case 'invalid-argument': {
          enum11 = 3;
          break;
        }
        case 'out-of-memory': {
          enum11 = 4;
          break;
        }
        case 'timeout': {
          enum11 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum11 = 6;
          break;
        }
        case 'not-in-progress': {
          enum11 = 7;
          break;
        }
        case 'would-block': {
          enum11 = 8;
          break;
        }
        case 'invalid-state': {
          enum11 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum11 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum11 = 11;
          break;
        }
        case 'address-in-use': {
          enum11 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum11 = 13;
          break;
        }
        case 'connection-refused': {
          enum11 = 14;
          break;
        }
        case 'connection-reset': {
          enum11 = 15;
          break;
        }
        case 'connection-aborted': {
          enum11 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum11 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum11 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum11 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum11 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val11}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg2 + 4, enum11, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/udp@0.2.0", function="[method]incoming-datagram-stream.receive"][Instruction::Return]', {
    funcName: '[method]incoming-datagram-stream.receive',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_96_metadata = {
  qualifiedImportFn: 'wasi:sockets/udp@0.2.0#[method]outgoing-datagram-stream.check-send',
  moduleIdx: null,
};


function trampoline117(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable11[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable11.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(OutgoingDatagramStream.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/udp@0.2.0", function="[method]outgoing-datagram-stream.check-send"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.checkSend._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'checkSend',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.checkSend()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant4 = ret;
  switch (variant4.tag) {
    case 'ok': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      dataView(memory0).setBigInt64(arg1 + 8, toUint64(e), true);
      break;
    }
    case 'err': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val3 = e;
      let enum3;
      switch (val3) {
        case 'unknown': {
          enum3 = 0;
          break;
        }
        case 'access-denied': {
          enum3 = 1;
          break;
        }
        case 'not-supported': {
          enum3 = 2;
          break;
        }
        case 'invalid-argument': {
          enum3 = 3;
          break;
        }
        case 'out-of-memory': {
          enum3 = 4;
          break;
        }
        case 'timeout': {
          enum3 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum3 = 6;
          break;
        }
        case 'not-in-progress': {
          enum3 = 7;
          break;
        }
        case 'would-block': {
          enum3 = 8;
          break;
        }
        case 'invalid-state': {
          enum3 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum3 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum3 = 11;
          break;
        }
        case 'address-in-use': {
          enum3 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum3 = 13;
          break;
        }
        case 'connection-refused': {
          enum3 = 14;
          break;
        }
        case 'connection-reset': {
          enum3 = 15;
          break;
        }
        case 'connection-aborted': {
          enum3 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum3 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum3 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum3 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum3 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val3}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 8, enum3, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/udp@0.2.0", function="[method]outgoing-datagram-stream.check-send"][Instruction::Return]', {
    funcName: '[method]outgoing-datagram-stream.check-send',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_97_metadata = {
  qualifiedImportFn: 'wasi:sockets/udp@0.2.0#[method]outgoing-datagram-stream.send',
  moduleIdx: null,
};


function trampoline118(arg0, arg1, arg2, arg3) {
  var handle1 = arg0;
  var rep2 = handleTable11[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable11.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(OutgoingDatagramStream.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  var len6 = arg2;
  var base6 = arg1;
  var result6 = [];
  for (let i = 0; i < len6; i++) {
    const base = base6 + i * 44;
    var ptr3 = dataView(memory0).getUint32(base + 0, true);
    var len3 = dataView(memory0).getUint32(base + 4, true);
    var result3 = new Uint8Array(memory0.buffer.slice(ptr3, ptr3 + len3 * 1));
    let variant5;
    switch (dataView(memory0).getUint8(base + 8, true)) {
      case 0: {
        variant5 = undefined;
        break;
      }
      case 1: {
        let variant4;
        switch (dataView(memory0).getUint8(base + 12, true)) {
          case 0: {
            variant4= {
              tag: 'ipv4',
              val: {
                port: clampGuest(dataView(memory0).getUint16(base + 16, true), 0, 65535),
                address: [clampGuest(dataView(memory0).getUint8(base + 18, true), 0, 255), clampGuest(dataView(memory0).getUint8(base + 19, true), 0, 255), clampGuest(dataView(memory0).getUint8(base + 20, true), 0, 255), clampGuest(dataView(memory0).getUint8(base + 21, true), 0, 255)],
              }
            };
            break;
          }
          case 1: {
            variant4= {
              tag: 'ipv6',
              val: {
                port: clampGuest(dataView(memory0).getUint16(base + 16, true), 0, 65535),
                flowInfo: dataView(memory0).getInt32(base + 20, true) >>> 0,
                address: [clampGuest(dataView(memory0).getUint16(base + 24, true), 0, 65535), clampGuest(dataView(memory0).getUint16(base + 26, true), 0, 65535), clampGuest(dataView(memory0).getUint16(base + 28, true), 0, 65535), clampGuest(dataView(memory0).getUint16(base + 30, true), 0, 65535), clampGuest(dataView(memory0).getUint16(base + 32, true), 0, 65535), clampGuest(dataView(memory0).getUint16(base + 34, true), 0, 65535), clampGuest(dataView(memory0).getUint16(base + 36, true), 0, 65535), clampGuest(dataView(memory0).getUint16(base + 38, true), 0, 65535)],
                scopeId: dataView(memory0).getInt32(base + 40, true) >>> 0,
              }
            };
            break;
          }
          default: {
            throw new TypeError('invalid variant discriminant for IpSocketAddress');
          }
        }
        variant5 = variant4;
        break;
      }
      default: {
        throw new TypeError('invalid variant discriminant for option');
      }
    }
    result6.push({
      data: result3,
      remoteAddress: variant5,
    });
  }
  _debugLog('[iface="wasi:sockets/udp@0.2.0", function="[method]outgoing-datagram-stream.send"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.send._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'send',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.send(result6)};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant8 = ret;
  switch (variant8.tag) {
    case 'ok': {
      const e = variant8.val;
      dataView(memory0).setInt8(arg3 + 0, 0, true);
      dataView(memory0).setBigInt64(arg3 + 8, toUint64(e), true);
      break;
    }
    case 'err': {
      const e = variant8.val;
      dataView(memory0).setInt8(arg3 + 0, 1, true);
      var val7 = e;
      let enum7;
      switch (val7) {
        case 'unknown': {
          enum7 = 0;
          break;
        }
        case 'access-denied': {
          enum7 = 1;
          break;
        }
        case 'not-supported': {
          enum7 = 2;
          break;
        }
        case 'invalid-argument': {
          enum7 = 3;
          break;
        }
        case 'out-of-memory': {
          enum7 = 4;
          break;
        }
        case 'timeout': {
          enum7 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum7 = 6;
          break;
        }
        case 'not-in-progress': {
          enum7 = 7;
          break;
        }
        case 'would-block': {
          enum7 = 8;
          break;
        }
        case 'invalid-state': {
          enum7 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum7 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum7 = 11;
          break;
        }
        case 'address-in-use': {
          enum7 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum7 = 13;
          break;
        }
        case 'connection-refused': {
          enum7 = 14;
          break;
        }
        case 'connection-reset': {
          enum7 = 15;
          break;
        }
        case 'connection-aborted': {
          enum7 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum7 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum7 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum7 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum7 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val7}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg3 + 8, enum7, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/udp@0.2.0", function="[method]outgoing-datagram-stream.send"][Instruction::Return]', {
    funcName: '[method]outgoing-datagram-stream.send',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_98_metadata = {
  qualifiedImportFn: 'wasi:sockets/tcp@0.2.0#[method]tcp-socket.start-bind',
  moduleIdx: null,
};


function trampoline119(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14) {
  var handle1 = arg0;
  var rep2 = handleTable12[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable12.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(TcpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  var handle4 = arg1;
  var rep5 = handleTable8[(handle4 << 1) + 1] & ~T_FLAG;
  var rsc3 = captureTable8.get(rep5);
  if (!rsc3) {
    rsc3 = Object.create(Network.prototype);
    Object.defineProperty(rsc3, symbolRscHandle, { writable: true, value: handle4});
    Object.defineProperty(rsc3, symbolRscRep, { writable: true, value: rep5});
  }
  curResourceBorrows.push(rsc3);
  let variant6;
  switch (arg2) {
    case 0: {
      variant6= {
        tag: 'ipv4',
        val: {
          port: clampGuest(arg3, 0, 65535),
          address: [clampGuest(arg4, 0, 255), clampGuest(arg5, 0, 255), clampGuest(arg6, 0, 255), clampGuest(arg7, 0, 255)],
        }
      };
      break;
    }
    case 1: {
      variant6= {
        tag: 'ipv6',
        val: {
          port: clampGuest(arg3, 0, 65535),
          flowInfo: arg4 >>> 0,
          address: [clampGuest(arg5, 0, 65535), clampGuest(arg6, 0, 65535), clampGuest(arg7, 0, 65535), clampGuest(arg8, 0, 65535), clampGuest(arg9, 0, 65535), clampGuest(arg10, 0, 65535), clampGuest(arg11, 0, 65535), clampGuest(arg12, 0, 65535)],
          scopeId: arg13 >>> 0,
        }
      };
      break;
    }
    default: {
      throw new TypeError('invalid variant discriminant for IpSocketAddress');
    }
  }
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.start-bind"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.startBind._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'startBind',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.startBind(rsc3, variant6)};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant8 = ret;
  switch (variant8.tag) {
    case 'ok': {
      const e = variant8.val;
      dataView(memory0).setInt8(arg14 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant8.val;
      dataView(memory0).setInt8(arg14 + 0, 1, true);
      var val7 = e;
      let enum7;
      switch (val7) {
        case 'unknown': {
          enum7 = 0;
          break;
        }
        case 'access-denied': {
          enum7 = 1;
          break;
        }
        case 'not-supported': {
          enum7 = 2;
          break;
        }
        case 'invalid-argument': {
          enum7 = 3;
          break;
        }
        case 'out-of-memory': {
          enum7 = 4;
          break;
        }
        case 'timeout': {
          enum7 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum7 = 6;
          break;
        }
        case 'not-in-progress': {
          enum7 = 7;
          break;
        }
        case 'would-block': {
          enum7 = 8;
          break;
        }
        case 'invalid-state': {
          enum7 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum7 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum7 = 11;
          break;
        }
        case 'address-in-use': {
          enum7 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum7 = 13;
          break;
        }
        case 'connection-refused': {
          enum7 = 14;
          break;
        }
        case 'connection-reset': {
          enum7 = 15;
          break;
        }
        case 'connection-aborted': {
          enum7 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum7 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum7 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum7 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum7 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val7}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg14 + 1, enum7, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.start-bind"][Instruction::Return]', {
    funcName: '[method]tcp-socket.start-bind',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_99_metadata = {
  qualifiedImportFn: 'wasi:sockets/tcp@0.2.0#[method]tcp-socket.finish-bind',
  moduleIdx: null,
};


function trampoline120(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable12[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable12.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(TcpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.finish-bind"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.finishBind._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'finishBind',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.finishBind()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant4 = ret;
  switch (variant4.tag) {
    case 'ok': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val3 = e;
      let enum3;
      switch (val3) {
        case 'unknown': {
          enum3 = 0;
          break;
        }
        case 'access-denied': {
          enum3 = 1;
          break;
        }
        case 'not-supported': {
          enum3 = 2;
          break;
        }
        case 'invalid-argument': {
          enum3 = 3;
          break;
        }
        case 'out-of-memory': {
          enum3 = 4;
          break;
        }
        case 'timeout': {
          enum3 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum3 = 6;
          break;
        }
        case 'not-in-progress': {
          enum3 = 7;
          break;
        }
        case 'would-block': {
          enum3 = 8;
          break;
        }
        case 'invalid-state': {
          enum3 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum3 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum3 = 11;
          break;
        }
        case 'address-in-use': {
          enum3 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum3 = 13;
          break;
        }
        case 'connection-refused': {
          enum3 = 14;
          break;
        }
        case 'connection-reset': {
          enum3 = 15;
          break;
        }
        case 'connection-aborted': {
          enum3 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum3 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum3 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum3 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum3 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val3}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 1, enum3, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.finish-bind"][Instruction::Return]', {
    funcName: '[method]tcp-socket.finish-bind',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_100_metadata = {
  qualifiedImportFn: 'wasi:sockets/tcp@0.2.0#[method]tcp-socket.start-connect',
  moduleIdx: null,
};


function trampoline121(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14) {
  var handle1 = arg0;
  var rep2 = handleTable12[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable12.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(TcpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  var handle4 = arg1;
  var rep5 = handleTable8[(handle4 << 1) + 1] & ~T_FLAG;
  var rsc3 = captureTable8.get(rep5);
  if (!rsc3) {
    rsc3 = Object.create(Network.prototype);
    Object.defineProperty(rsc3, symbolRscHandle, { writable: true, value: handle4});
    Object.defineProperty(rsc3, symbolRscRep, { writable: true, value: rep5});
  }
  curResourceBorrows.push(rsc3);
  let variant6;
  switch (arg2) {
    case 0: {
      variant6= {
        tag: 'ipv4',
        val: {
          port: clampGuest(arg3, 0, 65535),
          address: [clampGuest(arg4, 0, 255), clampGuest(arg5, 0, 255), clampGuest(arg6, 0, 255), clampGuest(arg7, 0, 255)],
        }
      };
      break;
    }
    case 1: {
      variant6= {
        tag: 'ipv6',
        val: {
          port: clampGuest(arg3, 0, 65535),
          flowInfo: arg4 >>> 0,
          address: [clampGuest(arg5, 0, 65535), clampGuest(arg6, 0, 65535), clampGuest(arg7, 0, 65535), clampGuest(arg8, 0, 65535), clampGuest(arg9, 0, 65535), clampGuest(arg10, 0, 65535), clampGuest(arg11, 0, 65535), clampGuest(arg12, 0, 65535)],
          scopeId: arg13 >>> 0,
        }
      };
      break;
    }
    default: {
      throw new TypeError('invalid variant discriminant for IpSocketAddress');
    }
  }
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.start-connect"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.startConnect._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'startConnect',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.startConnect(rsc3, variant6)};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant8 = ret;
  switch (variant8.tag) {
    case 'ok': {
      const e = variant8.val;
      dataView(memory0).setInt8(arg14 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant8.val;
      dataView(memory0).setInt8(arg14 + 0, 1, true);
      var val7 = e;
      let enum7;
      switch (val7) {
        case 'unknown': {
          enum7 = 0;
          break;
        }
        case 'access-denied': {
          enum7 = 1;
          break;
        }
        case 'not-supported': {
          enum7 = 2;
          break;
        }
        case 'invalid-argument': {
          enum7 = 3;
          break;
        }
        case 'out-of-memory': {
          enum7 = 4;
          break;
        }
        case 'timeout': {
          enum7 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum7 = 6;
          break;
        }
        case 'not-in-progress': {
          enum7 = 7;
          break;
        }
        case 'would-block': {
          enum7 = 8;
          break;
        }
        case 'invalid-state': {
          enum7 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum7 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum7 = 11;
          break;
        }
        case 'address-in-use': {
          enum7 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum7 = 13;
          break;
        }
        case 'connection-refused': {
          enum7 = 14;
          break;
        }
        case 'connection-reset': {
          enum7 = 15;
          break;
        }
        case 'connection-aborted': {
          enum7 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum7 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum7 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum7 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum7 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val7}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg14 + 1, enum7, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.start-connect"][Instruction::Return]', {
    funcName: '[method]tcp-socket.start-connect',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_101_metadata = {
  qualifiedImportFn: 'wasi:sockets/tcp@0.2.0#[method]tcp-socket.finish-connect',
  moduleIdx: null,
};


function trampoline122(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable12[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable12.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(TcpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.finish-connect"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.finishConnect._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'finishConnect',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.finishConnect()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant7 = ret;
  switch (variant7.tag) {
    case 'ok': {
      const e = variant7.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      var [tuple3_0, tuple3_1] = e;
      if (!(tuple3_0 instanceof InputStream)) {
        throw new TypeError('Resource error: Not a valid "InputStream" resource.');
      }
      var handle4 = tuple3_0[symbolRscHandle];
      if (!handle4) {
        const rep = tuple3_0[symbolRscRep] || ++captureCnt2;
        captureTable2.set(rep, tuple3_0);
        handle4 = rscTableCreateOwn(handleTable2, rep);
      }
      dataView(memory0).setInt32(arg1 + 4, handle4, true);
      if (!(tuple3_1 instanceof OutputStream)) {
        throw new TypeError('Resource error: Not a valid "OutputStream" resource.');
      }
      var handle5 = tuple3_1[symbolRscHandle];
      if (!handle5) {
        const rep = tuple3_1[symbolRscRep] || ++captureCnt3;
        captureTable3.set(rep, tuple3_1);
        handle5 = rscTableCreateOwn(handleTable3, rep);
      }
      dataView(memory0).setInt32(arg1 + 8, handle5, true);
      break;
    }
    case 'err': {
      const e = variant7.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val6 = e;
      let enum6;
      switch (val6) {
        case 'unknown': {
          enum6 = 0;
          break;
        }
        case 'access-denied': {
          enum6 = 1;
          break;
        }
        case 'not-supported': {
          enum6 = 2;
          break;
        }
        case 'invalid-argument': {
          enum6 = 3;
          break;
        }
        case 'out-of-memory': {
          enum6 = 4;
          break;
        }
        case 'timeout': {
          enum6 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum6 = 6;
          break;
        }
        case 'not-in-progress': {
          enum6 = 7;
          break;
        }
        case 'would-block': {
          enum6 = 8;
          break;
        }
        case 'invalid-state': {
          enum6 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum6 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum6 = 11;
          break;
        }
        case 'address-in-use': {
          enum6 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum6 = 13;
          break;
        }
        case 'connection-refused': {
          enum6 = 14;
          break;
        }
        case 'connection-reset': {
          enum6 = 15;
          break;
        }
        case 'connection-aborted': {
          enum6 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum6 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum6 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum6 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum6 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val6}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 4, enum6, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.finish-connect"][Instruction::Return]', {
    funcName: '[method]tcp-socket.finish-connect',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_102_metadata = {
  qualifiedImportFn: 'wasi:sockets/tcp@0.2.0#[method]tcp-socket.start-listen',
  moduleIdx: null,
};


function trampoline123(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable12[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable12.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(TcpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.start-listen"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.startListen._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'startListen',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.startListen()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant4 = ret;
  switch (variant4.tag) {
    case 'ok': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val3 = e;
      let enum3;
      switch (val3) {
        case 'unknown': {
          enum3 = 0;
          break;
        }
        case 'access-denied': {
          enum3 = 1;
          break;
        }
        case 'not-supported': {
          enum3 = 2;
          break;
        }
        case 'invalid-argument': {
          enum3 = 3;
          break;
        }
        case 'out-of-memory': {
          enum3 = 4;
          break;
        }
        case 'timeout': {
          enum3 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum3 = 6;
          break;
        }
        case 'not-in-progress': {
          enum3 = 7;
          break;
        }
        case 'would-block': {
          enum3 = 8;
          break;
        }
        case 'invalid-state': {
          enum3 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum3 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum3 = 11;
          break;
        }
        case 'address-in-use': {
          enum3 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum3 = 13;
          break;
        }
        case 'connection-refused': {
          enum3 = 14;
          break;
        }
        case 'connection-reset': {
          enum3 = 15;
          break;
        }
        case 'connection-aborted': {
          enum3 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum3 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum3 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum3 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum3 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val3}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 1, enum3, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.start-listen"][Instruction::Return]', {
    funcName: '[method]tcp-socket.start-listen',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_103_metadata = {
  qualifiedImportFn: 'wasi:sockets/tcp@0.2.0#[method]tcp-socket.finish-listen',
  moduleIdx: null,
};


function trampoline124(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable12[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable12.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(TcpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.finish-listen"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.finishListen._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'finishListen',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.finishListen()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant4 = ret;
  switch (variant4.tag) {
    case 'ok': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val3 = e;
      let enum3;
      switch (val3) {
        case 'unknown': {
          enum3 = 0;
          break;
        }
        case 'access-denied': {
          enum3 = 1;
          break;
        }
        case 'not-supported': {
          enum3 = 2;
          break;
        }
        case 'invalid-argument': {
          enum3 = 3;
          break;
        }
        case 'out-of-memory': {
          enum3 = 4;
          break;
        }
        case 'timeout': {
          enum3 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum3 = 6;
          break;
        }
        case 'not-in-progress': {
          enum3 = 7;
          break;
        }
        case 'would-block': {
          enum3 = 8;
          break;
        }
        case 'invalid-state': {
          enum3 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum3 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum3 = 11;
          break;
        }
        case 'address-in-use': {
          enum3 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum3 = 13;
          break;
        }
        case 'connection-refused': {
          enum3 = 14;
          break;
        }
        case 'connection-reset': {
          enum3 = 15;
          break;
        }
        case 'connection-aborted': {
          enum3 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum3 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum3 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum3 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum3 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val3}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 1, enum3, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.finish-listen"][Instruction::Return]', {
    funcName: '[method]tcp-socket.finish-listen',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_104_metadata = {
  qualifiedImportFn: 'wasi:sockets/tcp@0.2.0#[method]tcp-socket.accept',
  moduleIdx: null,
};


function trampoline125(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable12[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable12.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(TcpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.accept"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.accept._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'accept',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.accept()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant8 = ret;
  switch (variant8.tag) {
    case 'ok': {
      const e = variant8.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      var [tuple3_0, tuple3_1, tuple3_2] = e;
      if (!(tuple3_0 instanceof TcpSocket)) {
        throw new TypeError('Resource error: Not a valid "TcpSocket" resource.');
      }
      var handle4 = tuple3_0[symbolRscHandle];
      if (!handle4) {
        const rep = tuple3_0[symbolRscRep] || ++captureCnt12;
        captureTable12.set(rep, tuple3_0);
        handle4 = rscTableCreateOwn(handleTable12, rep);
      }
      dataView(memory0).setInt32(arg1 + 4, handle4, true);
      if (!(tuple3_1 instanceof InputStream)) {
        throw new TypeError('Resource error: Not a valid "InputStream" resource.');
      }
      var handle5 = tuple3_1[symbolRscHandle];
      if (!handle5) {
        const rep = tuple3_1[symbolRscRep] || ++captureCnt2;
        captureTable2.set(rep, tuple3_1);
        handle5 = rscTableCreateOwn(handleTable2, rep);
      }
      dataView(memory0).setInt32(arg1 + 8, handle5, true);
      if (!(tuple3_2 instanceof OutputStream)) {
        throw new TypeError('Resource error: Not a valid "OutputStream" resource.');
      }
      var handle6 = tuple3_2[symbolRscHandle];
      if (!handle6) {
        const rep = tuple3_2[symbolRscRep] || ++captureCnt3;
        captureTable3.set(rep, tuple3_2);
        handle6 = rscTableCreateOwn(handleTable3, rep);
      }
      dataView(memory0).setInt32(arg1 + 12, handle6, true);
      break;
    }
    case 'err': {
      const e = variant8.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val7 = e;
      let enum7;
      switch (val7) {
        case 'unknown': {
          enum7 = 0;
          break;
        }
        case 'access-denied': {
          enum7 = 1;
          break;
        }
        case 'not-supported': {
          enum7 = 2;
          break;
        }
        case 'invalid-argument': {
          enum7 = 3;
          break;
        }
        case 'out-of-memory': {
          enum7 = 4;
          break;
        }
        case 'timeout': {
          enum7 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum7 = 6;
          break;
        }
        case 'not-in-progress': {
          enum7 = 7;
          break;
        }
        case 'would-block': {
          enum7 = 8;
          break;
        }
        case 'invalid-state': {
          enum7 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum7 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum7 = 11;
          break;
        }
        case 'address-in-use': {
          enum7 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum7 = 13;
          break;
        }
        case 'connection-refused': {
          enum7 = 14;
          break;
        }
        case 'connection-reset': {
          enum7 = 15;
          break;
        }
        case 'connection-aborted': {
          enum7 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum7 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum7 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum7 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum7 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val7}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 4, enum7, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.accept"][Instruction::Return]', {
    funcName: '[method]tcp-socket.accept',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_105_metadata = {
  qualifiedImportFn: 'wasi:sockets/tcp@0.2.0#[method]tcp-socket.local-address',
  moduleIdx: null,
};


function trampoline126(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable12[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable12.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(TcpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.local-address"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.localAddress._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'localAddress',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.localAddress()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant9 = ret;
  switch (variant9.tag) {
    case 'ok': {
      const e = variant9.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      var variant7 = e;
      switch (variant7.tag) {
        case 'ipv4': {
          const e = variant7.val;
          dataView(memory0).setInt8(arg1 + 4, 0, true);
          var {port: v3_0, address: v3_1 } = e;
          dataView(memory0).setInt16(arg1 + 8, toUint16(v3_0), true);
          var [tuple4_0, tuple4_1, tuple4_2, tuple4_3] = v3_1;
          dataView(memory0).setInt8(arg1 + 10, toUint8(tuple4_0), true);
          dataView(memory0).setInt8(arg1 + 11, toUint8(tuple4_1), true);
          dataView(memory0).setInt8(arg1 + 12, toUint8(tuple4_2), true);
          dataView(memory0).setInt8(arg1 + 13, toUint8(tuple4_3), true);
          break;
        }
        case 'ipv6': {
          const e = variant7.val;
          dataView(memory0).setInt8(arg1 + 4, 1, true);
          var {port: v5_0, flowInfo: v5_1, address: v5_2, scopeId: v5_3 } = e;
          dataView(memory0).setInt16(arg1 + 8, toUint16(v5_0), true);
          dataView(memory0).setInt32(arg1 + 12, toUint32(v5_1), true);
          var [tuple6_0, tuple6_1, tuple6_2, tuple6_3, tuple6_4, tuple6_5, tuple6_6, tuple6_7] = v5_2;
          dataView(memory0).setInt16(arg1 + 16, toUint16(tuple6_0), true);
          dataView(memory0).setInt16(arg1 + 18, toUint16(tuple6_1), true);
          dataView(memory0).setInt16(arg1 + 20, toUint16(tuple6_2), true);
          dataView(memory0).setInt16(arg1 + 22, toUint16(tuple6_3), true);
          dataView(memory0).setInt16(arg1 + 24, toUint16(tuple6_4), true);
          dataView(memory0).setInt16(arg1 + 26, toUint16(tuple6_5), true);
          dataView(memory0).setInt16(arg1 + 28, toUint16(tuple6_6), true);
          dataView(memory0).setInt16(arg1 + 30, toUint16(tuple6_7), true);
          dataView(memory0).setInt32(arg1 + 32, toUint32(v5_3), true);
          break;
        }
        default: {
          throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant7.tag)}\` (received \`${variant7}\`) specified for \`IpSocketAddress\``);
        }
      }
      break;
    }
    case 'err': {
      const e = variant9.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val8 = e;
      let enum8;
      switch (val8) {
        case 'unknown': {
          enum8 = 0;
          break;
        }
        case 'access-denied': {
          enum8 = 1;
          break;
        }
        case 'not-supported': {
          enum8 = 2;
          break;
        }
        case 'invalid-argument': {
          enum8 = 3;
          break;
        }
        case 'out-of-memory': {
          enum8 = 4;
          break;
        }
        case 'timeout': {
          enum8 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum8 = 6;
          break;
        }
        case 'not-in-progress': {
          enum8 = 7;
          break;
        }
        case 'would-block': {
          enum8 = 8;
          break;
        }
        case 'invalid-state': {
          enum8 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum8 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum8 = 11;
          break;
        }
        case 'address-in-use': {
          enum8 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum8 = 13;
          break;
        }
        case 'connection-refused': {
          enum8 = 14;
          break;
        }
        case 'connection-reset': {
          enum8 = 15;
          break;
        }
        case 'connection-aborted': {
          enum8 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum8 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum8 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum8 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum8 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val8}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 4, enum8, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.local-address"][Instruction::Return]', {
    funcName: '[method]tcp-socket.local-address',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_106_metadata = {
  qualifiedImportFn: 'wasi:sockets/tcp@0.2.0#[method]tcp-socket.remote-address',
  moduleIdx: null,
};


function trampoline127(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable12[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable12.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(TcpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.remote-address"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.remoteAddress._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'remoteAddress',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.remoteAddress()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant9 = ret;
  switch (variant9.tag) {
    case 'ok': {
      const e = variant9.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      var variant7 = e;
      switch (variant7.tag) {
        case 'ipv4': {
          const e = variant7.val;
          dataView(memory0).setInt8(arg1 + 4, 0, true);
          var {port: v3_0, address: v3_1 } = e;
          dataView(memory0).setInt16(arg1 + 8, toUint16(v3_0), true);
          var [tuple4_0, tuple4_1, tuple4_2, tuple4_3] = v3_1;
          dataView(memory0).setInt8(arg1 + 10, toUint8(tuple4_0), true);
          dataView(memory0).setInt8(arg1 + 11, toUint8(tuple4_1), true);
          dataView(memory0).setInt8(arg1 + 12, toUint8(tuple4_2), true);
          dataView(memory0).setInt8(arg1 + 13, toUint8(tuple4_3), true);
          break;
        }
        case 'ipv6': {
          const e = variant7.val;
          dataView(memory0).setInt8(arg1 + 4, 1, true);
          var {port: v5_0, flowInfo: v5_1, address: v5_2, scopeId: v5_3 } = e;
          dataView(memory0).setInt16(arg1 + 8, toUint16(v5_0), true);
          dataView(memory0).setInt32(arg1 + 12, toUint32(v5_1), true);
          var [tuple6_0, tuple6_1, tuple6_2, tuple6_3, tuple6_4, tuple6_5, tuple6_6, tuple6_7] = v5_2;
          dataView(memory0).setInt16(arg1 + 16, toUint16(tuple6_0), true);
          dataView(memory0).setInt16(arg1 + 18, toUint16(tuple6_1), true);
          dataView(memory0).setInt16(arg1 + 20, toUint16(tuple6_2), true);
          dataView(memory0).setInt16(arg1 + 22, toUint16(tuple6_3), true);
          dataView(memory0).setInt16(arg1 + 24, toUint16(tuple6_4), true);
          dataView(memory0).setInt16(arg1 + 26, toUint16(tuple6_5), true);
          dataView(memory0).setInt16(arg1 + 28, toUint16(tuple6_6), true);
          dataView(memory0).setInt16(arg1 + 30, toUint16(tuple6_7), true);
          dataView(memory0).setInt32(arg1 + 32, toUint32(v5_3), true);
          break;
        }
        default: {
          throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant7.tag)}\` (received \`${variant7}\`) specified for \`IpSocketAddress\``);
        }
      }
      break;
    }
    case 'err': {
      const e = variant9.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val8 = e;
      let enum8;
      switch (val8) {
        case 'unknown': {
          enum8 = 0;
          break;
        }
        case 'access-denied': {
          enum8 = 1;
          break;
        }
        case 'not-supported': {
          enum8 = 2;
          break;
        }
        case 'invalid-argument': {
          enum8 = 3;
          break;
        }
        case 'out-of-memory': {
          enum8 = 4;
          break;
        }
        case 'timeout': {
          enum8 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum8 = 6;
          break;
        }
        case 'not-in-progress': {
          enum8 = 7;
          break;
        }
        case 'would-block': {
          enum8 = 8;
          break;
        }
        case 'invalid-state': {
          enum8 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum8 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum8 = 11;
          break;
        }
        case 'address-in-use': {
          enum8 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum8 = 13;
          break;
        }
        case 'connection-refused': {
          enum8 = 14;
          break;
        }
        case 'connection-reset': {
          enum8 = 15;
          break;
        }
        case 'connection-aborted': {
          enum8 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum8 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum8 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum8 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum8 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val8}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 4, enum8, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.remote-address"][Instruction::Return]', {
    funcName: '[method]tcp-socket.remote-address',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_107_metadata = {
  qualifiedImportFn: 'wasi:sockets/tcp@0.2.0#[method]tcp-socket.set-listen-backlog-size',
  moduleIdx: null,
};


function trampoline128(arg0, arg1, arg2) {
  var handle1 = arg0;
  var rep2 = handleTable12[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable12.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(TcpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.set-listen-backlog-size"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.setListenBacklogSize._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'setListenBacklogSize',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.setListenBacklogSize(BigInt.asUintN(64, arg1))};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant4 = ret;
  switch (variant4.tag) {
    case 'ok': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg2 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg2 + 0, 1, true);
      var val3 = e;
      let enum3;
      switch (val3) {
        case 'unknown': {
          enum3 = 0;
          break;
        }
        case 'access-denied': {
          enum3 = 1;
          break;
        }
        case 'not-supported': {
          enum3 = 2;
          break;
        }
        case 'invalid-argument': {
          enum3 = 3;
          break;
        }
        case 'out-of-memory': {
          enum3 = 4;
          break;
        }
        case 'timeout': {
          enum3 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum3 = 6;
          break;
        }
        case 'not-in-progress': {
          enum3 = 7;
          break;
        }
        case 'would-block': {
          enum3 = 8;
          break;
        }
        case 'invalid-state': {
          enum3 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum3 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum3 = 11;
          break;
        }
        case 'address-in-use': {
          enum3 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum3 = 13;
          break;
        }
        case 'connection-refused': {
          enum3 = 14;
          break;
        }
        case 'connection-reset': {
          enum3 = 15;
          break;
        }
        case 'connection-aborted': {
          enum3 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum3 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum3 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum3 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum3 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val3}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg2 + 1, enum3, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.set-listen-backlog-size"][Instruction::Return]', {
    funcName: '[method]tcp-socket.set-listen-backlog-size',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_108_metadata = {
  qualifiedImportFn: 'wasi:sockets/tcp@0.2.0#[method]tcp-socket.keep-alive-enabled',
  moduleIdx: null,
};


function trampoline129(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable12[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable12.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(TcpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.keep-alive-enabled"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.keepAliveEnabled._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'keepAliveEnabled',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.keepAliveEnabled()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant4 = ret;
  switch (variant4.tag) {
    case 'ok': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      dataView(memory0).setInt8(arg1 + 1, e ? 1 : 0, true);
      break;
    }
    case 'err': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val3 = e;
      let enum3;
      switch (val3) {
        case 'unknown': {
          enum3 = 0;
          break;
        }
        case 'access-denied': {
          enum3 = 1;
          break;
        }
        case 'not-supported': {
          enum3 = 2;
          break;
        }
        case 'invalid-argument': {
          enum3 = 3;
          break;
        }
        case 'out-of-memory': {
          enum3 = 4;
          break;
        }
        case 'timeout': {
          enum3 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum3 = 6;
          break;
        }
        case 'not-in-progress': {
          enum3 = 7;
          break;
        }
        case 'would-block': {
          enum3 = 8;
          break;
        }
        case 'invalid-state': {
          enum3 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum3 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum3 = 11;
          break;
        }
        case 'address-in-use': {
          enum3 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum3 = 13;
          break;
        }
        case 'connection-refused': {
          enum3 = 14;
          break;
        }
        case 'connection-reset': {
          enum3 = 15;
          break;
        }
        case 'connection-aborted': {
          enum3 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum3 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum3 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum3 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum3 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val3}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 1, enum3, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.keep-alive-enabled"][Instruction::Return]', {
    funcName: '[method]tcp-socket.keep-alive-enabled',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_109_metadata = {
  qualifiedImportFn: 'wasi:sockets/tcp@0.2.0#[method]tcp-socket.set-keep-alive-enabled',
  moduleIdx: null,
};


function trampoline130(arg0, arg1, arg2) {
  var handle1 = arg0;
  var rep2 = handleTable12[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable12.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(TcpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  var bool3 = arg1;
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.set-keep-alive-enabled"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.setKeepAliveEnabled._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'setKeepAliveEnabled',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.setKeepAliveEnabled(bool3 == 0 ? false : (bool3 == 1 ? true : throwInvalidBool()))};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant5 = ret;
  switch (variant5.tag) {
    case 'ok': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg2 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg2 + 0, 1, true);
      var val4 = e;
      let enum4;
      switch (val4) {
        case 'unknown': {
          enum4 = 0;
          break;
        }
        case 'access-denied': {
          enum4 = 1;
          break;
        }
        case 'not-supported': {
          enum4 = 2;
          break;
        }
        case 'invalid-argument': {
          enum4 = 3;
          break;
        }
        case 'out-of-memory': {
          enum4 = 4;
          break;
        }
        case 'timeout': {
          enum4 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum4 = 6;
          break;
        }
        case 'not-in-progress': {
          enum4 = 7;
          break;
        }
        case 'would-block': {
          enum4 = 8;
          break;
        }
        case 'invalid-state': {
          enum4 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum4 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum4 = 11;
          break;
        }
        case 'address-in-use': {
          enum4 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum4 = 13;
          break;
        }
        case 'connection-refused': {
          enum4 = 14;
          break;
        }
        case 'connection-reset': {
          enum4 = 15;
          break;
        }
        case 'connection-aborted': {
          enum4 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum4 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum4 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum4 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum4 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val4}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg2 + 1, enum4, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.set-keep-alive-enabled"][Instruction::Return]', {
    funcName: '[method]tcp-socket.set-keep-alive-enabled',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_110_metadata = {
  qualifiedImportFn: 'wasi:sockets/tcp@0.2.0#[method]tcp-socket.keep-alive-idle-time',
  moduleIdx: null,
};


function trampoline131(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable12[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable12.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(TcpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.keep-alive-idle-time"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.keepAliveIdleTime._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'keepAliveIdleTime',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.keepAliveIdleTime()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant4 = ret;
  switch (variant4.tag) {
    case 'ok': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      dataView(memory0).setBigInt64(arg1 + 8, toUint64(e), true);
      break;
    }
    case 'err': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val3 = e;
      let enum3;
      switch (val3) {
        case 'unknown': {
          enum3 = 0;
          break;
        }
        case 'access-denied': {
          enum3 = 1;
          break;
        }
        case 'not-supported': {
          enum3 = 2;
          break;
        }
        case 'invalid-argument': {
          enum3 = 3;
          break;
        }
        case 'out-of-memory': {
          enum3 = 4;
          break;
        }
        case 'timeout': {
          enum3 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum3 = 6;
          break;
        }
        case 'not-in-progress': {
          enum3 = 7;
          break;
        }
        case 'would-block': {
          enum3 = 8;
          break;
        }
        case 'invalid-state': {
          enum3 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum3 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum3 = 11;
          break;
        }
        case 'address-in-use': {
          enum3 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum3 = 13;
          break;
        }
        case 'connection-refused': {
          enum3 = 14;
          break;
        }
        case 'connection-reset': {
          enum3 = 15;
          break;
        }
        case 'connection-aborted': {
          enum3 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum3 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum3 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum3 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum3 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val3}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 8, enum3, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.keep-alive-idle-time"][Instruction::Return]', {
    funcName: '[method]tcp-socket.keep-alive-idle-time',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_111_metadata = {
  qualifiedImportFn: 'wasi:sockets/tcp@0.2.0#[method]tcp-socket.set-keep-alive-idle-time',
  moduleIdx: null,
};


function trampoline132(arg0, arg1, arg2) {
  var handle1 = arg0;
  var rep2 = handleTable12[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable12.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(TcpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.set-keep-alive-idle-time"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.setKeepAliveIdleTime._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'setKeepAliveIdleTime',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.setKeepAliveIdleTime(BigInt.asUintN(64, arg1))};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant4 = ret;
  switch (variant4.tag) {
    case 'ok': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg2 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg2 + 0, 1, true);
      var val3 = e;
      let enum3;
      switch (val3) {
        case 'unknown': {
          enum3 = 0;
          break;
        }
        case 'access-denied': {
          enum3 = 1;
          break;
        }
        case 'not-supported': {
          enum3 = 2;
          break;
        }
        case 'invalid-argument': {
          enum3 = 3;
          break;
        }
        case 'out-of-memory': {
          enum3 = 4;
          break;
        }
        case 'timeout': {
          enum3 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum3 = 6;
          break;
        }
        case 'not-in-progress': {
          enum3 = 7;
          break;
        }
        case 'would-block': {
          enum3 = 8;
          break;
        }
        case 'invalid-state': {
          enum3 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum3 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum3 = 11;
          break;
        }
        case 'address-in-use': {
          enum3 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum3 = 13;
          break;
        }
        case 'connection-refused': {
          enum3 = 14;
          break;
        }
        case 'connection-reset': {
          enum3 = 15;
          break;
        }
        case 'connection-aborted': {
          enum3 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum3 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum3 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum3 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum3 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val3}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg2 + 1, enum3, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.set-keep-alive-idle-time"][Instruction::Return]', {
    funcName: '[method]tcp-socket.set-keep-alive-idle-time',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_112_metadata = {
  qualifiedImportFn: 'wasi:sockets/tcp@0.2.0#[method]tcp-socket.keep-alive-interval',
  moduleIdx: null,
};


function trampoline133(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable12[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable12.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(TcpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.keep-alive-interval"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.keepAliveInterval._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'keepAliveInterval',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.keepAliveInterval()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant4 = ret;
  switch (variant4.tag) {
    case 'ok': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      dataView(memory0).setBigInt64(arg1 + 8, toUint64(e), true);
      break;
    }
    case 'err': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val3 = e;
      let enum3;
      switch (val3) {
        case 'unknown': {
          enum3 = 0;
          break;
        }
        case 'access-denied': {
          enum3 = 1;
          break;
        }
        case 'not-supported': {
          enum3 = 2;
          break;
        }
        case 'invalid-argument': {
          enum3 = 3;
          break;
        }
        case 'out-of-memory': {
          enum3 = 4;
          break;
        }
        case 'timeout': {
          enum3 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum3 = 6;
          break;
        }
        case 'not-in-progress': {
          enum3 = 7;
          break;
        }
        case 'would-block': {
          enum3 = 8;
          break;
        }
        case 'invalid-state': {
          enum3 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum3 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum3 = 11;
          break;
        }
        case 'address-in-use': {
          enum3 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum3 = 13;
          break;
        }
        case 'connection-refused': {
          enum3 = 14;
          break;
        }
        case 'connection-reset': {
          enum3 = 15;
          break;
        }
        case 'connection-aborted': {
          enum3 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum3 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum3 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum3 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum3 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val3}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 8, enum3, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.keep-alive-interval"][Instruction::Return]', {
    funcName: '[method]tcp-socket.keep-alive-interval',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_113_metadata = {
  qualifiedImportFn: 'wasi:sockets/tcp@0.2.0#[method]tcp-socket.set-keep-alive-interval',
  moduleIdx: null,
};


function trampoline134(arg0, arg1, arg2) {
  var handle1 = arg0;
  var rep2 = handleTable12[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable12.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(TcpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.set-keep-alive-interval"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.setKeepAliveInterval._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'setKeepAliveInterval',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.setKeepAliveInterval(BigInt.asUintN(64, arg1))};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant4 = ret;
  switch (variant4.tag) {
    case 'ok': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg2 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg2 + 0, 1, true);
      var val3 = e;
      let enum3;
      switch (val3) {
        case 'unknown': {
          enum3 = 0;
          break;
        }
        case 'access-denied': {
          enum3 = 1;
          break;
        }
        case 'not-supported': {
          enum3 = 2;
          break;
        }
        case 'invalid-argument': {
          enum3 = 3;
          break;
        }
        case 'out-of-memory': {
          enum3 = 4;
          break;
        }
        case 'timeout': {
          enum3 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum3 = 6;
          break;
        }
        case 'not-in-progress': {
          enum3 = 7;
          break;
        }
        case 'would-block': {
          enum3 = 8;
          break;
        }
        case 'invalid-state': {
          enum3 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum3 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum3 = 11;
          break;
        }
        case 'address-in-use': {
          enum3 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum3 = 13;
          break;
        }
        case 'connection-refused': {
          enum3 = 14;
          break;
        }
        case 'connection-reset': {
          enum3 = 15;
          break;
        }
        case 'connection-aborted': {
          enum3 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum3 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum3 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum3 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum3 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val3}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg2 + 1, enum3, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.set-keep-alive-interval"][Instruction::Return]', {
    funcName: '[method]tcp-socket.set-keep-alive-interval',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_114_metadata = {
  qualifiedImportFn: 'wasi:sockets/tcp@0.2.0#[method]tcp-socket.keep-alive-count',
  moduleIdx: null,
};


function trampoline135(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable12[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable12.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(TcpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.keep-alive-count"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.keepAliveCount._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'keepAliveCount',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.keepAliveCount()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant4 = ret;
  switch (variant4.tag) {
    case 'ok': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      dataView(memory0).setInt32(arg1 + 4, toUint32(e), true);
      break;
    }
    case 'err': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val3 = e;
      let enum3;
      switch (val3) {
        case 'unknown': {
          enum3 = 0;
          break;
        }
        case 'access-denied': {
          enum3 = 1;
          break;
        }
        case 'not-supported': {
          enum3 = 2;
          break;
        }
        case 'invalid-argument': {
          enum3 = 3;
          break;
        }
        case 'out-of-memory': {
          enum3 = 4;
          break;
        }
        case 'timeout': {
          enum3 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum3 = 6;
          break;
        }
        case 'not-in-progress': {
          enum3 = 7;
          break;
        }
        case 'would-block': {
          enum3 = 8;
          break;
        }
        case 'invalid-state': {
          enum3 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum3 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum3 = 11;
          break;
        }
        case 'address-in-use': {
          enum3 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum3 = 13;
          break;
        }
        case 'connection-refused': {
          enum3 = 14;
          break;
        }
        case 'connection-reset': {
          enum3 = 15;
          break;
        }
        case 'connection-aborted': {
          enum3 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum3 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum3 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum3 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum3 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val3}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 4, enum3, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.keep-alive-count"][Instruction::Return]', {
    funcName: '[method]tcp-socket.keep-alive-count',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_115_metadata = {
  qualifiedImportFn: 'wasi:sockets/tcp@0.2.0#[method]tcp-socket.set-keep-alive-count',
  moduleIdx: null,
};


function trampoline136(arg0, arg1, arg2) {
  var handle1 = arg0;
  var rep2 = handleTable12[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable12.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(TcpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.set-keep-alive-count"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.setKeepAliveCount._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'setKeepAliveCount',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.setKeepAliveCount(arg1 >>> 0)};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant4 = ret;
  switch (variant4.tag) {
    case 'ok': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg2 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg2 + 0, 1, true);
      var val3 = e;
      let enum3;
      switch (val3) {
        case 'unknown': {
          enum3 = 0;
          break;
        }
        case 'access-denied': {
          enum3 = 1;
          break;
        }
        case 'not-supported': {
          enum3 = 2;
          break;
        }
        case 'invalid-argument': {
          enum3 = 3;
          break;
        }
        case 'out-of-memory': {
          enum3 = 4;
          break;
        }
        case 'timeout': {
          enum3 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum3 = 6;
          break;
        }
        case 'not-in-progress': {
          enum3 = 7;
          break;
        }
        case 'would-block': {
          enum3 = 8;
          break;
        }
        case 'invalid-state': {
          enum3 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum3 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum3 = 11;
          break;
        }
        case 'address-in-use': {
          enum3 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum3 = 13;
          break;
        }
        case 'connection-refused': {
          enum3 = 14;
          break;
        }
        case 'connection-reset': {
          enum3 = 15;
          break;
        }
        case 'connection-aborted': {
          enum3 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum3 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum3 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum3 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum3 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val3}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg2 + 1, enum3, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.set-keep-alive-count"][Instruction::Return]', {
    funcName: '[method]tcp-socket.set-keep-alive-count',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_116_metadata = {
  qualifiedImportFn: 'wasi:sockets/tcp@0.2.0#[method]tcp-socket.hop-limit',
  moduleIdx: null,
};


function trampoline137(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable12[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable12.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(TcpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.hop-limit"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.hopLimit._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'hopLimit',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.hopLimit()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant4 = ret;
  switch (variant4.tag) {
    case 'ok': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      dataView(memory0).setInt8(arg1 + 1, toUint8(e), true);
      break;
    }
    case 'err': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val3 = e;
      let enum3;
      switch (val3) {
        case 'unknown': {
          enum3 = 0;
          break;
        }
        case 'access-denied': {
          enum3 = 1;
          break;
        }
        case 'not-supported': {
          enum3 = 2;
          break;
        }
        case 'invalid-argument': {
          enum3 = 3;
          break;
        }
        case 'out-of-memory': {
          enum3 = 4;
          break;
        }
        case 'timeout': {
          enum3 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum3 = 6;
          break;
        }
        case 'not-in-progress': {
          enum3 = 7;
          break;
        }
        case 'would-block': {
          enum3 = 8;
          break;
        }
        case 'invalid-state': {
          enum3 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum3 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum3 = 11;
          break;
        }
        case 'address-in-use': {
          enum3 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum3 = 13;
          break;
        }
        case 'connection-refused': {
          enum3 = 14;
          break;
        }
        case 'connection-reset': {
          enum3 = 15;
          break;
        }
        case 'connection-aborted': {
          enum3 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum3 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum3 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum3 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum3 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val3}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 1, enum3, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.hop-limit"][Instruction::Return]', {
    funcName: '[method]tcp-socket.hop-limit',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_117_metadata = {
  qualifiedImportFn: 'wasi:sockets/tcp@0.2.0#[method]tcp-socket.set-hop-limit',
  moduleIdx: null,
};


function trampoline138(arg0, arg1, arg2) {
  var handle1 = arg0;
  var rep2 = handleTable12[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable12.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(TcpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.set-hop-limit"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.setHopLimit._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'setHopLimit',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.setHopLimit(clampGuest(arg1, 0, 255))};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant4 = ret;
  switch (variant4.tag) {
    case 'ok': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg2 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg2 + 0, 1, true);
      var val3 = e;
      let enum3;
      switch (val3) {
        case 'unknown': {
          enum3 = 0;
          break;
        }
        case 'access-denied': {
          enum3 = 1;
          break;
        }
        case 'not-supported': {
          enum3 = 2;
          break;
        }
        case 'invalid-argument': {
          enum3 = 3;
          break;
        }
        case 'out-of-memory': {
          enum3 = 4;
          break;
        }
        case 'timeout': {
          enum3 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum3 = 6;
          break;
        }
        case 'not-in-progress': {
          enum3 = 7;
          break;
        }
        case 'would-block': {
          enum3 = 8;
          break;
        }
        case 'invalid-state': {
          enum3 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum3 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum3 = 11;
          break;
        }
        case 'address-in-use': {
          enum3 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum3 = 13;
          break;
        }
        case 'connection-refused': {
          enum3 = 14;
          break;
        }
        case 'connection-reset': {
          enum3 = 15;
          break;
        }
        case 'connection-aborted': {
          enum3 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum3 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum3 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum3 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum3 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val3}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg2 + 1, enum3, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.set-hop-limit"][Instruction::Return]', {
    funcName: '[method]tcp-socket.set-hop-limit',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_118_metadata = {
  qualifiedImportFn: 'wasi:sockets/tcp@0.2.0#[method]tcp-socket.receive-buffer-size',
  moduleIdx: null,
};


function trampoline139(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable12[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable12.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(TcpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.receive-buffer-size"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.receiveBufferSize._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'receiveBufferSize',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.receiveBufferSize()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant4 = ret;
  switch (variant4.tag) {
    case 'ok': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      dataView(memory0).setBigInt64(arg1 + 8, toUint64(e), true);
      break;
    }
    case 'err': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val3 = e;
      let enum3;
      switch (val3) {
        case 'unknown': {
          enum3 = 0;
          break;
        }
        case 'access-denied': {
          enum3 = 1;
          break;
        }
        case 'not-supported': {
          enum3 = 2;
          break;
        }
        case 'invalid-argument': {
          enum3 = 3;
          break;
        }
        case 'out-of-memory': {
          enum3 = 4;
          break;
        }
        case 'timeout': {
          enum3 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum3 = 6;
          break;
        }
        case 'not-in-progress': {
          enum3 = 7;
          break;
        }
        case 'would-block': {
          enum3 = 8;
          break;
        }
        case 'invalid-state': {
          enum3 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum3 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum3 = 11;
          break;
        }
        case 'address-in-use': {
          enum3 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum3 = 13;
          break;
        }
        case 'connection-refused': {
          enum3 = 14;
          break;
        }
        case 'connection-reset': {
          enum3 = 15;
          break;
        }
        case 'connection-aborted': {
          enum3 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum3 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum3 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum3 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum3 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val3}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 8, enum3, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.receive-buffer-size"][Instruction::Return]', {
    funcName: '[method]tcp-socket.receive-buffer-size',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_119_metadata = {
  qualifiedImportFn: 'wasi:sockets/tcp@0.2.0#[method]tcp-socket.set-receive-buffer-size',
  moduleIdx: null,
};


function trampoline140(arg0, arg1, arg2) {
  var handle1 = arg0;
  var rep2 = handleTable12[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable12.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(TcpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.set-receive-buffer-size"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.setReceiveBufferSize._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'setReceiveBufferSize',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.setReceiveBufferSize(BigInt.asUintN(64, arg1))};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant4 = ret;
  switch (variant4.tag) {
    case 'ok': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg2 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg2 + 0, 1, true);
      var val3 = e;
      let enum3;
      switch (val3) {
        case 'unknown': {
          enum3 = 0;
          break;
        }
        case 'access-denied': {
          enum3 = 1;
          break;
        }
        case 'not-supported': {
          enum3 = 2;
          break;
        }
        case 'invalid-argument': {
          enum3 = 3;
          break;
        }
        case 'out-of-memory': {
          enum3 = 4;
          break;
        }
        case 'timeout': {
          enum3 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum3 = 6;
          break;
        }
        case 'not-in-progress': {
          enum3 = 7;
          break;
        }
        case 'would-block': {
          enum3 = 8;
          break;
        }
        case 'invalid-state': {
          enum3 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum3 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum3 = 11;
          break;
        }
        case 'address-in-use': {
          enum3 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum3 = 13;
          break;
        }
        case 'connection-refused': {
          enum3 = 14;
          break;
        }
        case 'connection-reset': {
          enum3 = 15;
          break;
        }
        case 'connection-aborted': {
          enum3 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum3 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum3 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum3 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum3 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val3}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg2 + 1, enum3, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.set-receive-buffer-size"][Instruction::Return]', {
    funcName: '[method]tcp-socket.set-receive-buffer-size',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_120_metadata = {
  qualifiedImportFn: 'wasi:sockets/tcp@0.2.0#[method]tcp-socket.send-buffer-size',
  moduleIdx: null,
};


function trampoline141(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable12[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable12.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(TcpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.send-buffer-size"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.sendBufferSize._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'sendBufferSize',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.sendBufferSize()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant4 = ret;
  switch (variant4.tag) {
    case 'ok': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      dataView(memory0).setBigInt64(arg1 + 8, toUint64(e), true);
      break;
    }
    case 'err': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val3 = e;
      let enum3;
      switch (val3) {
        case 'unknown': {
          enum3 = 0;
          break;
        }
        case 'access-denied': {
          enum3 = 1;
          break;
        }
        case 'not-supported': {
          enum3 = 2;
          break;
        }
        case 'invalid-argument': {
          enum3 = 3;
          break;
        }
        case 'out-of-memory': {
          enum3 = 4;
          break;
        }
        case 'timeout': {
          enum3 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum3 = 6;
          break;
        }
        case 'not-in-progress': {
          enum3 = 7;
          break;
        }
        case 'would-block': {
          enum3 = 8;
          break;
        }
        case 'invalid-state': {
          enum3 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum3 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum3 = 11;
          break;
        }
        case 'address-in-use': {
          enum3 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum3 = 13;
          break;
        }
        case 'connection-refused': {
          enum3 = 14;
          break;
        }
        case 'connection-reset': {
          enum3 = 15;
          break;
        }
        case 'connection-aborted': {
          enum3 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum3 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum3 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum3 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum3 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val3}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 8, enum3, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.send-buffer-size"][Instruction::Return]', {
    funcName: '[method]tcp-socket.send-buffer-size',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_121_metadata = {
  qualifiedImportFn: 'wasi:sockets/tcp@0.2.0#[method]tcp-socket.set-send-buffer-size',
  moduleIdx: null,
};


function trampoline142(arg0, arg1, arg2) {
  var handle1 = arg0;
  var rep2 = handleTable12[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable12.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(TcpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.set-send-buffer-size"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.setSendBufferSize._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'setSendBufferSize',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.setSendBufferSize(BigInt.asUintN(64, arg1))};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant4 = ret;
  switch (variant4.tag) {
    case 'ok': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg2 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg2 + 0, 1, true);
      var val3 = e;
      let enum3;
      switch (val3) {
        case 'unknown': {
          enum3 = 0;
          break;
        }
        case 'access-denied': {
          enum3 = 1;
          break;
        }
        case 'not-supported': {
          enum3 = 2;
          break;
        }
        case 'invalid-argument': {
          enum3 = 3;
          break;
        }
        case 'out-of-memory': {
          enum3 = 4;
          break;
        }
        case 'timeout': {
          enum3 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum3 = 6;
          break;
        }
        case 'not-in-progress': {
          enum3 = 7;
          break;
        }
        case 'would-block': {
          enum3 = 8;
          break;
        }
        case 'invalid-state': {
          enum3 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum3 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum3 = 11;
          break;
        }
        case 'address-in-use': {
          enum3 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum3 = 13;
          break;
        }
        case 'connection-refused': {
          enum3 = 14;
          break;
        }
        case 'connection-reset': {
          enum3 = 15;
          break;
        }
        case 'connection-aborted': {
          enum3 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum3 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum3 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum3 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum3 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val3}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg2 + 1, enum3, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.set-send-buffer-size"][Instruction::Return]', {
    funcName: '[method]tcp-socket.set-send-buffer-size',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_122_metadata = {
  qualifiedImportFn: 'wasi:sockets/tcp@0.2.0#[method]tcp-socket.shutdown',
  moduleIdx: null,
};


function trampoline143(arg0, arg1, arg2) {
  var handle1 = arg0;
  var rep2 = handleTable12[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable12.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(TcpSocket.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  let enum3;
  switch (arg1) {
    case 0: {
      enum3 = 'receive';
      break;
    }
    case 1: {
      enum3 = 'send';
      break;
    }
    case 2: {
      enum3 = 'both';
      break;
    }
    default: {
      throw new TypeError('invalid discriminant specified for ShutdownType');
    }
  }
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.shutdown"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.shutdown._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'shutdown',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.shutdown(enum3)};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant5 = ret;
  switch (variant5.tag) {
    case 'ok': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg2 + 0, 0, true);
      break;
    }
    case 'err': {
      const e = variant5.val;
      dataView(memory0).setInt8(arg2 + 0, 1, true);
      var val4 = e;
      let enum4;
      switch (val4) {
        case 'unknown': {
          enum4 = 0;
          break;
        }
        case 'access-denied': {
          enum4 = 1;
          break;
        }
        case 'not-supported': {
          enum4 = 2;
          break;
        }
        case 'invalid-argument': {
          enum4 = 3;
          break;
        }
        case 'out-of-memory': {
          enum4 = 4;
          break;
        }
        case 'timeout': {
          enum4 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum4 = 6;
          break;
        }
        case 'not-in-progress': {
          enum4 = 7;
          break;
        }
        case 'would-block': {
          enum4 = 8;
          break;
        }
        case 'invalid-state': {
          enum4 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum4 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum4 = 11;
          break;
        }
        case 'address-in-use': {
          enum4 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum4 = 13;
          break;
        }
        case 'connection-refused': {
          enum4 = 14;
          break;
        }
        case 'connection-reset': {
          enum4 = 15;
          break;
        }
        case 'connection-aborted': {
          enum4 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum4 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum4 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum4 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum4 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val4}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg2 + 1, enum4, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/tcp@0.2.0", function="[method]tcp-socket.shutdown"][Instruction::Return]', {
    funcName: '[method]tcp-socket.shutdown',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_123_metadata = {
  qualifiedImportFn: 'wasi:sockets/ip-name-lookup@0.2.0#resolve-addresses',
  moduleIdx: null,
};


function trampoline144(arg0, arg1, arg2, arg3) {
  var handle1 = arg0;
  var rep2 = handleTable8[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable8.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(Network.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  var ptr3 = arg1;
  var len3 = arg2;
  var result3 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr3, len3));
  _debugLog('[iface="wasi:sockets/ip-name-lookup@0.2.0", function="resolve-addresses"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = resolveAddresses._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'resolveAddresses',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  resolveAddresses(rsc0, result3)};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant6 = ret;
  switch (variant6.tag) {
    case 'ok': {
      const e = variant6.val;
      dataView(memory0).setInt8(arg3 + 0, 0, true);
      if (!(e instanceof ResolveAddressStream)) {
        throw new TypeError('Resource error: Not a valid "ResolveAddressStream" resource.');
      }
      var handle4 = e[symbolRscHandle];
      if (!handle4) {
        const rep = e[symbolRscRep] || ++captureCnt13;
        captureTable13.set(rep, e);
        handle4 = rscTableCreateOwn(handleTable13, rep);
      }
      dataView(memory0).setInt32(arg3 + 4, handle4, true);
      break;
    }
    case 'err': {
      const e = variant6.val;
      dataView(memory0).setInt8(arg3 + 0, 1, true);
      var val5 = e;
      let enum5;
      switch (val5) {
        case 'unknown': {
          enum5 = 0;
          break;
        }
        case 'access-denied': {
          enum5 = 1;
          break;
        }
        case 'not-supported': {
          enum5 = 2;
          break;
        }
        case 'invalid-argument': {
          enum5 = 3;
          break;
        }
        case 'out-of-memory': {
          enum5 = 4;
          break;
        }
        case 'timeout': {
          enum5 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum5 = 6;
          break;
        }
        case 'not-in-progress': {
          enum5 = 7;
          break;
        }
        case 'would-block': {
          enum5 = 8;
          break;
        }
        case 'invalid-state': {
          enum5 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum5 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum5 = 11;
          break;
        }
        case 'address-in-use': {
          enum5 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum5 = 13;
          break;
        }
        case 'connection-refused': {
          enum5 = 14;
          break;
        }
        case 'connection-reset': {
          enum5 = 15;
          break;
        }
        case 'connection-aborted': {
          enum5 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum5 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum5 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum5 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum5 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val5}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg3 + 4, enum5, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/ip-name-lookup@0.2.0", function="resolve-addresses"][Instruction::Return]', {
    funcName: 'resolve-addresses',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_124_metadata = {
  qualifiedImportFn: 'wasi:sockets/ip-name-lookup@0.2.0#[method]resolve-address-stream.resolve-next-address',
  moduleIdx: null,
};


function trampoline145(arg0, arg1) {
  var handle1 = arg0;
  var rep2 = handleTable13[(handle1 << 1) + 1] & ~T_FLAG;
  var rsc0 = captureTable13.get(rep2);
  if (!rsc0) {
    rsc0 = Object.create(ResolveAddressStream.prototype);
    Object.defineProperty(rsc0, symbolRscHandle, { writable: true, value: handle1});
    Object.defineProperty(rsc0, symbolRscRep, { writable: true, value: rep2});
  }
  curResourceBorrows.push(rsc0);
  _debugLog('[iface="wasi:sockets/ip-name-lookup@0.2.0", function="[method]resolve-address-stream.resolve-next-address"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = rsc0.resolveNextAddress._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'resolveNextAddress',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  rsc0.resolveNextAddress()};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  for (const rsc of curResourceBorrows) {
    rsc[symbolRscHandle] = undefined;
  }
  curResourceBorrows = [];
  endCurrentTask(0);
  var variant8 = ret;
  switch (variant8.tag) {
    case 'ok': {
      const e = variant8.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      var variant6 = e;
      if (variant6 === null || variant6=== undefined) {
        dataView(memory0).setInt8(arg1 + 2, 0, true);
      } else {
        const e = variant6;
        dataView(memory0).setInt8(arg1 + 2, 1, true);
        var variant5 = e;
        switch (variant5.tag) {
          case 'ipv4': {
            const e = variant5.val;
            dataView(memory0).setInt8(arg1 + 4, 0, true);
            var [tuple3_0, tuple3_1, tuple3_2, tuple3_3] = e;
            dataView(memory0).setInt8(arg1 + 6, toUint8(tuple3_0), true);
            dataView(memory0).setInt8(arg1 + 7, toUint8(tuple3_1), true);
            dataView(memory0).setInt8(arg1 + 8, toUint8(tuple3_2), true);
            dataView(memory0).setInt8(arg1 + 9, toUint8(tuple3_3), true);
            break;
          }
          case 'ipv6': {
            const e = variant5.val;
            dataView(memory0).setInt8(arg1 + 4, 1, true);
            var [tuple4_0, tuple4_1, tuple4_2, tuple4_3, tuple4_4, tuple4_5, tuple4_6, tuple4_7] = e;
            dataView(memory0).setInt16(arg1 + 6, toUint16(tuple4_0), true);
            dataView(memory0).setInt16(arg1 + 8, toUint16(tuple4_1), true);
            dataView(memory0).setInt16(arg1 + 10, toUint16(tuple4_2), true);
            dataView(memory0).setInt16(arg1 + 12, toUint16(tuple4_3), true);
            dataView(memory0).setInt16(arg1 + 14, toUint16(tuple4_4), true);
            dataView(memory0).setInt16(arg1 + 16, toUint16(tuple4_5), true);
            dataView(memory0).setInt16(arg1 + 18, toUint16(tuple4_6), true);
            dataView(memory0).setInt16(arg1 + 20, toUint16(tuple4_7), true);
            break;
          }
          default: {
            throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant5.tag)}\` (received \`${variant5}\`) specified for \`IpAddress\``);
          }
        }
      }
      break;
    }
    case 'err': {
      const e = variant8.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val7 = e;
      let enum7;
      switch (val7) {
        case 'unknown': {
          enum7 = 0;
          break;
        }
        case 'access-denied': {
          enum7 = 1;
          break;
        }
        case 'not-supported': {
          enum7 = 2;
          break;
        }
        case 'invalid-argument': {
          enum7 = 3;
          break;
        }
        case 'out-of-memory': {
          enum7 = 4;
          break;
        }
        case 'timeout': {
          enum7 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum7 = 6;
          break;
        }
        case 'not-in-progress': {
          enum7 = 7;
          break;
        }
        case 'would-block': {
          enum7 = 8;
          break;
        }
        case 'invalid-state': {
          enum7 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum7 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum7 = 11;
          break;
        }
        case 'address-in-use': {
          enum7 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum7 = 13;
          break;
        }
        case 'connection-refused': {
          enum7 = 14;
          break;
        }
        case 'connection-reset': {
          enum7 = 15;
          break;
        }
        case 'connection-aborted': {
          enum7 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum7 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum7 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum7 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum7 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val7}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 2, enum7, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/ip-name-lookup@0.2.0", function="[method]resolve-address-stream.resolve-next-address"][Instruction::Return]', {
    funcName: '[method]resolve-address-stream.resolve-next-address',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_125_metadata = {
  qualifiedImportFn: 'wasi:cli/environment@0.2.0#get-environment',
  moduleIdx: null,
};


function trampoline146(arg0) {
  _debugLog('[iface="wasi:cli/environment@0.2.0", function="get-environment"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = getEnvironment._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'getEnvironment',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  getEnvironment();
  endCurrentTask(0);
  var vec3 = ret;
  var len3 = vec3.length;
  var result3 = realloc1(0, 0, 4, len3 * 16);
  for (let i = 0; i < vec3.length; i++) {
    const e = vec3[i];
    const base = result3 + i * 16;var [tuple0_0, tuple0_1] = e;
    
    var encodeRes = _utf8AllocateAndEncode(tuple0_0, realloc1, memory0);
    var ptr1= encodeRes.ptr;
    var len1 = encodeRes.len;
    
    dataView(memory0).setUint32(base + 4, len1, true);
    dataView(memory0).setUint32(base + 0, ptr1, true);
    
    var encodeRes = _utf8AllocateAndEncode(tuple0_1, realloc1, memory0);
    var ptr2= encodeRes.ptr;
    var len2 = encodeRes.len;
    
    dataView(memory0).setUint32(base + 12, len2, true);
    dataView(memory0).setUint32(base + 8, ptr2, true);
  }
  dataView(memory0).setUint32(arg0 + 4, len3, true);
  dataView(memory0).setUint32(arg0 + 0, result3, true);
  _debugLog('[iface="wasi:cli/environment@0.2.0", function="get-environment"][Instruction::Return]', {
    funcName: 'get-environment',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_126_metadata = {
  qualifiedImportFn: 'wasi:cli/environment@0.2.0#get-arguments',
  moduleIdx: null,
};


function trampoline147(arg0) {
  _debugLog('[iface="wasi:cli/environment@0.2.0", function="get-arguments"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = getArguments._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'getArguments',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  getArguments();
  endCurrentTask(0);
  var vec1 = ret;
  var len1 = vec1.length;
  var result1 = realloc1(0, 0, 4, len1 * 8);
  for (let i = 0; i < vec1.length; i++) {
    const e = vec1[i];
    const base = result1 + i * 8;
    var encodeRes = _utf8AllocateAndEncode(e, realloc1, memory0);
    var ptr0= encodeRes.ptr;
    var len0 = encodeRes.len;
    
    dataView(memory0).setUint32(base + 4, len0, true);
    dataView(memory0).setUint32(base + 0, ptr0, true);
  }
  dataView(memory0).setUint32(arg0 + 4, len1, true);
  dataView(memory0).setUint32(arg0 + 0, result1, true);
  _debugLog('[iface="wasi:cli/environment@0.2.0", function="get-arguments"][Instruction::Return]', {
    funcName: 'get-arguments',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_127_metadata = {
  qualifiedImportFn: 'wasi:cli/environment@0.2.0#initial-cwd',
  moduleIdx: null,
};


function trampoline148(arg0) {
  _debugLog('[iface="wasi:cli/environment@0.2.0", function="initial-cwd"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = initialCwd._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'initialCwd',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  initialCwd();
  endCurrentTask(0);
  var variant1 = ret;
  if (variant1 === null || variant1=== undefined) {
    dataView(memory0).setInt8(arg0 + 0, 0, true);
  } else {
    const e = variant1;
    dataView(memory0).setInt8(arg0 + 0, 1, true);
    
    var encodeRes = _utf8AllocateAndEncode(e, realloc1, memory0);
    var ptr0= encodeRes.ptr;
    var len0 = encodeRes.len;
    
    dataView(memory0).setUint32(arg0 + 8, len0, true);
    dataView(memory0).setUint32(arg0 + 4, ptr0, true);
  }
  _debugLog('[iface="wasi:cli/environment@0.2.0", function="initial-cwd"][Instruction::Return]', {
    funcName: 'initial-cwd',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_128_metadata = {
  qualifiedImportFn: 'wasi:filesystem/preopens@0.2.0#get-directories',
  moduleIdx: null,
};


function trampoline149(arg0) {
  _debugLog('[iface="wasi:filesystem/preopens@0.2.0", function="get-directories"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = getDirectories._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'getDirectories',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  getDirectories();
  endCurrentTask(0);
  var vec3 = ret;
  var len3 = vec3.length;
  var result3 = realloc1(0, 0, 4, len3 * 12);
  for (let i = 0; i < vec3.length; i++) {
    const e = vec3[i];
    const base = result3 + i * 12;var [tuple0_0, tuple0_1] = e;
    if (!(tuple0_0 instanceof Descriptor)) {
      throw new TypeError('Resource error: Not a valid "Descriptor" resource.');
    }
    var handle1 = tuple0_0[symbolRscHandle];
    if (!handle1) {
      const rep = tuple0_0[symbolRscRep] || ++captureCnt6;
      captureTable6.set(rep, tuple0_0);
      handle1 = rscTableCreateOwn(handleTable6, rep);
    }
    dataView(memory0).setInt32(base + 0, handle1, true);
    
    var encodeRes = _utf8AllocateAndEncode(tuple0_1, realloc1, memory0);
    var ptr2= encodeRes.ptr;
    var len2 = encodeRes.len;
    
    dataView(memory0).setUint32(base + 8, len2, true);
    dataView(memory0).setUint32(base + 4, ptr2, true);
  }
  dataView(memory0).setUint32(arg0 + 4, len3, true);
  dataView(memory0).setUint32(arg0 + 0, result3, true);
  _debugLog('[iface="wasi:filesystem/preopens@0.2.0", function="get-directories"][Instruction::Return]', {
    funcName: 'get-directories',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_129_metadata = {
  qualifiedImportFn: 'wasi:sockets/udp-create-socket@0.2.0#create-udp-socket',
  moduleIdx: null,
};


function trampoline150(arg0, arg1) {
  let enum0;
  switch (arg0) {
    case 0: {
      enum0 = 'ipv4';
      break;
    }
    case 1: {
      enum0 = 'ipv6';
      break;
    }
    default: {
      throw new TypeError('invalid discriminant specified for IpAddressFamily');
    }
  }
  _debugLog('[iface="wasi:sockets/udp-create-socket@0.2.0", function="create-udp-socket"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = createUdpSocket._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'createUdpSocket',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  createUdpSocket(enum0)};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  endCurrentTask(0);
  var variant3 = ret;
  switch (variant3.tag) {
    case 'ok': {
      const e = variant3.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      if (!(e instanceof UdpSocket)) {
        throw new TypeError('Resource error: Not a valid "UdpSocket" resource.');
      }
      var handle1 = e[symbolRscHandle];
      if (!handle1) {
        const rep = e[symbolRscRep] || ++captureCnt9;
        captureTable9.set(rep, e);
        handle1 = rscTableCreateOwn(handleTable9, rep);
      }
      dataView(memory0).setInt32(arg1 + 4, handle1, true);
      break;
    }
    case 'err': {
      const e = variant3.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val2 = e;
      let enum2;
      switch (val2) {
        case 'unknown': {
          enum2 = 0;
          break;
        }
        case 'access-denied': {
          enum2 = 1;
          break;
        }
        case 'not-supported': {
          enum2 = 2;
          break;
        }
        case 'invalid-argument': {
          enum2 = 3;
          break;
        }
        case 'out-of-memory': {
          enum2 = 4;
          break;
        }
        case 'timeout': {
          enum2 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum2 = 6;
          break;
        }
        case 'not-in-progress': {
          enum2 = 7;
          break;
        }
        case 'would-block': {
          enum2 = 8;
          break;
        }
        case 'invalid-state': {
          enum2 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum2 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum2 = 11;
          break;
        }
        case 'address-in-use': {
          enum2 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum2 = 13;
          break;
        }
        case 'connection-refused': {
          enum2 = 14;
          break;
        }
        case 'connection-reset': {
          enum2 = 15;
          break;
        }
        case 'connection-aborted': {
          enum2 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum2 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum2 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum2 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum2 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val2}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 4, enum2, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/udp-create-socket@0.2.0", function="create-udp-socket"][Instruction::Return]', {
    funcName: 'create-udp-socket',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_130_metadata = {
  qualifiedImportFn: 'wasi:sockets/tcp-create-socket@0.2.0#create-tcp-socket',
  moduleIdx: null,
};


function trampoline151(arg0, arg1) {
  let enum0;
  switch (arg0) {
    case 0: {
      enum0 = 'ipv4';
      break;
    }
    case 1: {
      enum0 = 'ipv6';
      break;
    }
    default: {
      throw new TypeError('invalid discriminant specified for IpAddressFamily');
    }
  }
  _debugLog('[iface="wasi:sockets/tcp-create-socket@0.2.0", function="create-tcp-socket"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = createTcpSocket._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'createTcpSocket',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  createTcpSocket(enum0)};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  endCurrentTask(0);
  var variant3 = ret;
  switch (variant3.tag) {
    case 'ok': {
      const e = variant3.val;
      dataView(memory0).setInt8(arg1 + 0, 0, true);
      if (!(e instanceof TcpSocket)) {
        throw new TypeError('Resource error: Not a valid "TcpSocket" resource.');
      }
      var handle1 = e[symbolRscHandle];
      if (!handle1) {
        const rep = e[symbolRscRep] || ++captureCnt12;
        captureTable12.set(rep, e);
        handle1 = rscTableCreateOwn(handleTable12, rep);
      }
      dataView(memory0).setInt32(arg1 + 4, handle1, true);
      break;
    }
    case 'err': {
      const e = variant3.val;
      dataView(memory0).setInt8(arg1 + 0, 1, true);
      var val2 = e;
      let enum2;
      switch (val2) {
        case 'unknown': {
          enum2 = 0;
          break;
        }
        case 'access-denied': {
          enum2 = 1;
          break;
        }
        case 'not-supported': {
          enum2 = 2;
          break;
        }
        case 'invalid-argument': {
          enum2 = 3;
          break;
        }
        case 'out-of-memory': {
          enum2 = 4;
          break;
        }
        case 'timeout': {
          enum2 = 5;
          break;
        }
        case 'concurrency-conflict': {
          enum2 = 6;
          break;
        }
        case 'not-in-progress': {
          enum2 = 7;
          break;
        }
        case 'would-block': {
          enum2 = 8;
          break;
        }
        case 'invalid-state': {
          enum2 = 9;
          break;
        }
        case 'new-socket-limit': {
          enum2 = 10;
          break;
        }
        case 'address-not-bindable': {
          enum2 = 11;
          break;
        }
        case 'address-in-use': {
          enum2 = 12;
          break;
        }
        case 'remote-unreachable': {
          enum2 = 13;
          break;
        }
        case 'connection-refused': {
          enum2 = 14;
          break;
        }
        case 'connection-reset': {
          enum2 = 15;
          break;
        }
        case 'connection-aborted': {
          enum2 = 16;
          break;
        }
        case 'datagram-too-large': {
          enum2 = 17;
          break;
        }
        case 'name-unresolvable': {
          enum2 = 18;
          break;
        }
        case 'temporary-resolver-failure': {
          enum2 = 19;
          break;
        }
        case 'permanent-resolver-failure': {
          enum2 = 20;
          break;
        }
        default: {
          if ((e) instanceof Error) {
            console.error(e);
          }
          
          throw new TypeError(`"${val2}" is not one of the cases of error-code`);
        }
      }
      dataView(memory0).setInt8(arg1 + 4, enum2, true);
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="wasi:sockets/tcp-create-socket@0.2.0", function="create-tcp-socket"][Instruction::Return]', {
    funcName: 'create-tcp-socket',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_131_metadata = {
  qualifiedImportFn: 'wasi:random/random@0.2.0#get-random-bytes',
  moduleIdx: null,
};


function trampoline152(arg0, arg1) {
  _debugLog('[iface="wasi:random/random@0.2.0", function="get-random-bytes"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = getRandomBytes._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'getRandomBytes',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  getRandomBytes(BigInt.asUintN(64, arg0));
  endCurrentTask(0);
  var val0 = ret;
  var len0 = val0.byteLength;
  var ptr0 = realloc1(0, 0, 1, len0 * 1);
  var src0 = new Uint8Array(val0.buffer || val0, val0.byteOffset, len0 * 1);
  (new Uint8Array(memory0.buffer, ptr0, len0 * 1)).set(src0);
  dataView(memory0).setUint32(arg1 + 4, len0, true);
  dataView(memory0).setUint32(arg1 + 0, ptr0, true);
  _debugLog('[iface="wasi:random/random@0.2.0", function="get-random-bytes"][Instruction::Return]', {
    funcName: 'get-random-bytes',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_132_metadata = {
  qualifiedImportFn: 'wasi:random/insecure@0.2.0#get-insecure-random-bytes',
  moduleIdx: null,
};


function trampoline153(arg0, arg1) {
  _debugLog('[iface="wasi:random/insecure@0.2.0", function="get-insecure-random-bytes"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = getInsecureRandomBytes._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'getInsecureRandomBytes',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  getInsecureRandomBytes(BigInt.asUintN(64, arg0));
  endCurrentTask(0);
  var val0 = ret;
  var len0 = val0.byteLength;
  var ptr0 = realloc1(0, 0, 1, len0 * 1);
  var src0 = new Uint8Array(val0.buffer || val0, val0.byteOffset, len0 * 1);
  (new Uint8Array(memory0.buffer, ptr0, len0 * 1)).set(src0);
  dataView(memory0).setUint32(arg1 + 4, len0, true);
  dataView(memory0).setUint32(arg1 + 0, ptr0, true);
  _debugLog('[iface="wasi:random/insecure@0.2.0", function="get-insecure-random-bytes"][Instruction::Return]', {
    funcName: 'get-insecure-random-bytes',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_133_metadata = {
  qualifiedImportFn: 'wasi:random/insecure-seed@0.2.0#insecure-seed',
  moduleIdx: null,
};


function trampoline154(arg0) {
  _debugLog('[iface="wasi:random/insecure-seed@0.2.0", function="insecure-seed"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = insecureSeed._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'insecureSeed',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  insecureSeed();
  endCurrentTask(0);
  var [tuple0_0, tuple0_1] = ret;
  dataView(memory0).setBigInt64(arg0 + 0, toUint64(tuple0_0), true);
  dataView(memory0).setBigInt64(arg0 + 8, toUint64(tuple0_1), true);
  _debugLog('[iface="wasi:random/insecure-seed@0.2.0", function="insecure-seed"][Instruction::Return]', {
    funcName: 'insecure-seed',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_134_metadata = {
  qualifiedImportFn: 'eryx:net/tcp@0.1.0#connect',
  moduleIdx: null,
};


function trampoline155(arg0, arg1, arg2, arg3) {
  var ptr0 = arg0;
  var len0 = arg1;
  var result0 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr0, len0));
  _debugLog('[iface="eryx:net/tcp@0.1.0", function="connect"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = connect._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'connect',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  connect(result0, clampGuest(arg2, 0, 65535))};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  endCurrentTask(0);
  var variant4 = ret;
  switch (variant4.tag) {
    case 'ok': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg3 + 0, 0, true);
      dataView(memory0).setInt32(arg3 + 4, toUint32(e), true);
      break;
    }
    case 'err': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg3 + 0, 1, true);
      var variant3 = e;
      switch (variant3.tag) {
        case 'connection-refused': {
          dataView(memory0).setInt8(arg3 + 4, 0, true);
          break;
        }
        case 'connection-reset': {
          dataView(memory0).setInt8(arg3 + 4, 1, true);
          break;
        }
        case 'timed-out': {
          dataView(memory0).setInt8(arg3 + 4, 2, true);
          break;
        }
        case 'host-not-found': {
          dataView(memory0).setInt8(arg3 + 4, 3, true);
          break;
        }
        case 'io-error': {
          const e = variant3.val;
          dataView(memory0).setInt8(arg3 + 4, 4, true);
          
          var encodeRes = _utf8AllocateAndEncode(e, realloc2, memory0);
          var ptr1= encodeRes.ptr;
          var len1 = encodeRes.len;
          
          dataView(memory0).setUint32(arg3 + 12, len1, true);
          dataView(memory0).setUint32(arg3 + 8, ptr1, true);
          break;
        }
        case 'not-permitted': {
          const e = variant3.val;
          dataView(memory0).setInt8(arg3 + 4, 5, true);
          
          var encodeRes = _utf8AllocateAndEncode(e, realloc2, memory0);
          var ptr2= encodeRes.ptr;
          var len2 = encodeRes.len;
          
          dataView(memory0).setUint32(arg3 + 12, len2, true);
          dataView(memory0).setUint32(arg3 + 8, ptr2, true);
          break;
        }
        case 'invalid-handle': {
          dataView(memory0).setInt8(arg3 + 4, 6, true);
          break;
        }
        default: {
          throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant3.tag)}\` (received \`${variant3}\`) specified for \`TcpError\``);
        }
      }
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="eryx:net/tcp@0.1.0", function="connect"][Instruction::Return]', {
    funcName: 'connect',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_135_metadata = {
  qualifiedImportFn: 'eryx:net/tcp@0.1.0#read',
  moduleIdx: null,
};


function trampoline156(arg0, arg1, arg2) {
  _debugLog('[iface="eryx:net/tcp@0.1.0", function="read"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = read._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'read',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  read(arg0 >>> 0, arg1 >>> 0)};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  endCurrentTask(0);
  var variant4 = ret;
  switch (variant4.tag) {
    case 'ok': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg2 + 0, 0, true);
      var val0 = e;
      var len0 = val0.byteLength;
      var ptr0 = realloc2(0, 0, 1, len0 * 1);
      var src0 = new Uint8Array(val0.buffer || val0, val0.byteOffset, len0 * 1);
      (new Uint8Array(memory0.buffer, ptr0, len0 * 1)).set(src0);
      dataView(memory0).setUint32(arg2 + 8, len0, true);
      dataView(memory0).setUint32(arg2 + 4, ptr0, true);
      break;
    }
    case 'err': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg2 + 0, 1, true);
      var variant3 = e;
      switch (variant3.tag) {
        case 'connection-refused': {
          dataView(memory0).setInt8(arg2 + 4, 0, true);
          break;
        }
        case 'connection-reset': {
          dataView(memory0).setInt8(arg2 + 4, 1, true);
          break;
        }
        case 'timed-out': {
          dataView(memory0).setInt8(arg2 + 4, 2, true);
          break;
        }
        case 'host-not-found': {
          dataView(memory0).setInt8(arg2 + 4, 3, true);
          break;
        }
        case 'io-error': {
          const e = variant3.val;
          dataView(memory0).setInt8(arg2 + 4, 4, true);
          
          var encodeRes = _utf8AllocateAndEncode(e, realloc2, memory0);
          var ptr1= encodeRes.ptr;
          var len1 = encodeRes.len;
          
          dataView(memory0).setUint32(arg2 + 12, len1, true);
          dataView(memory0).setUint32(arg2 + 8, ptr1, true);
          break;
        }
        case 'not-permitted': {
          const e = variant3.val;
          dataView(memory0).setInt8(arg2 + 4, 5, true);
          
          var encodeRes = _utf8AllocateAndEncode(e, realloc2, memory0);
          var ptr2= encodeRes.ptr;
          var len2 = encodeRes.len;
          
          dataView(memory0).setUint32(arg2 + 12, len2, true);
          dataView(memory0).setUint32(arg2 + 8, ptr2, true);
          break;
        }
        case 'invalid-handle': {
          dataView(memory0).setInt8(arg2 + 4, 6, true);
          break;
        }
        default: {
          throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant3.tag)}\` (received \`${variant3}\`) specified for \`TcpError\``);
        }
      }
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="eryx:net/tcp@0.1.0", function="read"][Instruction::Return]', {
    funcName: 'read',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_136_metadata = {
  qualifiedImportFn: 'eryx:net/tcp@0.1.0#write',
  moduleIdx: null,
};


function trampoline157(arg0, arg1, arg2, arg3) {
  var ptr0 = arg1;
  var len0 = arg2;
  var result0 = new Uint8Array(memory0.buffer.slice(ptr0, ptr0 + len0 * 1));
  _debugLog('[iface="eryx:net/tcp@0.1.0", function="write"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = write._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'write',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  write(arg0 >>> 0, result0)};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  endCurrentTask(0);
  var variant4 = ret;
  switch (variant4.tag) {
    case 'ok': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg3 + 0, 0, true);
      dataView(memory0).setInt32(arg3 + 4, toUint32(e), true);
      break;
    }
    case 'err': {
      const e = variant4.val;
      dataView(memory0).setInt8(arg3 + 0, 1, true);
      var variant3 = e;
      switch (variant3.tag) {
        case 'connection-refused': {
          dataView(memory0).setInt8(arg3 + 4, 0, true);
          break;
        }
        case 'connection-reset': {
          dataView(memory0).setInt8(arg3 + 4, 1, true);
          break;
        }
        case 'timed-out': {
          dataView(memory0).setInt8(arg3 + 4, 2, true);
          break;
        }
        case 'host-not-found': {
          dataView(memory0).setInt8(arg3 + 4, 3, true);
          break;
        }
        case 'io-error': {
          const e = variant3.val;
          dataView(memory0).setInt8(arg3 + 4, 4, true);
          
          var encodeRes = _utf8AllocateAndEncode(e, realloc2, memory0);
          var ptr1= encodeRes.ptr;
          var len1 = encodeRes.len;
          
          dataView(memory0).setUint32(arg3 + 12, len1, true);
          dataView(memory0).setUint32(arg3 + 8, ptr1, true);
          break;
        }
        case 'not-permitted': {
          const e = variant3.val;
          dataView(memory0).setInt8(arg3 + 4, 5, true);
          
          var encodeRes = _utf8AllocateAndEncode(e, realloc2, memory0);
          var ptr2= encodeRes.ptr;
          var len2 = encodeRes.len;
          
          dataView(memory0).setUint32(arg3 + 12, len2, true);
          dataView(memory0).setUint32(arg3 + 8, ptr2, true);
          break;
        }
        case 'invalid-handle': {
          dataView(memory0).setInt8(arg3 + 4, 6, true);
          break;
        }
        default: {
          throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant3.tag)}\` (received \`${variant3}\`) specified for \`TcpError\``);
        }
      }
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="eryx:net/tcp@0.1.0", function="write"][Instruction::Return]', {
    funcName: 'write',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_137_metadata = {
  qualifiedImportFn: 'eryx:net/tls@0.1.0#upgrade',
  moduleIdx: null,
};


function trampoline158(arg0, arg1, arg2, arg3) {
  var ptr0 = arg1;
  var len0 = arg2;
  var result0 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr0, len0));
  _debugLog('[iface="eryx:net/tls@0.1.0", function="upgrade"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = upgrade._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'upgrade',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  upgrade(arg0 >>> 0, result0)};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  endCurrentTask(0);
  var variant7 = ret;
  switch (variant7.tag) {
    case 'ok': {
      const e = variant7.val;
      dataView(memory0).setInt8(arg3 + 0, 0, true);
      dataView(memory0).setInt32(arg3 + 4, toUint32(e), true);
      break;
    }
    case 'err': {
      const e = variant7.val;
      dataView(memory0).setInt8(arg3 + 0, 1, true);
      var variant6 = e;
      switch (variant6.tag) {
        case 'tcp': {
          const e = variant6.val;
          dataView(memory0).setInt8(arg3 + 4, 0, true);
          var variant3 = e;
          switch (variant3.tag) {
            case 'connection-refused': {
              dataView(memory0).setInt8(arg3 + 8, 0, true);
              break;
            }
            case 'connection-reset': {
              dataView(memory0).setInt8(arg3 + 8, 1, true);
              break;
            }
            case 'timed-out': {
              dataView(memory0).setInt8(arg3 + 8, 2, true);
              break;
            }
            case 'host-not-found': {
              dataView(memory0).setInt8(arg3 + 8, 3, true);
              break;
            }
            case 'io-error': {
              const e = variant3.val;
              dataView(memory0).setInt8(arg3 + 8, 4, true);
              
              var encodeRes = _utf8AllocateAndEncode(e, realloc2, memory0);
              var ptr1= encodeRes.ptr;
              var len1 = encodeRes.len;
              
              dataView(memory0).setUint32(arg3 + 16, len1, true);
              dataView(memory0).setUint32(arg3 + 12, ptr1, true);
              break;
            }
            case 'not-permitted': {
              const e = variant3.val;
              dataView(memory0).setInt8(arg3 + 8, 5, true);
              
              var encodeRes = _utf8AllocateAndEncode(e, realloc2, memory0);
              var ptr2= encodeRes.ptr;
              var len2 = encodeRes.len;
              
              dataView(memory0).setUint32(arg3 + 16, len2, true);
              dataView(memory0).setUint32(arg3 + 12, ptr2, true);
              break;
            }
            case 'invalid-handle': {
              dataView(memory0).setInt8(arg3 + 8, 6, true);
              break;
            }
            default: {
              throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant3.tag)}\` (received \`${variant3}\`) specified for \`TcpError\``);
            }
          }
          break;
        }
        case 'handshake-failed': {
          const e = variant6.val;
          dataView(memory0).setInt8(arg3 + 4, 1, true);
          
          var encodeRes = _utf8AllocateAndEncode(e, realloc2, memory0);
          var ptr4= encodeRes.ptr;
          var len4 = encodeRes.len;
          
          dataView(memory0).setUint32(arg3 + 12, len4, true);
          dataView(memory0).setUint32(arg3 + 8, ptr4, true);
          break;
        }
        case 'certificate-error': {
          const e = variant6.val;
          dataView(memory0).setInt8(arg3 + 4, 2, true);
          
          var encodeRes = _utf8AllocateAndEncode(e, realloc2, memory0);
          var ptr5= encodeRes.ptr;
          var len5 = encodeRes.len;
          
          dataView(memory0).setUint32(arg3 + 12, len5, true);
          dataView(memory0).setUint32(arg3 + 8, ptr5, true);
          break;
        }
        case 'invalid-handle': {
          dataView(memory0).setInt8(arg3 + 4, 3, true);
          break;
        }
        default: {
          throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant6.tag)}\` (received \`${variant6}\`) specified for \`TlsError\``);
        }
      }
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="eryx:net/tls@0.1.0", function="upgrade"][Instruction::Return]', {
    funcName: 'upgrade',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_138_metadata = {
  qualifiedImportFn: 'eryx:net/tls@0.1.0#read',
  moduleIdx: null,
};


function trampoline159(arg0, arg1, arg2) {
  _debugLog('[iface="eryx:net/tls@0.1.0", function="read"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = read$1._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'read$1',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  read$1(arg0 >>> 0, arg1 >>> 0)};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  endCurrentTask(0);
  var variant7 = ret;
  switch (variant7.tag) {
    case 'ok': {
      const e = variant7.val;
      dataView(memory0).setInt8(arg2 + 0, 0, true);
      var val0 = e;
      var len0 = val0.byteLength;
      var ptr0 = realloc2(0, 0, 1, len0 * 1);
      var src0 = new Uint8Array(val0.buffer || val0, val0.byteOffset, len0 * 1);
      (new Uint8Array(memory0.buffer, ptr0, len0 * 1)).set(src0);
      dataView(memory0).setUint32(arg2 + 8, len0, true);
      dataView(memory0).setUint32(arg2 + 4, ptr0, true);
      break;
    }
    case 'err': {
      const e = variant7.val;
      dataView(memory0).setInt8(arg2 + 0, 1, true);
      var variant6 = e;
      switch (variant6.tag) {
        case 'tcp': {
          const e = variant6.val;
          dataView(memory0).setInt8(arg2 + 4, 0, true);
          var variant3 = e;
          switch (variant3.tag) {
            case 'connection-refused': {
              dataView(memory0).setInt8(arg2 + 8, 0, true);
              break;
            }
            case 'connection-reset': {
              dataView(memory0).setInt8(arg2 + 8, 1, true);
              break;
            }
            case 'timed-out': {
              dataView(memory0).setInt8(arg2 + 8, 2, true);
              break;
            }
            case 'host-not-found': {
              dataView(memory0).setInt8(arg2 + 8, 3, true);
              break;
            }
            case 'io-error': {
              const e = variant3.val;
              dataView(memory0).setInt8(arg2 + 8, 4, true);
              
              var encodeRes = _utf8AllocateAndEncode(e, realloc2, memory0);
              var ptr1= encodeRes.ptr;
              var len1 = encodeRes.len;
              
              dataView(memory0).setUint32(arg2 + 16, len1, true);
              dataView(memory0).setUint32(arg2 + 12, ptr1, true);
              break;
            }
            case 'not-permitted': {
              const e = variant3.val;
              dataView(memory0).setInt8(arg2 + 8, 5, true);
              
              var encodeRes = _utf8AllocateAndEncode(e, realloc2, memory0);
              var ptr2= encodeRes.ptr;
              var len2 = encodeRes.len;
              
              dataView(memory0).setUint32(arg2 + 16, len2, true);
              dataView(memory0).setUint32(arg2 + 12, ptr2, true);
              break;
            }
            case 'invalid-handle': {
              dataView(memory0).setInt8(arg2 + 8, 6, true);
              break;
            }
            default: {
              throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant3.tag)}\` (received \`${variant3}\`) specified for \`TcpError\``);
            }
          }
          break;
        }
        case 'handshake-failed': {
          const e = variant6.val;
          dataView(memory0).setInt8(arg2 + 4, 1, true);
          
          var encodeRes = _utf8AllocateAndEncode(e, realloc2, memory0);
          var ptr4= encodeRes.ptr;
          var len4 = encodeRes.len;
          
          dataView(memory0).setUint32(arg2 + 12, len4, true);
          dataView(memory0).setUint32(arg2 + 8, ptr4, true);
          break;
        }
        case 'certificate-error': {
          const e = variant6.val;
          dataView(memory0).setInt8(arg2 + 4, 2, true);
          
          var encodeRes = _utf8AllocateAndEncode(e, realloc2, memory0);
          var ptr5= encodeRes.ptr;
          var len5 = encodeRes.len;
          
          dataView(memory0).setUint32(arg2 + 12, len5, true);
          dataView(memory0).setUint32(arg2 + 8, ptr5, true);
          break;
        }
        case 'invalid-handle': {
          dataView(memory0).setInt8(arg2 + 4, 3, true);
          break;
        }
        default: {
          throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant6.tag)}\` (received \`${variant6}\`) specified for \`TlsError\``);
        }
      }
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="eryx:net/tls@0.1.0", function="read"][Instruction::Return]', {
    funcName: 'read',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_139_metadata = {
  qualifiedImportFn: 'eryx:net/tls@0.1.0#write',
  moduleIdx: null,
};


function trampoline160(arg0, arg1, arg2, arg3) {
  var ptr0 = arg1;
  var len0 = arg2;
  var result0 = new Uint8Array(memory0.buffer.slice(ptr0, ptr0 + len0 * 1));
  _debugLog('[iface="eryx:net/tls@0.1.0", function="write"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = write$1._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'write$1',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val:  write$1(arg0 >>> 0, result0)};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  endCurrentTask(0);
  var variant7 = ret;
  switch (variant7.tag) {
    case 'ok': {
      const e = variant7.val;
      dataView(memory0).setInt8(arg3 + 0, 0, true);
      dataView(memory0).setInt32(arg3 + 4, toUint32(e), true);
      break;
    }
    case 'err': {
      const e = variant7.val;
      dataView(memory0).setInt8(arg3 + 0, 1, true);
      var variant6 = e;
      switch (variant6.tag) {
        case 'tcp': {
          const e = variant6.val;
          dataView(memory0).setInt8(arg3 + 4, 0, true);
          var variant3 = e;
          switch (variant3.tag) {
            case 'connection-refused': {
              dataView(memory0).setInt8(arg3 + 8, 0, true);
              break;
            }
            case 'connection-reset': {
              dataView(memory0).setInt8(arg3 + 8, 1, true);
              break;
            }
            case 'timed-out': {
              dataView(memory0).setInt8(arg3 + 8, 2, true);
              break;
            }
            case 'host-not-found': {
              dataView(memory0).setInt8(arg3 + 8, 3, true);
              break;
            }
            case 'io-error': {
              const e = variant3.val;
              dataView(memory0).setInt8(arg3 + 8, 4, true);
              
              var encodeRes = _utf8AllocateAndEncode(e, realloc2, memory0);
              var ptr1= encodeRes.ptr;
              var len1 = encodeRes.len;
              
              dataView(memory0).setUint32(arg3 + 16, len1, true);
              dataView(memory0).setUint32(arg3 + 12, ptr1, true);
              break;
            }
            case 'not-permitted': {
              const e = variant3.val;
              dataView(memory0).setInt8(arg3 + 8, 5, true);
              
              var encodeRes = _utf8AllocateAndEncode(e, realloc2, memory0);
              var ptr2= encodeRes.ptr;
              var len2 = encodeRes.len;
              
              dataView(memory0).setUint32(arg3 + 16, len2, true);
              dataView(memory0).setUint32(arg3 + 12, ptr2, true);
              break;
            }
            case 'invalid-handle': {
              dataView(memory0).setInt8(arg3 + 8, 6, true);
              break;
            }
            default: {
              throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant3.tag)}\` (received \`${variant3}\`) specified for \`TcpError\``);
            }
          }
          break;
        }
        case 'handshake-failed': {
          const e = variant6.val;
          dataView(memory0).setInt8(arg3 + 4, 1, true);
          
          var encodeRes = _utf8AllocateAndEncode(e, realloc2, memory0);
          var ptr4= encodeRes.ptr;
          var len4 = encodeRes.len;
          
          dataView(memory0).setUint32(arg3 + 12, len4, true);
          dataView(memory0).setUint32(arg3 + 8, ptr4, true);
          break;
        }
        case 'certificate-error': {
          const e = variant6.val;
          dataView(memory0).setInt8(arg3 + 4, 2, true);
          
          var encodeRes = _utf8AllocateAndEncode(e, realloc2, memory0);
          var ptr5= encodeRes.ptr;
          var len5 = encodeRes.len;
          
          dataView(memory0).setUint32(arg3 + 12, len5, true);
          dataView(memory0).setUint32(arg3 + 8, ptr5, true);
          break;
        }
        case 'invalid-handle': {
          dataView(memory0).setInt8(arg3 + 4, 3, true);
          break;
        }
        default: {
          throw new TypeError(`invalid variant tag value \`${JSON.stringify(variant6.tag)}\` (received \`${variant6}\`) specified for \`TlsError\``);
        }
      }
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="eryx:net/tls@0.1.0", function="write"][Instruction::Return]', {
    funcName: 'write',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_140_metadata = {
  qualifiedImportFn: '$root#invoke',
  moduleIdx: null,
};


const trampoline161 = new WebAssembly.Suspending(async function(arg0, arg1, arg2, arg3, arg4) {
  var ptr0 = arg0;
  var len0 = arg1;
  var result0 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr0, len0));
  var ptr1 = arg2;
  var len1 = arg3;
  var result1 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr1, len1));
  _debugLog('[iface="invoke", function="invoke"] [Instruction::CallInterface] (async, @ enter)');
  const hostProvided = invoke._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: true,
      entryFnName: 'invoke',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'result-catch-handler',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && true;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  
  const started = await task.enter();
  if (!started) {
    _debugLog('[Instruction::CallInterface] failed to enter task', {
      taskID: preparedTask.id(),
      subtaskID: currentSubtask?.id(),
    });
    throw new Error("failed to enter task");
  }
  
  
  let ret;
  try {
    ret = { tag: 'ok', val: await  invoke(result0, result1)};
  } catch (e) {
    ret = { tag: 'err', val: getErrorPayload(e) };
  }
  
  var variant4 = ret;
  let variant4_0;
  let variant4_1;
  let variant4_2;
  switch (variant4.tag) {
    case 'ok': {
      const e = variant4.val;
      
      var encodeRes = _utf8AllocateAndEncode(e, realloc2, memory0);
      var ptr2= encodeRes.ptr;
      var len2 = encodeRes.len;
      
      variant4_0 = 0;
      variant4_1 = ptr2;
      variant4_2 = len2;
      break;
    }
    case 'err': {
      const e = variant4.val;
      
      var encodeRes = _utf8AllocateAndEncode(e, realloc2, memory0);
      var ptr3= encodeRes.ptr;
      var len3 = encodeRes.len;
      
      variant4_0 = 1;
      variant4_1 = ptr3;
      variant4_2 = len3;
      break;
    }
    default: {
      throw new TypeError('invalid variant specified for result');
    }
  }
  _debugLog('[iface="invoke", function="invoke"][Instruction::AsyncTaskReturn]', {
    funcName: '[task-return]invoke',
    paramCount: 3,
    postReturn: false,
    hostProvided,
  });
  
  if (hostProvided) {
    _debugLog('[Instruction::AsyncTaskReturn] signaling host-provided async return completion', {
      task: task.id(),
      subtask: subtask?.id(),
      result: ret,
    })
    task.resolve([ret]);
    endCurrentTask(0, task.id());
    return task.completionPromise();
  }
  
  const currentSubtask = task.getLatestSubtask();
  if (currentSubtask && currentSubtask.isNotStarted()) {
    _debugLog('[Instruction::AsyncTaskReturn] subtask not started at end of task run, starting it', {
      task: task.id(),
      subtask: currentSubtask?.id(),
      result: ret,
    })
    currentSubtask.onStart();
  }
  
  const componentState = getOrCreateAsyncState(0);
  if (!componentState) { throw new Error('failed to lookup current component state'); }
  
  new Promise(async (resolve, reject) => {
    try {
      _debugLog("[Instruction::AsyncTaskReturn] starting driver loop", { fnName: '[task-return]invoke' });
      await _driverLoop({
        componentInstanceIdx: 0,
        componentState,
        task,
        fnName: '[task-return]invoke',
        isAsync: true,
        callbackResult: ret,
        resolve,
        reject
      });
    } catch (err) {
      _debugLog("[Instruction::AsyncTaskReturn] driver loop call failure", { err });
    }
  });
  
  let taskRes = await task.completionPromise();
  if (task.getErrHandling() === 'throw-result-err') {
    if (typeof taskRes !== 'object') { return taskRes; }
    if (taskRes.tag === 'err') { throw taskRes.val; }
    if (taskRes.tag === 'ok') { taskRes = taskRes.val; }
  }
  
  return taskRes;
  
}
);

let lowered_import_141_metadata = {
  qualifiedImportFn: '$root#list-callbacks',
  moduleIdx: null,
};


function trampoline162(arg0) {
  _debugLog('[iface="list-callbacks", function="list-callbacks"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = listCallbacks._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'listCallbacks',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret =  listCallbacks();
  endCurrentTask(0);
  var vec4 = ret;
  var len4 = vec4.length;
  var result4 = realloc2(0, 0, 4, len4 * 24);
  for (let i = 0; i < vec4.length; i++) {
    const e = vec4[i];
    const base = result4 + i * 24;var {name: v0_0, description: v0_1, parametersSchemaJson: v0_2 } = e;
    
    var encodeRes = _utf8AllocateAndEncode(v0_0, realloc2, memory0);
    var ptr1= encodeRes.ptr;
    var len1 = encodeRes.len;
    
    dataView(memory0).setUint32(base + 4, len1, true);
    dataView(memory0).setUint32(base + 0, ptr1, true);
    
    var encodeRes = _utf8AllocateAndEncode(v0_1, realloc2, memory0);
    var ptr2= encodeRes.ptr;
    var len2 = encodeRes.len;
    
    dataView(memory0).setUint32(base + 12, len2, true);
    dataView(memory0).setUint32(base + 8, ptr2, true);
    
    var encodeRes = _utf8AllocateAndEncode(v0_2, realloc2, memory0);
    var ptr3= encodeRes.ptr;
    var len3 = encodeRes.len;
    
    dataView(memory0).setUint32(base + 20, len3, true);
    dataView(memory0).setUint32(base + 16, ptr3, true);
  }
  dataView(memory0).setUint32(arg0 + 4, len4, true);
  dataView(memory0).setUint32(arg0 + 0, result4, true);
  _debugLog('[iface="list-callbacks", function="list-callbacks"][Instruction::Return]', {
    funcName: 'list-callbacks',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}


let lowered_import_142_metadata = {
  qualifiedImportFn: '$root#report-trace',
  moduleIdx: null,
};


function trampoline163(arg0, arg1, arg2, arg3, arg4) {
  var ptr0 = arg1;
  var len0 = arg2;
  var result0 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr0, len0));
  var ptr1 = arg3;
  var len1 = arg4;
  var result1 = TEXT_DECODER_UTF8.decode(new Uint8Array(memory0.buffer, ptr1, len1));
  _debugLog('[iface="report-trace", function="report-trace"] [Instruction::CallInterface] (sync, @ enter)');
  const hostProvided = reportTrace._isHostProvided;
  
  let parentTask;
  let task;
  let subtask;
  
  const createTask = () => {
    const results = createNewCurrentTask({
      componentIdx: 0,
      isAsync: false,
      entryFnName: 'reportTrace',
      getCallbackFn: () => null,
      callbackFnName: 'null',
      errHandling: 'none',
      callingWasmExport: false,
    });
    task = results[0];
  };
  
  taskCreation: {
    parentTask = getCurrentTask(0)?.task;
    if (!parentTask) {
      createTask();
      break taskCreation;
    }
    
    createTask();
    
    const isHostAsyncImport = hostProvided && false;
    if (isHostAsyncImport) {
      subtask = parentTask.getLatestSubtask();
      if (!subtask) {
        throw new Error("Missing subtask for host import, has the import been lowered? (ensure asyncImports are set properly)");
      }
      subtask.setChildTask(task);
      task.setParentSubtask(subtask);
    }
  }
  
  let ret; reportTrace(arg0 >>> 0, result0, result1);
  endCurrentTask(0);
  _debugLog('[iface="report-trace", function="report-trace"][Instruction::Return]', {
    funcName: 'report-trace',
    paramCount: 0,
    async: false,
    postReturn: false
  });
}

let exports12;
let exports13;
let callback_0;
let callback_1;
let callback_2;
let callback_3;
let postReturn0;

GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_0_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_0_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 0,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [],
    metadata: lowered_import_0_metadata,
    resultLowerFns: [_lowerFlatU64],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: null,
    getMemoryFn: () => null,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_1_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_1_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 1,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [],
    metadata: lowered_import_1_metadata,
    resultLowerFns: [_lowerFlatU64],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: null,
    getMemoryFn: () => null,
    getReallocFn: () => null,
  },
  ),
});

function trampoline2(handle) {
  const handleEntry = rscTableRemove(handleTable7, handle);
  if (handleEntry.own) {
    
    const rsc = captureTable7.get(handleEntry.rep);
    if (rsc) {
      if (rsc[symbolDispose]) rsc[symbolDispose]();
      captureTable7.delete(handleEntry.rep);
    } else if (DirectoryEntryStream[symbolCabiDispose]) {
      DirectoryEntryStream[symbolCabiDispose](handleEntry.rep);
    }
  }
}
function trampoline3(handle) {
  const handleEntry = rscTableRemove(handleTable0, handle);
  if (handleEntry.own) {
    
    const rsc = captureTable0.get(handleEntry.rep);
    if (rsc) {
      if (rsc[symbolDispose]) rsc[symbolDispose]();
      captureTable0.delete(handleEntry.rep);
    } else if (Error$1[symbolCabiDispose]) {
      Error$1[symbolCabiDispose](handleEntry.rep);
    }
  }
}
function trampoline4(handle) {
  const handleEntry = rscTableRemove(handleTable2, handle);
  if (handleEntry.own) {
    
    const rsc = captureTable2.get(handleEntry.rep);
    if (rsc) {
      if (rsc[symbolDispose]) rsc[symbolDispose]();
      captureTable2.delete(handleEntry.rep);
    } else if (InputStream[symbolCabiDispose]) {
      InputStream[symbolCabiDispose](handleEntry.rep);
    }
  }
}
function trampoline5(handle) {
  const handleEntry = rscTableRemove(handleTable3, handle);
  if (handleEntry.own) {
    
    const rsc = captureTable3.get(handleEntry.rep);
    if (rsc) {
      if (rsc[symbolDispose]) rsc[symbolDispose]();
      captureTable3.delete(handleEntry.rep);
    } else if (OutputStream[symbolCabiDispose]) {
      OutputStream[symbolCabiDispose](handleEntry.rep);
    }
  }
}
function trampoline6(handle) {
  const handleEntry = rscTableRemove(handleTable6, handle);
  if (handleEntry.own) {
    
    const rsc = captureTable6.get(handleEntry.rep);
    if (rsc) {
      if (rsc[symbolDispose]) rsc[symbolDispose]();
      captureTable6.delete(handleEntry.rep);
    } else if (Descriptor[symbolCabiDispose]) {
      Descriptor[symbolCabiDispose](handleEntry.rep);
    }
  }
}

GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_2_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_2_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 7,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatU64],
    metadata: lowered_import_2_metadata,
    resultLowerFns: [_lowerFlatOwn.bind(null, 1)],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: null,
    getMemoryFn: () => null,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_3_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_3_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 8,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatU64],
    metadata: lowered_import_3_metadata,
    resultLowerFns: [_lowerFlatOwn.bind(null, 1)],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: null,
    getMemoryFn: () => null,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_4_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_4_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 9,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 3)],
    metadata: lowered_import_4_metadata,
    resultLowerFns: [_lowerFlatOwn.bind(null, 1)],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: null,
    getMemoryFn: () => null,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_5_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_5_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 10,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 2)],
    metadata: lowered_import_5_metadata,
    resultLowerFns: [_lowerFlatOwn.bind(null, 1)],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: null,
    getMemoryFn: () => null,
    getReallocFn: () => null,
  },
  ),
});

function trampoline11(handle) {
  const handleEntry = rscTableRemove(handleTable1, handle);
  if (handleEntry.own) {
    
    const rsc = captureTable1.get(handleEntry.rep);
    if (rsc) {
      if (rsc[symbolDispose]) rsc[symbolDispose]();
      captureTable1.delete(handleEntry.rep);
    } else if (Pollable[symbolCabiDispose]) {
      Pollable[symbolCabiDispose](handleEntry.rep);
    }
  }
}
function trampoline12(handle) {
  const handleEntry = rscTableRemove(handleTable5, handle);
  if (handleEntry.own) {
    
    const rsc = captureTable5.get(handleEntry.rep);
    if (rsc) {
      if (rsc[symbolDispose]) rsc[symbolDispose]();
      captureTable5.delete(handleEntry.rep);
    } else if (TerminalOutput[symbolCabiDispose]) {
      TerminalOutput[symbolCabiDispose](handleEntry.rep);
    }
  }
}
function trampoline13(handle) {
  const handleEntry = rscTableRemove(handleTable4, handle);
  if (handleEntry.own) {
    
    const rsc = captureTable4.get(handleEntry.rep);
    if (rsc) {
      if (rsc[symbolDispose]) rsc[symbolDispose]();
      captureTable4.delete(handleEntry.rep);
    } else if (TerminalInput[symbolCabiDispose]) {
      TerminalInput[symbolCabiDispose](handleEntry.rep);
    }
  }
}

GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_6_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_6_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 14,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [],
    metadata: lowered_import_6_metadata,
    resultLowerFns: [_lowerFlatOwn.bind(null, 3)],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: null,
    getMemoryFn: () => null,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_7_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_7_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 15,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatResult([['ok', null, null],['error', null, null],])],
    metadata: lowered_import_7_metadata,
    resultLowerFns: [],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: null,
    getMemoryFn: () => null,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_8_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_8_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 16,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [],
    metadata: lowered_import_8_metadata,
    resultLowerFns: [_lowerFlatOwn.bind(null, 2)],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: null,
    getMemoryFn: () => null,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_9_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_9_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 17,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [],
    metadata: lowered_import_9_metadata,
    resultLowerFns: [_lowerFlatOwn.bind(null, 3)],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: null,
    getMemoryFn: () => null,
    getReallocFn: () => null,
  },
  ),
});

function trampoline18(handle) {
  const handleEntry = rscTableRemove(handleTable8, handle);
  if (handleEntry.own) {
    
    const rsc = captureTable8.get(handleEntry.rep);
    if (rsc) {
      if (rsc[symbolDispose]) rsc[symbolDispose]();
      captureTable8.delete(handleEntry.rep);
    } else if (Network[symbolCabiDispose]) {
      Network[symbolCabiDispose](handleEntry.rep);
    }
  }
}
function trampoline19(handle) {
  const handleEntry = rscTableRemove(handleTable9, handle);
  if (handleEntry.own) {
    
    const rsc = captureTable9.get(handleEntry.rep);
    if (rsc) {
      if (rsc[symbolDispose]) rsc[symbolDispose]();
      captureTable9.delete(handleEntry.rep);
    } else if (UdpSocket[symbolCabiDispose]) {
      UdpSocket[symbolCabiDispose](handleEntry.rep);
    }
  }
}
function trampoline20(handle) {
  const handleEntry = rscTableRemove(handleTable10, handle);
  if (handleEntry.own) {
    
    const rsc = captureTable10.get(handleEntry.rep);
    if (rsc) {
      if (rsc[symbolDispose]) rsc[symbolDispose]();
      captureTable10.delete(handleEntry.rep);
    } else if (IncomingDatagramStream[symbolCabiDispose]) {
      IncomingDatagramStream[symbolCabiDispose](handleEntry.rep);
    }
  }
}
function trampoline21(handle) {
  const handleEntry = rscTableRemove(handleTable11, handle);
  if (handleEntry.own) {
    
    const rsc = captureTable11.get(handleEntry.rep);
    if (rsc) {
      if (rsc[symbolDispose]) rsc[symbolDispose]();
      captureTable11.delete(handleEntry.rep);
    } else if (OutgoingDatagramStream[symbolCabiDispose]) {
      OutgoingDatagramStream[symbolCabiDispose](handleEntry.rep);
    }
  }
}
function trampoline22(handle) {
  const handleEntry = rscTableRemove(handleTable12, handle);
  if (handleEntry.own) {
    
    const rsc = captureTable12.get(handleEntry.rep);
    if (rsc) {
      if (rsc[symbolDispose]) rsc[symbolDispose]();
      captureTable12.delete(handleEntry.rep);
    } else if (TcpSocket[symbolCabiDispose]) {
      TcpSocket[symbolCabiDispose](handleEntry.rep);
    }
  }
}
function trampoline23(handle) {
  const handleEntry = rscTableRemove(handleTable13, handle);
  if (handleEntry.own) {
    
    const rsc = captureTable13.get(handleEntry.rep);
    if (rsc) {
      if (rsc[symbolDispose]) rsc[symbolDispose]();
      captureTable13.delete(handleEntry.rep);
    } else if (ResolveAddressStream[symbolCabiDispose]) {
      ResolveAddressStream[symbolCabiDispose](handleEntry.rep);
    }
  }
}

GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_10_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_10_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 24,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 1)],
    metadata: lowered_import_10_metadata,
    resultLowerFns: [_lowerFlatBool],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: null,
    getMemoryFn: () => null,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_11_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_11_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 25,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 1)],
    metadata: lowered_import_11_metadata,
    resultLowerFns: [],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: null,
    getMemoryFn: () => null,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_12_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_12_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 26,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 6),_liftFlatOwn.bind(null, 6)],
    metadata: lowered_import_12_metadata,
    resultLowerFns: [_lowerFlatBool],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: null,
    getMemoryFn: () => null,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_13_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_13_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 27,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [],
    metadata: lowered_import_13_metadata,
    resultLowerFns: [_lowerFlatOwn.bind(null, 8)],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: null,
    getMemoryFn: () => null,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_14_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_14_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 28,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 9)],
    metadata: lowered_import_14_metadata,
    resultLowerFns: [_lowerFlatEnum.bind(null, 4)],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: null,
    getMemoryFn: () => null,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_15_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_15_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 29,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 9)],
    metadata: lowered_import_15_metadata,
    resultLowerFns: [_lowerFlatOwn.bind(null, 1)],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: null,
    getMemoryFn: () => null,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_16_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_16_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 30,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 10)],
    metadata: lowered_import_16_metadata,
    resultLowerFns: [_lowerFlatOwn.bind(null, 1)],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: null,
    getMemoryFn: () => null,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_17_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_17_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 31,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 11)],
    metadata: lowered_import_17_metadata,
    resultLowerFns: [_lowerFlatOwn.bind(null, 1)],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: null,
    getMemoryFn: () => null,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_18_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_18_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 32,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 12)],
    metadata: lowered_import_18_metadata,
    resultLowerFns: [_lowerFlatBool],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: null,
    getMemoryFn: () => null,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_19_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_19_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 33,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 12)],
    metadata: lowered_import_19_metadata,
    resultLowerFns: [_lowerFlatEnum.bind(null, 4)],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: null,
    getMemoryFn: () => null,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_20_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_20_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 34,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 12)],
    metadata: lowered_import_20_metadata,
    resultLowerFns: [_lowerFlatOwn.bind(null, 1)],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: null,
    getMemoryFn: () => null,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_21_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_21_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 35,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 13)],
    metadata: lowered_import_21_metadata,
    resultLowerFns: [_lowerFlatOwn.bind(null, 1)],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: null,
    getMemoryFn: () => null,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_22_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_22_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 36,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [],
    metadata: lowered_import_22_metadata,
    resultLowerFns: [_lowerFlatU64],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: null,
    getMemoryFn: () => null,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_23_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_23_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 37,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [],
    metadata: lowered_import_23_metadata,
    resultLowerFns: [_lowerFlatU64],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: null,
    getMemoryFn: () => null,
    getReallocFn: () => null,
  },
  ),
});

const trampoline38 = waitableSetNew.bind(null, 0);

const trampoline39 = waitableSetDrop.bind(null, 0);

const trampoline40 = waitableJoin.bind(null, 0);

const trampoline41 = contextSet.bind(null, 0);
const trampoline42 = contextGet.bind(null, 0);
const trampoline43 = subtaskDrop.bind(
null,
0,
);

GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_24_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_24_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 44,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatU32],
    metadata: lowered_import_24_metadata,
    resultLowerFns: [],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: null,
    getMemoryFn: () => null,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_25_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_25_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 45,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatU32],
    metadata: lowered_import_25_metadata,
    resultLowerFns: [],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: null,
    getMemoryFn: () => null,
    getReallocFn: () => null,
  },
  ),
});

const trampoline46 = taskReturn.bind(
null,
{
  componentIdx: 0,
  useDirectParams: true,
  getMemoryFn: () => null,
  memoryIdx: null,
  callbackFnIdx: null,
  liftFns: [],
},
);

GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_26_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_26_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 47,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [],
    metadata: lowered_import_26_metadata,
    resultLowerFns: [_lowerFlatList.bind(null, 5)],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => realloc0,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_27_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_27_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 48,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [],
    metadata: lowered_import_27_metadata,
    resultLowerFns: [_lowerFlatRecord([{ field: 'seconds', lowerFn: _lowerFlatU64, align32: 8 },{ field: 'nanoseconds', lowerFn: _lowerFlatU32, align32: 8 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_28_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_28_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 49,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [],
    metadata: lowered_import_28_metadata,
    resultLowerFns: [_lowerFlatRecord([{ field: 'seconds', lowerFn: _lowerFlatU64, align32: 8 },{ field: 'nanoseconds', lowerFn: _lowerFlatU32, align32: 8 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_29_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_29_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 50,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 6),_liftFlatU64,_liftFlatU64,_liftFlatEnum.bind(null, 0)],
    metadata: lowered_import_29_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 1), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_30_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_30_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 51,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 6)],
    metadata: lowered_import_30_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 1), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_31_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_31_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 52,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 6)],
    metadata: lowered_import_31_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatEnum.bind(null, 2), align32: 1 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 1), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_32_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_32_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 53,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 6),_liftFlatU64],
    metadata: lowered_import_32_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 1), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_33_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_33_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 54,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 6),_liftFlatList.bind(null, 4),_liftFlatU64],
    metadata: lowered_import_33_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 1), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_34_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_34_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 55,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 0)],
    metadata: lowered_import_34_metadata,
    resultLowerFns: [_lowerFlatOption.bind(null, 5)],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_35_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_35_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 56,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 6)],
    metadata: lowered_import_35_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatOwn.bind(null, 7), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 1), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_36_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_36_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 57,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 6)],
    metadata: lowered_import_36_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 1), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_37_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_37_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 58,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 6),_liftFlatStringUTF8],
    metadata: lowered_import_37_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 1), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_38_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_38_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 59,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 6),_liftFlatStringUTF8],
    metadata: lowered_import_38_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 1), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_39_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_39_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 60,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 6),_liftFlatStringUTF8,_liftFlatOwn.bind(null, 6),_liftFlatStringUTF8],
    metadata: lowered_import_39_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 1), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_40_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_40_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 61,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 6),_liftFlatStringUTF8,_liftFlatStringUTF8],
    metadata: lowered_import_40_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 1), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_41_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_41_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 62,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 6),_liftFlatStringUTF8],
    metadata: lowered_import_41_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 1), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_42_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_42_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 63,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 6),_liftFlatU64],
    metadata: lowered_import_42_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatOwn.bind(null, 2), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 1), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_43_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_43_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 64,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 6),_liftFlatU64],
    metadata: lowered_import_43_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatOwn.bind(null, 3), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 1), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_44_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_44_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 65,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 6)],
    metadata: lowered_import_44_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatOwn.bind(null, 3), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 1), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_45_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_45_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 66,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 6)],
    metadata: lowered_import_45_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatFlags.bind(null, 0), align32: 1 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 1), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_46_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_46_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 67,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 6),_liftFlatVariant([['no-change', null, null],['now', null, null],['timestamp', _liftFlatRecord([['seconds', _liftFlatU64, 16],['nanoseconds', _liftFlatU32, 16],]), 16],]),_liftFlatVariant([['no-change', null, null],['now', null, null],['timestamp', _liftFlatRecord([['seconds', _liftFlatU64, 16],['nanoseconds', _liftFlatU32, 16],]), 16],])],
    metadata: lowered_import_46_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 1), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_47_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_47_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 68,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 6),_liftFlatU64,_liftFlatU64],
    metadata: lowered_import_47_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatTuple.bind(null, 37), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 1), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => realloc0,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_48_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_48_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 69,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 6)],
    metadata: lowered_import_48_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatRecord([{ field: 'type', lowerFn: _lowerFlatEnum.bind(null, 2), align32: 8 },{ field: 'link-count', lowerFn: _lowerFlatU64, align32: 8 },{ field: 'size', lowerFn: _lowerFlatU64, align32: 8 },{ field: 'data-access-timestamp', lowerFn: _lowerFlatOption.bind(null, 3), align32: 8 },{ field: 'data-modification-timestamp', lowerFn: _lowerFlatOption.bind(null, 3), align32: 8 },{ field: 'status-change-timestamp', lowerFn: _lowerFlatOption.bind(null, 3), align32: 8 },]), align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 1), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_49_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_49_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 70,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 6),_liftFlatFlags.bind(null, 1),_liftFlatStringUTF8],
    metadata: lowered_import_49_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatRecord([{ field: 'type', lowerFn: _lowerFlatEnum.bind(null, 2), align32: 8 },{ field: 'link-count', lowerFn: _lowerFlatU64, align32: 8 },{ field: 'size', lowerFn: _lowerFlatU64, align32: 8 },{ field: 'data-access-timestamp', lowerFn: _lowerFlatOption.bind(null, 3), align32: 8 },{ field: 'data-modification-timestamp', lowerFn: _lowerFlatOption.bind(null, 3), align32: 8 },{ field: 'status-change-timestamp', lowerFn: _lowerFlatOption.bind(null, 3), align32: 8 },]), align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 1), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_50_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_50_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 71,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 6),_liftFlatFlags.bind(null, 1),_liftFlatStringUTF8,_liftFlatVariant([['no-change', null, null],['now', null, null],['timestamp', _liftFlatRecord([['seconds', _liftFlatU64, 16],['nanoseconds', _liftFlatU32, 16],]), 16],]),_liftFlatVariant([['no-change', null, null],['now', null, null],['timestamp', _liftFlatRecord([['seconds', _liftFlatU64, 16],['nanoseconds', _liftFlatU32, 16],]), 16],])],
    metadata: lowered_import_50_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 1), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_51_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_51_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 72,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 6),_liftFlatFlags.bind(null, 1),_liftFlatStringUTF8,_liftFlatOwn.bind(null, 6),_liftFlatStringUTF8],
    metadata: lowered_import_51_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 1), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_52_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_52_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 73,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 6),_liftFlatFlags.bind(null, 1),_liftFlatStringUTF8,_liftFlatFlags.bind(null, 2),_liftFlatFlags.bind(null, 0)],
    metadata: lowered_import_52_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatOwn.bind(null, 6), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 1), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_53_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_53_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 74,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 6),_liftFlatStringUTF8],
    metadata: lowered_import_53_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatStringUTF8, align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 1), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => realloc0,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_54_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_54_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 75,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 6)],
    metadata: lowered_import_54_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatRecord([{ field: 'lower', lowerFn: _lowerFlatU64, align32: 8 },{ field: 'upper', lowerFn: _lowerFlatU64, align32: 8 },]), align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 1), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_55_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_55_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 76,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 6),_liftFlatFlags.bind(null, 1),_liftFlatStringUTF8],
    metadata: lowered_import_55_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatRecord([{ field: 'lower', lowerFn: _lowerFlatU64, align32: 8 },{ field: 'upper', lowerFn: _lowerFlatU64, align32: 8 },]), align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 1), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_56_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_56_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 77,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 7)],
    metadata: lowered_import_56_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatOption.bind(null, 4), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 1), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => realloc0,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_57_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_57_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 78,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 2),_liftFlatU64],
    metadata: lowered_import_57_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatList.bind(null, 4), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 0), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => realloc0,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_58_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_58_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 79,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 2),_liftFlatU64],
    metadata: lowered_import_58_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatList.bind(null, 4), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 0), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => realloc0,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_59_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_59_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 80,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 3)],
    metadata: lowered_import_59_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 0), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_60_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_60_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 81,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 3),_liftFlatList.bind(null, 4)],
    metadata: lowered_import_60_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 0), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_61_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_61_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 82,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 3),_liftFlatList.bind(null, 4)],
    metadata: lowered_import_61_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 0), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_62_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_62_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 83,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 3)],
    metadata: lowered_import_62_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 0), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_63_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_63_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 84,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatList.bind(null, 2)],
    metadata: lowered_import_63_metadata,
    resultLowerFns: [_lowerFlatList.bind(null, 3)],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => realloc0,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_64_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_64_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 85,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatU64],
    metadata: lowered_import_64_metadata,
    resultLowerFns: [_lowerFlatList.bind(null, 4)],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => realloc0,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_65_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_65_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 86,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [],
    metadata: lowered_import_65_metadata,
    resultLowerFns: [_lowerFlatList.bind(null, 0)],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => realloc0,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_66_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_66_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 87,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [],
    metadata: lowered_import_66_metadata,
    resultLowerFns: [_lowerFlatList.bind(null, 1)],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => realloc0,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_67_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_67_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 88,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [],
    metadata: lowered_import_67_metadata,
    resultLowerFns: [_lowerFlatOption.bind(null, 1)],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_68_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_68_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 89,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [],
    metadata: lowered_import_68_metadata,
    resultLowerFns: [_lowerFlatOption.bind(null, 2)],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_69_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_69_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 90,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [],
    metadata: lowered_import_69_metadata,
    resultLowerFns: [_lowerFlatOption.bind(null, 2)],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_70_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_70_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 91,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 0)],
    metadata: lowered_import_70_metadata,
    resultLowerFns: [_lowerFlatStringUTF8],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => realloc1,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_71_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_71_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 92,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatList.bind(null, 2)],
    metadata: lowered_import_71_metadata,
    resultLowerFns: [_lowerFlatList.bind(null, 3)],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => realloc1,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_72_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_72_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 93,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 2),_liftFlatU64],
    metadata: lowered_import_72_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatList.bind(null, 4), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 0), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => realloc1,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_73_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_73_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 94,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 2),_liftFlatU64],
    metadata: lowered_import_73_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatList.bind(null, 4), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 0), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => realloc1,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_74_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_74_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 95,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 2),_liftFlatU64],
    metadata: lowered_import_74_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 0), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_75_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_75_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 96,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 2),_liftFlatU64],
    metadata: lowered_import_75_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 0), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_76_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_76_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 97,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 3)],
    metadata: lowered_import_76_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 0), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_77_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_77_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 98,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 3),_liftFlatU64],
    metadata: lowered_import_77_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 0), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_78_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_78_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 99,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 3),_liftFlatU64],
    metadata: lowered_import_78_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 0), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_79_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_79_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 100,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 3),_liftFlatOwn.bind(null, 2),_liftFlatU64],
    metadata: lowered_import_79_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 0), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_80_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_80_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 101,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 3),_liftFlatOwn.bind(null, 2),_liftFlatU64],
    metadata: lowered_import_80_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'last-operation-failed', lowerFn: _lowerFlatOwn.bind(null, 0), align32: 4, },{ discriminant: 1, tag: 'closed', lowerFn: null, align32: null, },] }), align32: 4 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_81_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_81_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 102,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 6),_liftFlatU64,_liftFlatU64],
    metadata: lowered_import_81_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatTuple.bind(null, 37), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 1), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => realloc1,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_82_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_82_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 103,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 6),_liftFlatStringUTF8],
    metadata: lowered_import_82_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatStringUTF8, align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 1), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => realloc1,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_83_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_83_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 104,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 7)],
    metadata: lowered_import_83_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatOption.bind(null, 4), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 1), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => realloc1,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_84_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_84_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 105,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 9),_liftFlatOwn.bind(null, 8),_liftFlatVariant([['ipv4', _liftFlatRecord([['port', _liftFlatU16, 6],['address', _liftFlatTuple.bind(null, 60), 6],]), 6],['ipv6', _liftFlatRecord([['port', _liftFlatU16, 28],['flow-info', _liftFlatU32, 28],['address', _liftFlatTuple.bind(null, 61), 28],['scope-id', _liftFlatU32, 28],]), 28],])],
    metadata: lowered_import_84_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_85_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_85_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 106,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 9)],
    metadata: lowered_import_85_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_86_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_86_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 107,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 9),_liftFlatOption.bind(null, 6)],
    metadata: lowered_import_86_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatTuple.bind(null, 66), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_87_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_87_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 108,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 9)],
    metadata: lowered_import_87_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'ipv4', lowerFn: _lowerFlatRecord([{ field: 'port', lowerFn: _lowerFlatU16, align32: 2 },{ field: 'address', lowerFn: _lowerFlatTuple.bind(null, 60), align32: 2 },]), align32: 2, },{ discriminant: 1, tag: 'ipv6', lowerFn: _lowerFlatRecord([{ field: 'port', lowerFn: _lowerFlatU16, align32: 4 },{ field: 'flow-info', lowerFn: _lowerFlatU32, align32: 4 },{ field: 'address', lowerFn: _lowerFlatTuple.bind(null, 61), align32: 4 },{ field: 'scope-id', lowerFn: _lowerFlatU32, align32: 4 },]), align32: 4, },] }), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_88_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_88_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 109,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 9)],
    metadata: lowered_import_88_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'ipv4', lowerFn: _lowerFlatRecord([{ field: 'port', lowerFn: _lowerFlatU16, align32: 2 },{ field: 'address', lowerFn: _lowerFlatTuple.bind(null, 60), align32: 2 },]), align32: 2, },{ discriminant: 1, tag: 'ipv6', lowerFn: _lowerFlatRecord([{ field: 'port', lowerFn: _lowerFlatU16, align32: 4 },{ field: 'flow-info', lowerFn: _lowerFlatU32, align32: 4 },{ field: 'address', lowerFn: _lowerFlatTuple.bind(null, 61), align32: 4 },{ field: 'scope-id', lowerFn: _lowerFlatU32, align32: 4 },]), align32: 4, },] }), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_89_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_89_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 110,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 9)],
    metadata: lowered_import_89_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU8, align32: 1 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_90_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_90_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 111,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 9),_liftFlatU8],
    metadata: lowered_import_90_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_91_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_91_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 112,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 9)],
    metadata: lowered_import_91_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_92_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_92_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 113,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 9),_liftFlatU64],
    metadata: lowered_import_92_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_93_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_93_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 114,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 9)],
    metadata: lowered_import_93_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_94_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_94_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 115,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 9),_liftFlatU64],
    metadata: lowered_import_94_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_95_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_95_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 116,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 10),_liftFlatU64],
    metadata: lowered_import_95_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatList.bind(null, 6), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => realloc1,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_96_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_96_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 117,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 11)],
    metadata: lowered_import_96_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_97_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_97_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 118,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 11),_liftFlatList.bind(null, 7)],
    metadata: lowered_import_97_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_98_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_98_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 119,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 12),_liftFlatOwn.bind(null, 8),_liftFlatVariant([['ipv4', _liftFlatRecord([['port', _liftFlatU16, 6],['address', _liftFlatTuple.bind(null, 60), 6],]), 6],['ipv6', _liftFlatRecord([['port', _liftFlatU16, 28],['flow-info', _liftFlatU32, 28],['address', _liftFlatTuple.bind(null, 61), 28],['scope-id', _liftFlatU32, 28],]), 28],])],
    metadata: lowered_import_98_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_99_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_99_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 120,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 12)],
    metadata: lowered_import_99_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_100_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_100_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 121,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 12),_liftFlatOwn.bind(null, 8),_liftFlatVariant([['ipv4', _liftFlatRecord([['port', _liftFlatU16, 6],['address', _liftFlatTuple.bind(null, 60), 6],]), 6],['ipv6', _liftFlatRecord([['port', _liftFlatU16, 28],['flow-info', _liftFlatU32, 28],['address', _liftFlatTuple.bind(null, 61), 28],['scope-id', _liftFlatU32, 28],]), 28],])],
    metadata: lowered_import_100_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_101_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_101_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 122,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 12)],
    metadata: lowered_import_101_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatTuple.bind(null, 83), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_102_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_102_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 123,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 12)],
    metadata: lowered_import_102_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_103_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_103_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 124,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 12)],
    metadata: lowered_import_103_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_104_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_104_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 125,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 12)],
    metadata: lowered_import_104_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatTuple.bind(null, 85), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_105_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_105_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 126,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 12)],
    metadata: lowered_import_105_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'ipv4', lowerFn: _lowerFlatRecord([{ field: 'port', lowerFn: _lowerFlatU16, align32: 2 },{ field: 'address', lowerFn: _lowerFlatTuple.bind(null, 60), align32: 2 },]), align32: 2, },{ discriminant: 1, tag: 'ipv6', lowerFn: _lowerFlatRecord([{ field: 'port', lowerFn: _lowerFlatU16, align32: 4 },{ field: 'flow-info', lowerFn: _lowerFlatU32, align32: 4 },{ field: 'address', lowerFn: _lowerFlatTuple.bind(null, 61), align32: 4 },{ field: 'scope-id', lowerFn: _lowerFlatU32, align32: 4 },]), align32: 4, },] }), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_106_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_106_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 127,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 12)],
    metadata: lowered_import_106_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'ipv4', lowerFn: _lowerFlatRecord([{ field: 'port', lowerFn: _lowerFlatU16, align32: 2 },{ field: 'address', lowerFn: _lowerFlatTuple.bind(null, 60), align32: 2 },]), align32: 2, },{ discriminant: 1, tag: 'ipv6', lowerFn: _lowerFlatRecord([{ field: 'port', lowerFn: _lowerFlatU16, align32: 4 },{ field: 'flow-info', lowerFn: _lowerFlatU32, align32: 4 },{ field: 'address', lowerFn: _lowerFlatTuple.bind(null, 61), align32: 4 },{ field: 'scope-id', lowerFn: _lowerFlatU32, align32: 4 },]), align32: 4, },] }), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_107_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_107_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 128,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 12),_liftFlatU64],
    metadata: lowered_import_107_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_108_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_108_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 129,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 12)],
    metadata: lowered_import_108_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatBool, align32: 1 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_109_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_109_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 130,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 12),_liftFlatBool],
    metadata: lowered_import_109_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_110_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_110_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 131,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 12)],
    metadata: lowered_import_110_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_111_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_111_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 132,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 12),_liftFlatU64],
    metadata: lowered_import_111_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_112_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_112_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 133,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 12)],
    metadata: lowered_import_112_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_113_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_113_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 134,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 12),_liftFlatU64],
    metadata: lowered_import_113_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_114_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_114_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 135,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 12)],
    metadata: lowered_import_114_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU32, align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_115_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_115_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 136,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 12),_liftFlatU32],
    metadata: lowered_import_115_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_116_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_116_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 137,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 12)],
    metadata: lowered_import_116_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU8, align32: 1 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_117_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_117_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 138,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 12),_liftFlatU8],
    metadata: lowered_import_117_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_118_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_118_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 139,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 12)],
    metadata: lowered_import_118_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_119_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_119_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 140,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 12),_liftFlatU64],
    metadata: lowered_import_119_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_120_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_120_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 141,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 12)],
    metadata: lowered_import_120_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU64, align32: 8 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_121_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_121_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 142,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 12),_liftFlatU64],
    metadata: lowered_import_121_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_122_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_122_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 143,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 12),_liftFlatEnum.bind(null, 5)],
    metadata: lowered_import_122_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: null, align32: null },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_123_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_123_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 144,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 8),_liftFlatStringUTF8],
    metadata: lowered_import_123_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatOwn.bind(null, 13), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_124_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_124_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 145,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatOwn.bind(null, 13)],
    metadata: lowered_import_124_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatOption.bind(null, 7), align32: 2 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_125_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_125_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 146,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [],
    metadata: lowered_import_125_metadata,
    resultLowerFns: [_lowerFlatList.bind(null, 0)],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => realloc1,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_126_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_126_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 147,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [],
    metadata: lowered_import_126_metadata,
    resultLowerFns: [_lowerFlatList.bind(null, 1)],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => realloc1,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_127_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_127_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 148,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [],
    metadata: lowered_import_127_metadata,
    resultLowerFns: [_lowerFlatOption.bind(null, 0)],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => realloc1,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_128_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_128_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 149,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [],
    metadata: lowered_import_128_metadata,
    resultLowerFns: [_lowerFlatList.bind(null, 5)],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => realloc1,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_129_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_129_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 150,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatEnum.bind(null, 4)],
    metadata: lowered_import_129_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatOwn.bind(null, 9), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_130_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_130_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 151,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatEnum.bind(null, 4)],
    metadata: lowered_import_130_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatOwn.bind(null, 12), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatEnum.bind(null, 3), align32: 1 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_131_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_131_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 152,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatU64],
    metadata: lowered_import_131_metadata,
    resultLowerFns: [_lowerFlatList.bind(null, 4)],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => realloc1,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_132_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_132_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 153,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatU64],
    metadata: lowered_import_132_metadata,
    resultLowerFns: [_lowerFlatList.bind(null, 4)],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => realloc1,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_133_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_133_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 154,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [],
    metadata: lowered_import_133_metadata,
    resultLowerFns: [_lowerFlatTuple.bind(null, 100)],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_134_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_134_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 155,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatStringUTF8,_liftFlatU16],
    metadata: lowered_import_134_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU32, align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'connection-refused', lowerFn: null, align32: null, },{ discriminant: 1, tag: 'connection-reset', lowerFn: null, align32: null, },{ discriminant: 2, tag: 'timed-out', lowerFn: null, align32: null, },{ discriminant: 3, tag: 'host-not-found', lowerFn: null, align32: null, },{ discriminant: 4, tag: 'io-error', lowerFn: _lowerFlatStringUTF8, align32: 4, },{ discriminant: 5, tag: 'not-permitted', lowerFn: _lowerFlatStringUTF8, align32: 4, },{ discriminant: 6, tag: 'invalid-handle', lowerFn: null, align32: null, },] }), align32: 4 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => realloc2,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_135_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_135_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 156,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatU32,_liftFlatU32],
    metadata: lowered_import_135_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatList.bind(null, 4), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'connection-refused', lowerFn: null, align32: null, },{ discriminant: 1, tag: 'connection-reset', lowerFn: null, align32: null, },{ discriminant: 2, tag: 'timed-out', lowerFn: null, align32: null, },{ discriminant: 3, tag: 'host-not-found', lowerFn: null, align32: null, },{ discriminant: 4, tag: 'io-error', lowerFn: _lowerFlatStringUTF8, align32: 4, },{ discriminant: 5, tag: 'not-permitted', lowerFn: _lowerFlatStringUTF8, align32: 4, },{ discriminant: 6, tag: 'invalid-handle', lowerFn: null, align32: null, },] }), align32: 4 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => realloc2,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_136_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_136_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 157,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatU32,_liftFlatList.bind(null, 4)],
    metadata: lowered_import_136_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU32, align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'connection-refused', lowerFn: null, align32: null, },{ discriminant: 1, tag: 'connection-reset', lowerFn: null, align32: null, },{ discriminant: 2, tag: 'timed-out', lowerFn: null, align32: null, },{ discriminant: 3, tag: 'host-not-found', lowerFn: null, align32: null, },{ discriminant: 4, tag: 'io-error', lowerFn: _lowerFlatStringUTF8, align32: 4, },{ discriminant: 5, tag: 'not-permitted', lowerFn: _lowerFlatStringUTF8, align32: 4, },{ discriminant: 6, tag: 'invalid-handle', lowerFn: null, align32: null, },] }), align32: 4 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => realloc2,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_137_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_137_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 158,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatU32,_liftFlatStringUTF8],
    metadata: lowered_import_137_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU32, align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'tcp', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'connection-refused', lowerFn: null, align32: null, },{ discriminant: 1, tag: 'connection-reset', lowerFn: null, align32: null, },{ discriminant: 2, tag: 'timed-out', lowerFn: null, align32: null, },{ discriminant: 3, tag: 'host-not-found', lowerFn: null, align32: null, },{ discriminant: 4, tag: 'io-error', lowerFn: _lowerFlatStringUTF8, align32: 4, },{ discriminant: 5, tag: 'not-permitted', lowerFn: _lowerFlatStringUTF8, align32: 4, },{ discriminant: 6, tag: 'invalid-handle', lowerFn: null, align32: null, },] }), align32: 4, },{ discriminant: 1, tag: 'handshake-failed', lowerFn: _lowerFlatStringUTF8, align32: 4, },{ discriminant: 2, tag: 'certificate-error', lowerFn: _lowerFlatStringUTF8, align32: 4, },{ discriminant: 3, tag: 'invalid-handle', lowerFn: null, align32: null, },] }), align32: 4 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => realloc2,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_138_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_138_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 159,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatU32,_liftFlatU32],
    metadata: lowered_import_138_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatList.bind(null, 4), align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'tcp', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'connection-refused', lowerFn: null, align32: null, },{ discriminant: 1, tag: 'connection-reset', lowerFn: null, align32: null, },{ discriminant: 2, tag: 'timed-out', lowerFn: null, align32: null, },{ discriminant: 3, tag: 'host-not-found', lowerFn: null, align32: null, },{ discriminant: 4, tag: 'io-error', lowerFn: _lowerFlatStringUTF8, align32: 4, },{ discriminant: 5, tag: 'not-permitted', lowerFn: _lowerFlatStringUTF8, align32: 4, },{ discriminant: 6, tag: 'invalid-handle', lowerFn: null, align32: null, },] }), align32: 4, },{ discriminant: 1, tag: 'handshake-failed', lowerFn: _lowerFlatStringUTF8, align32: 4, },{ discriminant: 2, tag: 'certificate-error', lowerFn: _lowerFlatStringUTF8, align32: 4, },{ discriminant: 3, tag: 'invalid-handle', lowerFn: null, align32: null, },] }), align32: 4 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => realloc2,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_139_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_139_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 160,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatU32,_liftFlatList.bind(null, 4)],
    metadata: lowered_import_139_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatU32, align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'tcp', lowerFn: _lowerFlatVariant({ discriminantSizeBytes: 1, lowerMetas: [{ discriminant: 0, tag: 'connection-refused', lowerFn: null, align32: null, },{ discriminant: 1, tag: 'connection-reset', lowerFn: null, align32: null, },{ discriminant: 2, tag: 'timed-out', lowerFn: null, align32: null, },{ discriminant: 3, tag: 'host-not-found', lowerFn: null, align32: null, },{ discriminant: 4, tag: 'io-error', lowerFn: _lowerFlatStringUTF8, align32: 4, },{ discriminant: 5, tag: 'not-permitted', lowerFn: _lowerFlatStringUTF8, align32: 4, },{ discriminant: 6, tag: 'invalid-handle', lowerFn: null, align32: null, },] }), align32: 4, },{ discriminant: 1, tag: 'handshake-failed', lowerFn: _lowerFlatStringUTF8, align32: 4, },{ discriminant: 2, tag: 'certificate-error', lowerFn: _lowerFlatStringUTF8, align32: 4, },{ discriminant: 3, tag: 'invalid-handle', lowerFn: null, align32: null, },] }), align32: 4 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => realloc2,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_140_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_140_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 161,
    componentIdx: 0,
    isAsync: true,
    paramLiftFns: [_liftFlatStringUTF8,_liftFlatStringUTF8],
    metadata: lowered_import_140_metadata,
    resultLowerFns: [_lowerFlatResult([{ discriminant: 0, tag: 'ok', lowerFn: _lowerFlatStringUTF8, align32: 4 },{ discriminant: 1, tag: 'error', lowerFn: _lowerFlatStringUTF8, align32: 4 },])],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => realloc2,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_141_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_141_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 162,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [],
    metadata: lowered_import_141_metadata,
    resultLowerFns: [_lowerFlatList.bind(null, 8)],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => realloc2,
  },
  ),
});


GlobalComponentAsyncLowers.define({
  componentIdx: lowered_import_142_metadata.moduleIdx,
  qualifiedImportFn: lowered_import_142_metadata.qualifiedImportFn,
  fn: _lowerImport.bind(
  null,
  {
    trampolineIdx: 163,
    componentIdx: 0,
    isAsync: false,
    paramLiftFns: [_liftFlatU32,_liftFlatStringUTF8,_liftFlatStringUTF8],
    metadata: lowered_import_142_metadata,
    resultLowerFns: [],
    getCallbackFn: () => null,
    getPostReturnFn: () => null,
    isCancellable: false,
    memoryIdx: 0,
    getMemoryFn: () => memory0,
    getReallocFn: () => null,
  },
  ),
});

const trampoline164 = taskReturn.bind(
null,
{
  componentIdx: 0,
  useDirectParams: true,
  getMemoryFn: () => memory0,
  memoryIdx: 0,
  callbackFnIdx: null,
  liftFns: [_liftFlatResult([['ok', _liftFlatRecord([['stdout', _liftFlatStringUTF8, 16],['stderr', _liftFlatStringUTF8, 16],]), 16],['error', _liftFlatStringUTF8, 8],])],
},
);
const trampoline165 = taskReturn.bind(
null,
{
  componentIdx: 0,
  useDirectParams: true,
  getMemoryFn: () => memory0,
  memoryIdx: 0,
  callbackFnIdx: null,
  liftFns: [_liftFlatResult([['ok', function(ctx){const[p,c]=_liftFlatU32(ctx);const[l,c2]=_liftFlatU32(c);return[new Uint8Array(c2.memory.buffer.slice(p,p+l)),c2];}, 8],['error', _liftFlatStringUTF8, 8],])],
},
);
const trampoline166 = taskReturn.bind(
null,
{
  componentIdx: 0,
  useDirectParams: true,
  getMemoryFn: () => memory0,
  memoryIdx: 0,
  callbackFnIdx: null,
  liftFns: [_liftFlatResult([['ok', null, null],['error', _liftFlatStringUTF8, 8],])],
},
);
let exports11AsyncLiftExecute;

async function execute(arg0) {
  
  var encodeRes = _utf8AllocateAndEncode(arg0, realloc2, memory0);
  var ptr0= encodeRes.ptr;
  var len0 = encodeRes.len;
  
  _debugLog('[iface="execute", function="execute"][Instruction::CallWasm] enter', {
    funcName: 'execute',
    paramCount: 2,
    async: true,
    postReturn: false,
  });
  const hostProvided = false;
  
  const [task, _wasm_call_currentTaskID] = createNewCurrentTask({
    componentIdx: 0,
    isAsync: true,
    entryFnName: 'exports11AsyncLiftExecute',
    getCallbackFn: () => callback_0,
    callbackFnName: 'callback_0',
    errHandling: 'throw-result-err',
    callingWasmExport: true,
  });
  
  let ret = exports11AsyncLiftExecute(ptr0, len0);
  _debugLog('[iface="execute", function="execute"][Instruction::AsyncTaskReturn]', {
    funcName: 'execute',
    paramCount: 1,
    postReturn: false,
    hostProvided,
  });
  
  if (hostProvided) {
    _debugLog('[Instruction::AsyncTaskReturn] signaling host-provided async return completion', {
      task: task.id(),
      subtask: subtask?.id(),
      result: ret,
    })
    task.resolve([ret]);
    endCurrentTask(0, task.id());
    return task.completionPromise();
  }
  
  const currentSubtask = task.getLatestSubtask();
  if (currentSubtask && currentSubtask.isNotStarted()) {
    _debugLog('[Instruction::AsyncTaskReturn] subtask not started at end of task run, starting it', {
      task: task.id(),
      subtask: currentSubtask?.id(),
      result: ret,
    })
    currentSubtask.onStart();
  }
  
  const componentState = getOrCreateAsyncState(0);
  if (!componentState) { throw new Error('failed to lookup current component state'); }
  
  new Promise(async (resolve, reject) => {
    try {
      _debugLog("[Instruction::AsyncTaskReturn] starting driver loop", { fnName: 'execute' });
      await _driverLoop({
        componentInstanceIdx: 0,
        componentState,
        task,
        fnName: 'execute',
        isAsync: true,
        callbackResult: ret,
        resolve,
        reject
      });
    } catch (err) {
      _debugLog("[Instruction::AsyncTaskReturn] driver loop call failure", { err });
    }
  });
  
  let taskRes = await task.completionPromise();
  if (task.getErrHandling() === 'throw-result-err') {
    if (typeof taskRes !== 'object') { return taskRes; }
    if (taskRes.tag === 'err') { throw taskRes.val; }
    if (taskRes.tag === 'ok') { taskRes = taskRes.val; }
  }
  
  return taskRes;
  
}
let exports11AsyncLiftSnapshotState;

async function snapshotState() {
  _debugLog('[iface="snapshot-state", function="snapshot-state"][Instruction::CallWasm] enter', {
    funcName: 'snapshot-state',
    paramCount: 0,
    async: true,
    postReturn: false,
  });
  const hostProvided = false;
  
  const [task, _wasm_call_currentTaskID] = createNewCurrentTask({
    componentIdx: 0,
    isAsync: true,
    entryFnName: 'exports11AsyncLiftSnapshotState',
    getCallbackFn: () => callback_1,
    callbackFnName: 'callback_1',
    errHandling: 'throw-result-err',
    callingWasmExport: true,
  });
  
  let ret = exports11AsyncLiftSnapshotState();
  _debugLog('[iface="snapshot-state", function="snapshot-state"][Instruction::AsyncTaskReturn]', {
    funcName: 'snapshot-state',
    paramCount: 1,
    postReturn: false,
    hostProvided,
  });
  
  if (hostProvided) {
    _debugLog('[Instruction::AsyncTaskReturn] signaling host-provided async return completion', {
      task: task.id(),
      subtask: subtask?.id(),
      result: ret,
    })
    task.resolve([ret]);
    endCurrentTask(0, task.id());
    return task.completionPromise();
  }
  
  const currentSubtask = task.getLatestSubtask();
  if (currentSubtask && currentSubtask.isNotStarted()) {
    _debugLog('[Instruction::AsyncTaskReturn] subtask not started at end of task run, starting it', {
      task: task.id(),
      subtask: currentSubtask?.id(),
      result: ret,
    })
    currentSubtask.onStart();
  }
  
  const componentState = getOrCreateAsyncState(0);
  if (!componentState) { throw new Error('failed to lookup current component state'); }
  
  new Promise(async (resolve, reject) => {
    try {
      _debugLog("[Instruction::AsyncTaskReturn] starting driver loop", { fnName: 'snapshot-state' });
      await _driverLoop({
        componentInstanceIdx: 0,
        componentState,
        task,
        fnName: 'snapshot-state',
        isAsync: true,
        callbackResult: ret,
        resolve,
        reject
      });
    } catch (err) {
      _debugLog("[Instruction::AsyncTaskReturn] driver loop call failure", { err });
    }
  });
  
  let taskRes = await task.completionPromise();
  if (task.getErrHandling() === 'throw-result-err') {
    if (typeof taskRes !== 'object') { return taskRes; }
    if (taskRes.tag === 'err') { throw taskRes.val; }
    if (taskRes.tag === 'ok') { taskRes = taskRes.val; }
  }
  
  return taskRes;
  
}
let exports11AsyncLiftRestoreState;

async function restoreState(arg0) {
  var val0 = arg0;
  var len0 = val0.byteLength;
  var ptr0 = realloc2(0, 0, 1, len0 * 1);
  var src0 = new Uint8Array(val0.buffer || val0, val0.byteOffset, len0 * 1);
  (new Uint8Array(memory0.buffer, ptr0, len0 * 1)).set(src0);
  _debugLog('[iface="restore-state", function="restore-state"][Instruction::CallWasm] enter', {
    funcName: 'restore-state',
    paramCount: 2,
    async: true,
    postReturn: false,
  });
  const hostProvided = false;
  
  const [task, _wasm_call_currentTaskID] = createNewCurrentTask({
    componentIdx: 0,
    isAsync: true,
    entryFnName: 'exports11AsyncLiftRestoreState',
    getCallbackFn: () => callback_2,
    callbackFnName: 'callback_2',
    errHandling: 'throw-result-err',
    callingWasmExport: true,
  });
  
  let ret = exports11AsyncLiftRestoreState(ptr0, len0);
  _debugLog('[iface="restore-state", function="restore-state"][Instruction::AsyncTaskReturn]', {
    funcName: 'restore-state',
    paramCount: 1,
    postReturn: false,
    hostProvided,
  });
  
  if (hostProvided) {
    _debugLog('[Instruction::AsyncTaskReturn] signaling host-provided async return completion', {
      task: task.id(),
      subtask: subtask?.id(),
      result: ret,
    })
    task.resolve([ret]);
    endCurrentTask(0, task.id());
    return task.completionPromise();
  }
  
  const currentSubtask = task.getLatestSubtask();
  if (currentSubtask && currentSubtask.isNotStarted()) {
    _debugLog('[Instruction::AsyncTaskReturn] subtask not started at end of task run, starting it', {
      task: task.id(),
      subtask: currentSubtask?.id(),
      result: ret,
    })
    currentSubtask.onStart();
  }
  
  const componentState = getOrCreateAsyncState(0);
  if (!componentState) { throw new Error('failed to lookup current component state'); }
  
  new Promise(async (resolve, reject) => {
    try {
      _debugLog("[Instruction::AsyncTaskReturn] starting driver loop", { fnName: 'restore-state' });
      await _driverLoop({
        componentInstanceIdx: 0,
        componentState,
        task,
        fnName: 'restore-state',
        isAsync: true,
        callbackResult: ret,
        resolve,
        reject
      });
    } catch (err) {
      _debugLog("[Instruction::AsyncTaskReturn] driver loop call failure", { err });
    }
  });
  
  let taskRes = await task.completionPromise();
  if (task.getErrHandling() === 'throw-result-err') {
    if (typeof taskRes !== 'object') { return taskRes; }
    if (taskRes.tag === 'err') { throw taskRes.val; }
    if (taskRes.tag === 'ok') { taskRes = taskRes.val; }
  }
  
  return taskRes;
  
}
let exports11AsyncLiftClearState;

async function clearState() {
  _debugLog('[iface="clear-state", function="clear-state"][Instruction::CallWasm] enter', {
    funcName: 'clear-state',
    paramCount: 0,
    async: true,
    postReturn: false,
  });
  const hostProvided = false;
  
  const [task, _wasm_call_currentTaskID] = createNewCurrentTask({
    componentIdx: 0,
    isAsync: true,
    entryFnName: 'exports11AsyncLiftClearState',
    getCallbackFn: () => callback_3,
    callbackFnName: 'callback_3',
    errHandling: 'none',
    callingWasmExport: true,
  });
  
  let ret;exports11AsyncLiftClearState();
  _debugLog('[iface="clear-state", function="clear-state"][Instruction::AsyncTaskReturn]', {
    funcName: 'clear-state',
    paramCount: 0,
    postReturn: false,
    hostProvided,
  });
  
  if (hostProvided) {
    _debugLog('[Instruction::AsyncTaskReturn] signaling host-provided async return completion', {
      task: task.id(),
      subtask: subtask?.id(),
      result: ret,
    })
    task.resolve([ret]);
    endCurrentTask(0, task.id());
    return task.completionPromise();
  }
  
  const currentSubtask = task.getLatestSubtask();
  if (currentSubtask && currentSubtask.isNotStarted()) {
    _debugLog('[Instruction::AsyncTaskReturn] subtask not started at end of task run, starting it', {
      task: task.id(),
      subtask: currentSubtask?.id(),
      result: ret,
    })
    currentSubtask.onStart();
  }
  
  const componentState = getOrCreateAsyncState(0);
  if (!componentState) { throw new Error('failed to lookup current component state'); }
  
  new Promise(async (resolve, reject) => {
    try {
      _debugLog("[Instruction::AsyncTaskReturn] starting driver loop", { fnName: 'clear-state' });
      await _driverLoop({
        componentInstanceIdx: 0,
        componentState,
        task,
        fnName: 'clear-state',
        isAsync: true,
        callbackResult: ret,
        resolve,
        reject
      });
    } catch (err) {
      _debugLog("[Instruction::AsyncTaskReturn] driver loop call failure", { err });
    }
  });
  
  let taskRes = await task.completionPromise();
  if (task.getErrHandling() === 'throw-result-err') {
    if (typeof taskRes !== 'object') { return taskRes; }
    if (taskRes.tag === 'err') { throw taskRes.val; }
    if (taskRes.tag === 'ok') { taskRes = taskRes.val; }
  }
  
  return taskRes;
  
}
let exports11FinalizePreinit;

function finalizePreinit() {
  _debugLog('[iface="finalize-preinit", function="finalize-preinit"][Instruction::CallWasm] enter', {
    funcName: 'finalize-preinit',
    paramCount: 0,
    async: false,
    postReturn: true,
  });
  const hostProvided = false;
  
  const [task, _wasm_call_currentTaskID] = createNewCurrentTask({
    componentIdx: 0,
    isAsync: false,
    entryFnName: 'exports11FinalizePreinit',
    getCallbackFn: () => null,
    callbackFnName: 'null',
    errHandling: 'none',
    callingWasmExport: true,
  });
  
  let ret;exports11FinalizePreinit();
  endCurrentTask(0);
  _debugLog('[iface="finalize-preinit", function="finalize-preinit"][Instruction::Return]', {
    funcName: 'finalize-preinit',
    paramCount: 0,
    async: false,
    postReturn: true
  });
  
  let cstate = getOrCreateAsyncState(0);
  cstate.mayLeave = false;
  postReturn0();
  cstate.mayLeave = true;
  
  
}

const $init = (() => {
  let gen = (function* _initGenerator () {
    const module0 = fetchCompile(new URL('./eryx-sandbox.core.wasm', import.meta.url));
    const module1 = fetchCompile(new URL('./eryx-sandbox.core2.wasm', import.meta.url));
    const module2 = base64Compile('AGFzbQEAAAABEQNgAn9/AX9gA39/fwF/YAAAAwQDAAECBz0DEF9fbWFpbl9hcmdjX2FyZ3YAABhfX2N4YV90aHJlYWRfYXRleGl0X2ltcGwAAQtfaW5pdGlhbGl6ZQACCgwDAwAACwMAAAsCAAsALwlwcm9kdWNlcnMBDHByb2Nlc3NlZC1ieQENd2l0LWNvbXBvbmVudAcwLjI0My4wCwEA');
    const module3 = fetchCompile(new URL('./eryx-sandbox.core3.wasm', import.meta.url));
    const module4 = fetchCompile(new URL('./eryx-sandbox.core4.wasm', import.meta.url));
    const module5 = fetchCompile(new URL('./eryx-sandbox.core5.wasm', import.meta.url));
    const module6 = base64Compile('AGFzbQEAAAAAGghkeWxpbmsuMAEEBAIAAAIJAQdsaWJjLnNvAQgCYAAAYAABfwJaBANlbnYGbWVtb3J5AgABA2VudhlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAXAAAANlbnYNX19tZW1vcnlfYmFzZQN/AANlbnYMX190YWJsZV9iYXNlA38AAwUEAAABAAcYAgZnZXRwaWQAAgtfaW5pdGlhbGl6ZQADCioEAgALHQACQCMAQQBqKAIARQ0AAAsjAEEAakEBNgIAEAALBABBKgsCAAsLAwEBAAC9AQ0uZGVidWdfYWJicmV2AREBJQ4TBQMOEBcbDhEBEgYAAAIuAREBEgZAGJdCGQMOOgs7CycZPxkAAAM0AAMOSRM6CzsLAhgAAASJggEAMRMRAQAABTUASRMAAAYkAAMOPgsLCwAABy4AAw46CzsLJxk8GT8ZAAAAAREBJQ4TBQMOEBcbDhEBEgYAAAIuABEBEgZAGJdCGQMOOgs7CycZSRM/GQAAAxYASRMDDjoLOwUAAAQkAAMOPgsLCwAAAADUAQsuZGVidWdfaW5mb28AAAAEAAAAAAAEAbYAAAAdADsAAAAAAAAAgAAAAAUAAAAxAAAAAgUAAAAxAAAAB+0D/////58cAAAAAQgDLwAAAF8AAAABEgztAwAAAAADAAAAACIEawAAADUAAAAABWQAAAAGAAAAAAUEBwoAAAABBQBRAAAABABpAAAABAG2AAAAHQBfAAAAcQAAAIAAAAA3AAAABAAAAAI3AAAABAAAAAftA/////+fKAAAAAEDQQAAAANNAAAABAAAAAISAQQAAAAABQQAAK8CCi5kZWJ1Z19zdHJpbnQAcGlkX3QAX193YXNtX2NhbGxfY3RvcnMAX2luaXRpYWxpemUAZ2V0cGlkAGluaXRpYWxpemVkAGxpYmMtYm90dG9tLWhhbGYvY3J0L2NydDEtcmVhY3Rvci5jAGxpYmMtYm90dG9tLWhhbGYvZ2V0cGlkL2dldHBpZC5jAHdhc2lzZGs6Ly92MjcuMC9idWlsZC9zeXNyb290L3dhc2ktbGliYy13YXNtMzItd2FzaXAyAGNsYW5nIHZlcnNpb24gMjAuMS44LXdhc2ktc2RrIChodHRwczovL2dpdGh1Yi5jb20vbGx2bS9sbHZtLXByb2plY3QgODdmMDIyN2NiNjAxNDdhMjZhMWVlYjRmYjA2ZTNiNTA1ZTljNzI2MSkAALICCy5kZWJ1Z19saW5lbQAAAAQAOwAAAAEBAfsODQABAQEBAAAAAQAAAWxpYmMtYm90dG9tLWhhbGYvY3J0AABjcnQxLXJlYWN0b3IuYwABAAAABQkKAAUCBgAAAAMSAQUVBgggBQkGPQYDbCAFEQYDFiAFBQgkBQFnAgEAAQGxAAAABACaAAAAAQEB+w4NAAEBAQEAAAABAAABbGliYy1ib3R0b20taGFsZi9nZXRwaWQAd2FzaXNkazovL3YyNy4wL2J1aWxkL3N5c3Jvb3QvaW5zdGFsbC9zaGFyZS93YXNpLXN5c3Jvb3QvaW5jbHVkZS93YXNtMzItd2FzaXAyL2JpdHMAAGdldHBpZC5jAAEAAGFsbHR5cGVzLmgAAgAAAAAFAjcAAAAUBQUKPgIBAAEBAHYEbmFtZQAbGmxpYndhc2ktZW11bGF0ZWQtZ2V0cGlkLnNvASkDABFfX3dhc21fY2FsbF9jdG9ycwELX2luaXRpYWxpemUCBmdldHBpZAceAgANX19tZW1vcnlfYmFzZQEMX190YWJsZV9iYXNlCQcBAAQuYnNzAI4BCXByb2R1Y2VycwIIbGFuZ3VhZ2UBA0MxMQAMcHJvY2Vzc2VkLWJ5AQVjbGFuZ18yMC4xLjgtd2FzaS1zZGsgKGh0dHBzOi8vZ2l0aHViLmNvbS9sbHZtL2xsdm0tcHJvamVjdCA4N2YwMjI3Y2I2MDE0N2EyNmExZWViNGZiMDZlM2I1MDVlOWM3MjYxKQCGAQ90YXJnZXRfZmVhdHVyZXMHKw9idWxrLW1lbW9yeS1vcHQrFmNhbGwtaW5kaXJlY3Qtb3ZlcmxvbmcrDmV4dGVuZGVkLWNvbnN0KwptdWx0aXZhbHVlKw9tdXRhYmxlLWdsb2JhbHMrE25vbnRyYXBwaW5nLWZwdG9pbnQrCHNpZ24tZXh0');
    const module7 = base64Compile('AGFzbQEAAAAAGwhkeWxpbmsuMAEFmAMCAAACCQEHbGliYy5zbwEeBmABfwF/YAN/f38Bf2AAAGAAAX9gAn9/AX9gAX8AAnQGA2VudgZtZW1vcnkCAAEDZW52GV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBcAAAA2Vudg1fX21lbW9yeV9iYXNlA38AA2VudgxfX3RhYmxlX2Jhc2UDfwADZW52BnN0cmxlbgAAA2VudgZtZW1jbXAAAQMLCgICAgACAwQEBQIGBwF/AEGMAQsHngEHB2RsY2xvc2UABQdkbGVycm9yAAcGZGxvcGVuAAgFZGxzeW0ACRRfX3dhc21fc2V0X2xpYnJhcmllcwAKUF9aTjE3Y29tcGlsZXJfYnVpbHRpbnM0bWF0aDlsaWJtX21hdGg3Z2VuZXJpYzRzcXJ0OVJTUVJUX1RBQjE3aGIxMDRiYjhiODg4NzEyZjJFAwILX2luaXRpYWxpemUACwqTBgoCAAsPAEGMAyMAakEAQQz8CwALHwACQCMAQYwDaigCAEUNAAALIwBBjANqQQE2AgAQAgteAQN/AkAjAEGUA2ooAgAiAUUNACABKAIAQQFqIQJBcCEDAkADQCACQX9qIgJFDQEgASgCBCADQRBqIgNqIABHDQALQQAPCyMAIgJBkANqIAJBAGo2AgBBfw8LEAYACwMAAAsaAQJ/IwBBkANqIgAoAgAhASAAQQA2AgAgAQuJAgEHfwJAAkACQAJAIwBBlANqKAIAIgJFDQAjACEDAkAgAUH8fXFFDQAgA0E6aiEEDAMLIAAQACEBIAIoAgAhAyMAQRdqIQQgAigCBCEFQQAhAgJAIAMOAgMCAAtBACECA0AgA0EBdiIGIAJqIQQgAiAEIAUgBEEEdGoiB0EEaigCACAAIAcoAgAiByABIAcgAUkbEAEiCCAHIAFrIAgbQQBKGyECIAMgBmsiA0EBSw0ADAILCxAGAAsgBSACQQR0aiIDQQRqKAIAIAAgAygCACICIAEgAiABSRsQASEEIwAhByAEIAIgAWsgBBtFDQEgB0EXaiEECyMAQZADaiAENgIAQQAhAwsgAwvDAgEHfwJAIABBAWpBAUsNACMAIgJBkANqIAJB2QBqNgIAQQAPCwJAAkAjAEGUA2ooAgAiA0UNACADKAIAQQFqIQJBcCEEA0AgAkF/aiICRQ0CIAMoAgQgBEEQaiIEaiAARw0ACyABEAAhAiAAKAIMIQVBACEEAkACQAJAAkAgACgCCCIADgICAQALQQAhBANAIABBAXYiBiAEaiEDIAQgAyAFIANBDGxqIgdBBGooAgAgASAHKAIAIgcgAiAHIAJJGxABIgggByACayAIG0EAShshBCAAIAZrIgBBAUsNAAsLIAUgBEEMbGoiAEEEaigCACABIAAoAgAiBCACIAQgAkkbEAEiAyAEIAJrIAMbRQ0BCyMAIgJBkANqIAJBKWo2AgBBAA8LIAAoAggPCxAGAAsjACICQZADaiACQQBqNgIAQQALDQAjAEGUA2ogADYCAAsCAAsLAwEBAA');
    const module8 = fetchCompile(new URL('./eryx-sandbox.core6.wasm', import.meta.url));
    const module9 = fetchCompile(new URL('./eryx-sandbox.core7.wasm', import.meta.url));
    const module10 = fetchCompile(new URL('./eryx-sandbox.core8.wasm', import.meta.url));
    const module11 = fetchCompile(new URL('./eryx-sandbox.core9.wasm', import.meta.url));
    const module12 = base64Compile('AGFzbQEAAAABxwIpYAF/AX9gAn9/AX9gA39+fwF/YAR/fn5/AX9gA39+fgF/YAJ/fgF/YAV/f39+fwF/YAN/f38Bf2AEf39/fwF/YAR/fn9/AX9gBX9/f39/AX9gB39/f39+fn8Bf2AHf39/f39/fwF/YAl/f39/f35+f38Bf2AGf39/f39/AX9gAX8AYAABf2AAAGABfwBgBX9+fn9/AGACf38AYAN/fn8AYAV/f39+fwBgBH9/f38AYAd/f39/f39/AGAGf39/f39/AGAIf39+f39+f38AYAR/fn5/AGAFf39/f38AYAt/f39/f35/f35/fwBgCH9/f39/f39/AGAHf39/f39/fwBgA39/fwBgAn5/AGAEf39+fwBgD39/f39/f39/f39/f39/fwBgA39/fwBgBH9/f38AYAV/f39/fwF/YAV/f39/fwBgA39/fwADzgHMAQAAAQEBAgEBAwQAAAEBBAEFAwYHAQYIBgEJAAEIBwoLDA0OBw4KBwgPARAHDgoBABESEhITFBQVFhQUFBcXGBkXFRUUFBobFBwdHh8XFBwUFRUUFxcUICESEhISEhQgFRUVFRQXFxQUFRUiIhUVFBMUFBQVGhsWFBQXFBwdHh8XFxgZFxQcFBQjFCMUFBQkFBUUFRUUFyMUIxQUFBQUFBUUJBQVFBUUJBQkFBUUFSQXFBISEhISEhISEhQUISESJSQXFyQXJhInJygoEQQHAXABywHLAQe7Cc0BATAAAAExAAEBMgACATMAAwE0AAQBNQAFATYABgE3AAcBOAAIATkACQIxMAAKAjExAAsCMTIADAIxMwANAjE0AA4CMTUADwIxNgAQAjE3ABECMTgAEgIxOQATAjIwABQCMjEAFQIyMgAWAjIzABcCMjQAGAIyNQAZAjI2ABoCMjcAGwIyOAAcAjI5AB0CMzAAHgIzMQAfAjMyACACMzMAIQIzNAAiAjM1ACMCMzYAJAIzNwAlAjM4ACYCMzkAJwI0MAAoAjQxACkCNDIAKgI0MwArAjQ0ACwCNDUALQI0NgAuAjQ3AC8CNDgAMAI0OQAxAjUwADICNTEAMwI1MgA0AjUzADUCNTQANgI1NQA3AjU2ADgCNTcAOQI1OAA6AjU5ADsCNjAAPAI2MQA9AjYyAD4CNjMAPwI2NABAAjY1AEECNjYAQgI2NwBDAjY4AEQCNjkARQI3MABGAjcxAEcCNzIASAI3MwBJAjc0AEoCNzUASwI3NgBMAjc3AE0CNzgATgI3OQBPAjgwAFACODEAUQI4MgBSAjgzAFMCODQAVAI4NQBVAjg2AFYCODcAVwI4OABYAjg5AFkCOTAAWgI5MQBbAjkyAFwCOTMAXQI5NABeAjk1AF8COTYAYAI5NwBhAjk4AGICOTkAYwMxMDAAZAMxMDEAZQMxMDIAZgMxMDMAZwMxMDQAaAMxMDUAaQMxMDYAagMxMDcAawMxMDgAbAMxMDkAbQMxMTAAbgMxMTEAbwMxMTIAcAMxMTMAcQMxMTQAcgMxMTUAcwMxMTYAdAMxMTcAdQMxMTgAdgMxMTkAdwMxMjAAeAMxMjEAeQMxMjIAegMxMjMAewMxMjQAfAMxMjUAfQMxMjYAfgMxMjcAfwMxMjgAgAEDMTI5AIEBAzEzMACCAQMxMzEAgwEDMTMyAIQBAzEzMwCFAQMxMzQAhgEDMTM1AIcBAzEzNgCIAQMxMzcAiQEDMTM4AIoBAzEzOQCLAQMxNDAAjAEDMTQxAI0BAzE0MgCOAQMxNDMAjwEDMTQ0AJABAzE0NQCRAQMxNDYAkgEDMTQ3AJMBAzE0OACUAQMxNDkAlQEDMTUwAJYBAzE1MQCXAQMxNTIAmAEDMTUzAJkBAzE1NACaAQMxNTUAmwEDMTU2AJwBAzE1NwCdAQMxNTgAngEDMTU5AJ8BAzE2MACgAQMxNjEAoQEDMTYyAKIBAzE2MwCjAQMxNjQApAEDMTY1AKUBAzE2NgCmAQMxNjcApwEDMTY4AKgBAzE2OQCpAQMxNzAAqgEDMTcxAKsBAzE3MgCsAQMxNzMArQEDMTc0AK4BAzE3NQCvAQMxNzYAsAEDMTc3ALEBAzE3OACyAQMxNzkAswEDMTgwALQBAzE4MQC1AQMxODIAtgEDMTgzALcBAzE4NAC4AQMxODUAuQEDMTg2ALoBAzE4NwC7AQMxODgAvAEDMTg5AL0BAzE5MAC+AQMxOTEAvwEDMTkyAMABAzE5MwDBAQMxOTQAwgEDMTk1AMMBAzE5NgDEAQMxOTcAxQEDMTk4AMYBAzE5OQDHAQMyMDAAyAEDMjAxAMkBAzIwMgDKAQgkaW1wb3J0cwEAC19pbml0aWFsaXplAMsBCq4YzAEJACAAQQARAAALCQAgAEEBEQAACwsAIAAgAUECEQEACwsAIAAgAUEDEQEACwsAIAAgAUEEEQEACw0AIAAgASACQQURAgALCwAgACABQQYRAQALCwAgACABQQcRAQALDwAgACABIAIgA0EIEQMACw0AIAAgASACQQkRBAALCQAgAEEKEQAACwkAIABBCxEAAAsLACAAIAFBDBEBAAsLACAAIAFBDREBAAsNACAAIAEgAkEOEQQACwsAIAAgAUEPEQEACwsAIAAgAUEQEQUACw8AIAAgASACIANBEREDAAsRACAAIAEgAiADIARBEhEGAAsNACAAIAEgAkETEQcACwsAIAAgAUEUEQEACxEAIAAgASACIAMgBEEVEQYACw8AIAAgASACIANBFhEIAAsRACAAIAEgAiADIARBFxEGAAsLACAAIAFBGBEBAAsPACAAIAEgAiADQRkRCQALCQAgAEEaEQAACwsAIAAgAUEbEQEACw8AIAAgASACIANBHBEIAAsNACAAIAEgAkEdEQcACxEAIAAgASACIAMgBEEeEQoACxUAIAAgASACIAMgBCAFIAZBHxELAAsVACAAIAEgAiADIAQgBSAGQSARDAALGQAgACABIAIgAyAEIAUgBiAHIAhBIRENAAsTACAAIAEgAiADIAQgBUEiEQ4ACw0AIAAgASACQSMRBwALEwAgACABIAIgAyAEIAVBJBEOAAsRACAAIAEgAiADIARBJREKAAsNACAAIAEgAkEmEQcACw8AIAAgASACIANBJxEIAAsJACAAQSgRDwALCwAgACABQSkRAQALBwBBKhEQAAsNACAAIAEgAkErEQcACxMAIAAgASACIAMgBCAFQSwRDgALEQAgACABIAIgAyAEQS0RCgALCwAgACABQS4RAQALCQAgAEEvEQAACwcAQTAREQALCQAgAEExERIACwkAIABBMhESAAsJACAAQTMREgALEQAgACABIAIgAyAEQTQREwALCwAgACABQTURFAALCwAgACABQTYRFAALDQAgACABIAJBNxEVAAsRACAAIAEgAiADIARBOBEWAAsLACAAIAFBOREUAAsLACAAIAFBOhEUAAsLACAAIAFBOxEUAAsPACAAIAEgAiADQTwRFwALDwAgACABIAIgA0E9ERcACxUAIAAgASACIAMgBCAFIAZBPhEYAAsTACAAIAEgAiADIAQgBUE/ERkACxAAIAAgASACIANBwAARFwALDgAgACABIAJBwQARFQALDgAgACABIAJBwgARFQALDAAgACABQcMAERQACwwAIAAgAUHEABEUAAsYACAAIAEgAiADIAQgBSAGIAdBxQARGgALEAAgACABIAIgA0HGABEbAAsMACAAIAFBxwARFAALEgAgACABIAIgAyAEQcgAERwACx4AIAAgASACIAMgBCAFIAYgByAIIAkgCkHJABEdAAsYACAAIAEgAiADIAQgBSAGIAdBygARHgALFgAgACABIAIgAyAEIAUgBkHLABEfAAsQACAAIAEgAiADQcwAERcACwwAIAAgAUHNABEUAAsSACAAIAEgAiADIARBzgARHAALDAAgACABQc8AERQACw4AIAAgASACQdAAERUACw4AIAAgASACQdEAERUACwwAIAAgAUHSABEUAAsQACAAIAEgAiADQdMAERcACxAAIAAgASACIANB1AARFwALDAAgACABQdUAERQACw4AIAAgASACQdYAESAACwwAIAAgAUHXABEhAAsKACAAQdgAERIACwoAIABB2QAREgALCgAgAEHaABESAAsKACAAQdsAERIACwoAIABB3AAREgALDAAgACABQd0AERQACw4AIAAgASACQd4AESAACw4AIAAgASACQd8AERUACw4AIAAgASACQeAAERUACw4AIAAgASACQeEAERUACw4AIAAgASACQeIAERUACwwAIAAgAUHjABEUAAsQACAAIAEgAiADQeQAERcACxAAIAAgASACIANB5QARFwALDAAgACABQeYAERQACwwAIAAgAUHnABEUAAsOACAAIAEgAkHoABEVAAsOACAAIAEgAkHpABEVAAsQACAAIAEgAiADQeoAESIACxAAIAAgASACIANB6wARIgALDgAgACABIAJB7AARFQALDgAgACABIAJB7QARFQALDAAgACABQe4AERQACxIAIAAgASACIAMgBEHvABETAAsMACAAIAFB8AARFAALDAAgACABQfEAERQACwwAIAAgAUHyABEUAAsOACAAIAEgAkHzABEVAAsYACAAIAEgAiADIAQgBSAGIAdB9AARGgALEAAgACABIAIgA0H1ABEbAAsSACAAIAEgAiADIARB9gARFgALDAAgACABQfcAERQACwwAIAAgAUH4ABEUAAsQACAAIAEgAiADQfkAERcACwwAIAAgAUH6ABEUAAsSACAAIAEgAiADIARB+wARHAALHgAgACABIAIgAyAEIAUgBiAHIAggCSAKQfwAER0ACxgAIAAgASACIAMgBCAFIAYgB0H9ABEeAAsWACAAIAEgAiADIAQgBSAGQf4AER8ACxAAIAAgASACIANB/wARFwALEAAgACABIAIgA0GAAREXAAsWACAAIAEgAiADIAQgBSAGQYEBERgACxQAIAAgASACIAMgBCAFQYIBERkACxAAIAAgASACIANBgwERFwALDAAgACABQYQBERQACxIAIAAgASACIAMgBEGFAREcAAsMACAAIAFBhgERFAALDAAgACABQYcBERQACyYAIAAgASACIAMgBCAFIAYgByAIIAkgCiALIAwgDSAOQYgBESMACwwAIAAgAUGJAREUAAsmACAAIAEgAiADIAQgBSAGIAcgCCAJIAogCyAMIA0gDkGKAREjAAsMACAAIAFBiwERFAALDAAgACABQYwBERQACwwAIAAgAUGNAREUAAsOACAAIAEgAkGOAREkAAsMACAAIAFBjwERFAALDgAgACABIAJBkAERFQALDAAgACABQZEBERQACw4AIAAgASACQZIBERUACw4AIAAgASACQZMBERUACwwAIAAgAUGUAREUAAsQACAAIAEgAiADQZUBERcACyYAIAAgASACIAMgBCAFIAYgByAIIAkgCiALIAwgDSAOQZYBESMACwwAIAAgAUGXAREUAAsmACAAIAEgAiADIAQgBSAGIAcgCCAJIAogCyAMIA0gDkGYAREjAAsMACAAIAFBmQERFAALDAAgACABQZoBERQACwwAIAAgAUGbAREUAAsMACAAIAFBnAERFAALDAAgACABQZ0BERQACwwAIAAgAUGeAREUAAsOACAAIAEgAkGfAREVAAsMACAAIAFBoAERFAALDgAgACABIAJBoQERJAALDAAgACABQaIBERQACw4AIAAgASACQaMBERUACwwAIAAgAUGkAREUAAsOACAAIAEgAkGlAREVAAsMACAAIAFBpgERFAALDgAgACABIAJBpwERJAALDAAgACABQagBERQACw4AIAAgASACQakBESQACwwAIAAgAUGqAREUAAsOACAAIAEgAkGrAREVAAsMACAAIAFBrAERFAALDgAgACABIAJBrQERFQALDgAgACABIAJBrgERJAALEAAgACABIAIgA0GvAREXAAsMACAAIAFBsAERFAALCgAgAEGxARESAAsKACAAQbIBERIACwoAIABBswEREgALCgAgAEG0ARESAAsKACAAQbUBERIACwoAIABBtgEREgALCgAgAEG3ARESAAsKACAAQbgBERIACwoAIABBuQEREgALDAAgACABQboBERQACwwAIAAgAUG7AREUAAsMACAAIAFBvAERIQALDAAgACABQb0BESEACwoAIABBvgEREgALEAAgACABIAIgA0G/ARElAAsOACAAIAEgAkHAAREkAAsQACAAIAEgAiADQcEBERcACxAAIAAgASACIANBwgERFwALDgAgACABIAJBwwERJAALEAAgACABIAIgA0HEAREXAAsSACAAIAEgAiADIARBxQERJgALCgAgAEHGARESAAsSACAAIAEgAiADIARBxwERJwALEgAgACABIAIgAyAEQcgBEScACw4AIAAgASACQckBESgACw4AIAAgASACQcoBESgACwIACwAvCXByb2R1Y2VycwEMcHJvY2Vzc2VkLWJ5AQ13aXQtY29tcG9uZW50BzAuMjQzLjALAQA');
    const module13 = base64Compile('AGFzbQEAAAABxwIpYAF/AX9gAn9/AX9gA39+fwF/YAR/fn5/AX9gA39+fgF/YAJ/fgF/YAV/f39+fwF/YAN/f38Bf2AEf39/fwF/YAR/fn9/AX9gBX9/f39/AX9gB39/f39+fn8Bf2AHf39/f39/fwF/YAl/f39/f35+f38Bf2AGf39/f39/AX9gAX8AYAABf2AAAGABfwBgBX9+fn9/AGACf38AYAN/fn8AYAV/f39+fwBgBH9/f38AYAd/f39/f39/AGAGf39/f39/AGAIf39+f39+f38AYAR/fn5/AGAFf39/f38AYAt/f39/f35/f35/fwBgCH9/f39/f39/AGAHf39/f39/fwBgA39/fwBgAn5/AGAEf39+fwBgD39/f39/f39/f39/f39/fwBgA39/fwBgBH9/f38AYAV/f39/fwF/YAV/f39/fwBgA39/fwACsgrMAQABMAAAAAExAAAAATIAAQABMwABAAE0AAEAATUAAgABNgABAAE3AAEAATgAAwABOQAEAAIxMAAAAAIxMQAAAAIxMgABAAIxMwABAAIxNAAEAAIxNQABAAIxNgAFAAIxNwADAAIxOAAGAAIxOQAHAAIyMAABAAIyMQAGAAIyMgAIAAIyMwAGAAIyNAABAAIyNQAJAAIyNgAAAAIyNwABAAIyOAAIAAIyOQAHAAIzMAAKAAIzMQALAAIzMgAMAAIzMwANAAIzNAAOAAIzNQAHAAIzNgAOAAIzNwAKAAIzOAAHAAIzOQAIAAI0MAAPAAI0MQABAAI0MgAQAAI0MwAHAAI0NAAOAAI0NQAKAAI0NgABAAI0NwAAAAI0OAARAAI0OQASAAI1MAASAAI1MQASAAI1MgATAAI1MwAUAAI1NAAUAAI1NQAVAAI1NgAWAAI1NwAUAAI1OAAUAAI1OQAUAAI2MAAXAAI2MQAXAAI2MgAYAAI2MwAZAAI2NAAXAAI2NQAVAAI2NgAVAAI2NwAUAAI2OAAUAAI2OQAaAAI3MAAbAAI3MQAUAAI3MgAcAAI3MwAdAAI3NAAeAAI3NQAfAAI3NgAXAAI3NwAUAAI3OAAcAAI3OQAUAAI4MAAVAAI4MQAVAAI4MgAUAAI4MwAXAAI4NAAXAAI4NQAUAAI4NgAgAAI4NwAhAAI4OAASAAI4OQASAAI5MAASAAI5MQASAAI5MgASAAI5MwAUAAI5NAAgAAI5NQAVAAI5NgAVAAI5NwAVAAI5OAAVAAI5OQAUAAMxMDAAFwADMTAxABcAAzEwMgAUAAMxMDMAFAADMTA0ABUAAzEwNQAVAAMxMDYAIgADMTA3ACIAAzEwOAAVAAMxMDkAFQADMTEwABQAAzExMQATAAMxMTIAFAADMTEzABQAAzExNAAUAAMxMTUAFQADMTE2ABoAAzExNwAbAAMxMTgAFgADMTE5ABQAAzEyMAAUAAMxMjEAFwADMTIyABQAAzEyMwAcAAMxMjQAHQADMTI1AB4AAzEyNgAfAAMxMjcAFwADMTI4ABcAAzEyOQAYAAMxMzAAGQADMTMxABcAAzEzMgAUAAMxMzMAHAADMTM0ABQAAzEzNQAUAAMxMzYAIwADMTM3ABQAAzEzOAAjAAMxMzkAFAADMTQwABQAAzE0MQAUAAMxNDIAJAADMTQzABQAAzE0NAAVAAMxNDUAFAADMTQ2ABUAAzE0NwAVAAMxNDgAFAADMTQ5ABcAAzE1MAAjAAMxNTEAFAADMTUyACMAAzE1MwAUAAMxNTQAFAADMTU1ABQAAzE1NgAUAAMxNTcAFAADMTU4ABQAAzE1OQAVAAMxNjAAFAADMTYxACQAAzE2MgAUAAMxNjMAFQADMTY0ABQAAzE2NQAVAAMxNjYAFAADMTY3ACQAAzE2OAAUAAMxNjkAJAADMTcwABQAAzE3MQAVAAMxNzIAFAADMTczABUAAzE3NAAkAAMxNzUAFwADMTc2ABQAAzE3NwASAAMxNzgAEgADMTc5ABIAAzE4MAASAAMxODEAEgADMTgyABIAAzE4MwASAAMxODQAEgADMTg1ABIAAzE4NgAUAAMxODcAFAADMTg4ACEAAzE4OQAhAAMxOTAAEgADMTkxACUAAzE5MgAkAAMxOTMAFwADMTk0ABcAAzE5NQAkAAMxOTYAFwADMTk3ACYAAzE5OAASAAMxOTkAJwADMjAwACcAAzIwMQAoAAMyMDIAKAAIJGltcG9ydHMBcAHLAcsBCZ0CAQBBAAvLAQABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAccByAHJAcoBAC8JcHJvZHVjZXJzAQxwcm9jZXNzZWQtYnkBDXdpdC1jb21wb25lbnQHMC4yNDMuMAsBAA');
    ({ exports: exports0 } = yield instantiateCore(yield module12));
    ({ exports: exports1 } = yield instantiateCore(yield module0, {
      wasi_snapshot_preview1: {
        adapter_close_badfd: exports0['0'],
        adapter_open_badfd: exports0['1'],
        args_get: exports0['2'],
        args_sizes_get: exports0['3'],
        clock_res_get: exports0['4'],
        clock_time_get: exports0['5'],
        environ_get: exports0['6'],
        environ_sizes_get: exports0['7'],
        fd_advise: exports0['8'],
        fd_allocate: exports0['9'],
        fd_close: exports0['10'],
        fd_datasync: exports0['11'],
        fd_fdstat_get: exports0['12'],
        fd_fdstat_set_flags: exports0['13'],
        fd_fdstat_set_rights: exports0['14'],
        fd_filestat_get: exports0['15'],
        fd_filestat_set_size: exports0['16'],
        fd_filestat_set_times: exports0['17'],
        fd_pread: exports0['18'],
        fd_prestat_dir_name: exports0['19'],
        fd_prestat_get: exports0['20'],
        fd_pwrite: exports0['21'],
        fd_read: exports0['22'],
        fd_readdir: exports0['23'],
        fd_renumber: exports0['24'],
        fd_seek: exports0['25'],
        fd_sync: exports0['26'],
        fd_tell: exports0['27'],
        fd_write: exports0['28'],
        path_create_directory: exports0['29'],
        path_filestat_get: exports0['30'],
        path_filestat_set_times: exports0['31'],
        path_link: exports0['32'],
        path_open: exports0['33'],
        path_readlink: exports0['34'],
        path_remove_directory: exports0['35'],
        path_rename: exports0['36'],
        path_symlink: exports0['37'],
        path_unlink_file: exports0['38'],
        poll_oneoff: exports0['39'],
        proc_exit: exports0['40'],
        proc_raise: exports0['47'],
        random_get: exports0['41'],
        reset_adapter_state: exports0['48'],
        sched_yield: exports0['42'],
        sock_accept: exports0['43'],
        sock_recv: exports0['44'],
        sock_send: exports0['45'],
        sock_shutdown: exports0['46'],
      },
    }));
    ({ exports: exports2 } = yield instantiateCore(yield module1, {
      __main_module__: {
        cabi_realloc: exports1.cabi_realloc,
      },
      env: {
        memory: exports1.memory,
      },
      'wasi:cli/environment@0.2.0': {
        'get-arguments': exports0['89'],
        'get-environment': exports0['88'],
      },
      'wasi:cli/exit@0.2.0': {
        exit: trampoline15,
      },
      'wasi:cli/stderr@0.2.0': {
        'get-stderr': trampoline14,
      },
      'wasi:cli/stdin@0.2.0': {
        'get-stdin': trampoline16,
      },
      'wasi:cli/stdout@0.2.0': {
        'get-stdout': trampoline17,
      },
      'wasi:cli/terminal-input@0.2.0': {
        '[resource-drop]terminal-input': trampoline13,
      },
      'wasi:cli/terminal-output@0.2.0': {
        '[resource-drop]terminal-output': trampoline12,
      },
      'wasi:cli/terminal-stderr@0.2.0': {
        'get-terminal-stderr': exports0['92'],
      },
      'wasi:cli/terminal-stdin@0.2.0': {
        'get-terminal-stdin': exports0['90'],
      },
      'wasi:cli/terminal-stdout@0.2.0': {
        'get-terminal-stdout': exports0['91'],
      },
      'wasi:clocks/monotonic-clock@0.2.0': {
        now: trampoline1,
        resolution: trampoline0,
        'subscribe-duration': trampoline7,
        'subscribe-instant': trampoline8,
      },
      'wasi:clocks/wall-clock@0.2.0': {
        now: exports0['51'],
        resolution: exports0['50'],
      },
      'wasi:filesystem/preopens@0.2.0': {
        'get-directories': exports0['49'],
      },
      'wasi:filesystem/types@0.2.0': {
        '[method]descriptor.advise': exports0['52'],
        '[method]descriptor.append-via-stream': exports0['67'],
        '[method]descriptor.create-directory-at': exports0['60'],
        '[method]descriptor.get-flags': exports0['68'],
        '[method]descriptor.get-type': exports0['54'],
        '[method]descriptor.link-at': exports0['74'],
        '[method]descriptor.metadata-hash': exports0['77'],
        '[method]descriptor.metadata-hash-at': exports0['78'],
        '[method]descriptor.open-at': exports0['75'],
        '[method]descriptor.read': exports0['70'],
        '[method]descriptor.read-directory': exports0['58'],
        '[method]descriptor.read-via-stream': exports0['65'],
        '[method]descriptor.readlink-at': exports0['76'],
        '[method]descriptor.remove-directory-at': exports0['61'],
        '[method]descriptor.rename-at': exports0['62'],
        '[method]descriptor.set-size': exports0['55'],
        '[method]descriptor.set-times': exports0['69'],
        '[method]descriptor.set-times-at': exports0['73'],
        '[method]descriptor.stat': exports0['71'],
        '[method]descriptor.stat-at': exports0['72'],
        '[method]descriptor.symlink-at': exports0['63'],
        '[method]descriptor.sync': exports0['59'],
        '[method]descriptor.sync-data': exports0['53'],
        '[method]descriptor.unlink-file-at': exports0['64'],
        '[method]descriptor.write': exports0['56'],
        '[method]descriptor.write-via-stream': exports0['66'],
        '[method]directory-entry-stream.read-directory-entry': exports0['79'],
        '[resource-drop]descriptor': trampoline6,
        '[resource-drop]directory-entry-stream': trampoline2,
        'filesystem-error-code': exports0['57'],
      },
      'wasi:io/error@0.2.0': {
        '[resource-drop]error': trampoline3,
      },
      'wasi:io/poll@0.2.0': {
        '[resource-drop]pollable': trampoline11,
        poll: exports0['86'],
      },
      'wasi:io/streams@0.2.0': {
        '[method]input-stream.blocking-read': exports0['81'],
        '[method]input-stream.read': exports0['80'],
        '[method]input-stream.subscribe': trampoline10,
        '[method]output-stream.blocking-flush': exports0['85'],
        '[method]output-stream.blocking-write-and-flush': exports0['84'],
        '[method]output-stream.check-write': exports0['82'],
        '[method]output-stream.subscribe': trampoline9,
        '[method]output-stream.write': exports0['83'],
        '[resource-drop]input-stream': trampoline4,
        '[resource-drop]output-stream': trampoline5,
      },
      'wasi:random/random@0.2.0': {
        'get-random-bytes': exports0['87'],
      },
    }));
    ({ exports: exports3 } = yield instantiateCore(yield module2));
    ({ exports: exports4 } = yield instantiateCore(yield module3, {
      'GOT.func': {
        __wasilibc_find_relpath_alloc: exports1['libc.so:__wasilibc_find_relpath_alloc'],
      },
      'GOT.mem': {
        _CLOCK_REALTIME: exports1['libc.so:_CLOCK_REALTIME'],
        __heap_base: exports1.__heap_base,
        __heap_end: exports1.__heap_end,
        __optpos: exports1['libc.so:__optpos'],
        __optreset: exports1['libc.so:__optreset'],
        __signgam: exports1['libc.so:__signgam'],
        __stack_chk_guard: exports1['libc.so:__stack_chk_guard'],
        __wasi_sockets_services_db: exports1['libc.so:__wasi_sockets_services_db'],
        __wasilibc_cwd: exports1['libc.so:__wasilibc_cwd'],
        __wasilibc_environ: exports1['libc.so:__wasilibc_environ'],
        __wasilibc_pthread_self: exports1['libc.so:__wasilibc_pthread_self'],
        errno: exports1['libc.so:errno'],
        getdate_err: exports1['libc.so:getdate_err'],
        optarg: exports1['libc.so:optarg'],
        opterr: exports1['libc.so:opterr'],
        optind: exports1['libc.so:optind'],
        optopt: exports1['libc.so:optopt'],
      },
      env: {
        _IO_feof_unlocked: exports1._IO_feof_unlocked,
        _IO_ferror_unlocked: exports1._IO_ferror_unlocked,
        _IO_getc: exports1._IO_getc,
        _IO_getc_unlocked: exports1._IO_getc_unlocked,
        _IO_putc: exports1._IO_putc,
        _IO_putc_unlocked: exports1._IO_putc_unlocked,
        __freelocale: exports1.__freelocale,
        __getdelim: exports1.__getdelim,
        __indirect_function_table: exports1.__indirect_function_table,
        __isoc99_fscanf: exports1.__isoc99_fscanf,
        __isoc99_fwscanf: exports1.__isoc99_fwscanf,
        __isoc99_scanf: exports1.__isoc99_scanf,
        __isoc99_sscanf: exports1.__isoc99_sscanf,
        __isoc99_swscanf: exports1.__isoc99_swscanf,
        __isoc99_vfscanf: exports1.__isoc99_vfscanf,
        __isoc99_vfwscanf: exports1.__isoc99_vfwscanf,
        __isoc99_vscanf: exports1.__isoc99_vscanf,
        __isoc99_vsscanf: exports1.__isoc99_vsscanf,
        __isoc99_vswscanf: exports1.__isoc99_vswscanf,
        __isoc99_vwscanf: exports1.__isoc99_vwscanf,
        __isoc99_wscanf: exports1.__isoc99_wscanf,
        __main_argc_argv: exports3.__main_argc_argv,
        __main_void: exports1.__main_void,
        __memory_base: exports1['libc.so:memory_base'],
        __posix_getopt: exports1.__posix_getopt,
        __small_printf: exports1.__small_printf,
        __stack_pointer: exports1.__stack_pointer,
        __strtod_l: exports1.__strtod_l,
        __strtof_l: exports1.__strtof_l,
        __strtoimax_internal: exports1.__strtoimax_internal,
        __strtol_internal: exports1.__strtol_internal,
        __strtold_l: exports1.__strtold_l,
        __strtoll_internal: exports1.__strtoll_internal,
        __strtoul_internal: exports1.__strtoul_internal,
        __strtoull_internal: exports1.__strtoull_internal,
        __strtoumax_internal: exports1.__strtoumax_internal,
        __table_base: exports1['libc.so:table_base'],
        __wasilibc_find_relpath_alloc: exports1.__wasilibc_find_relpath_alloc,
        __xpg_basename: exports1.__xpg_basename,
        __xpg_strerror_r: exports1.__xpg_strerror_r,
        alphasort64: exports1.alphasort64,
        asctime_r: exports1.asctime_r,
        cabi_realloc: exports1.cabi_realloc,
        clearerr_unlocked: exports1.clearerr_unlocked,
        clock_gettime: exports1.clock_gettime,
        creat64: exports1.creat64,
        crypt_r: exports1.crypt_r,
        drem: exports1.drem,
        dremf: exports1.dremf,
        duplocale: exports1.duplocale,
        fdopen: exports1.fdopen,
        feof_unlocked: exports1.feof_unlocked,
        ferror_unlocked: exports1.ferror_unlocked,
        fflush_unlocked: exports1.fflush_unlocked,
        fgetc_unlocked: exports1.fgetc_unlocked,
        fgetpos64: exports1.fgetpos64,
        fgets_unlocked: exports1.fgets_unlocked,
        fgetwc_unlocked: exports1.fgetwc_unlocked,
        fgetws_unlocked: exports1.fgetws_unlocked,
        fileno_unlocked: exports1.fileno_unlocked,
        fopen64: exports1.fopen64,
        fpurge: exports1.fpurge,
        fputc_unlocked: exports1.fputc_unlocked,
        fputs_unlocked: exports1.fputs_unlocked,
        fputwc_unlocked: exports1.fputwc_unlocked,
        fputws_unlocked: exports1.fputws_unlocked,
        fread_unlocked: exports1.fread_unlocked,
        freopen64: exports1.freopen64,
        fseeko: exports1.fseeko,
        fseeko64: exports1.fseeko64,
        fsetpos64: exports1.fsetpos64,
        ftello: exports1.ftello,
        ftello64: exports1.ftello64,
        futimesat: exports1.futimesat,
        fwrite_unlocked: exports1.fwrite_unlocked,
        getentropy: exports1.getentropy,
        getwc_unlocked: exports1.getwc_unlocked,
        getwchar_unlocked: exports1.getwchar_unlocked,
        glob64: exports1.glob64,
        globfree64: exports1.globfree64,
        gmtime_r: exports1.gmtime_r,
        hcreate_r: exports1.hcreate_r,
        hdestroy_r: exports1.hdestroy_r,
        hsearch_r: exports1.hsearch_r,
        inet_aton: exports1.inet_aton,
        iprintf: exports1.iprintf,
        isalnum_l: exports1.isalnum_l,
        isalpha_l: exports1.isalpha_l,
        isatty: exports1.isatty,
        isblank_l: exports1.isblank_l,
        iscntrl_l: exports1.iscntrl_l,
        isdigit_l: exports1.isdigit_l,
        isgraph_l: exports1.isgraph_l,
        islower_l: exports1.islower_l,
        isprint_l: exports1.isprint_l,
        ispunct_l: exports1.ispunct_l,
        isspace_l: exports1.isspace_l,
        isupper_l: exports1.isupper_l,
        iswalnum_l: exports1.iswalnum_l,
        iswalpha_l: exports1.iswalpha_l,
        iswblank_l: exports1.iswblank_l,
        iswcntrl_l: exports1.iswcntrl_l,
        iswctype_l: exports1.iswctype_l,
        iswdigit_l: exports1.iswdigit_l,
        iswgraph_l: exports1.iswgraph_l,
        iswlower_l: exports1.iswlower_l,
        iswprint_l: exports1.iswprint_l,
        iswpunct_l: exports1.iswpunct_l,
        iswspace_l: exports1.iswspace_l,
        iswupper_l: exports1.iswupper_l,
        iswxdigit_l: exports1.iswxdigit_l,
        isxdigit_l: exports1.isxdigit_l,
        lgamma_r: exports1.lgamma_r,
        lgammaf_r: exports1.lgammaf_r,
        lgammal_r: exports1.lgammal_r,
        localtime_r: exports1.localtime_r,
        lseek: exports1.lseek,
        memory: exports1.memory,
        memrchr: exports1.memrchr,
        newlocale: exports1.newlocale,
        nftw64: exports1.nftw64,
        nl_langinfo: exports1.nl_langinfo,
        nl_langinfo_l: exports1.nl_langinfo_l,
        pow10: exports1.pow10,
        pow10f: exports1.pow10f,
        pow10l: exports1.pow10l,
        pthread_cond_timedwait: exports1.pthread_cond_timedwait,
        pthread_create: exports1.pthread_create,
        pthread_detach: exports1.pthread_detach,
        pthread_equal: exports1.pthread_equal,
        pthread_getspecific: exports1.pthread_getspecific,
        pthread_join: exports1.pthread_join,
        pthread_key_create: exports1.pthread_key_create,
        pthread_key_delete: exports1.pthread_key_delete,
        pthread_mutex_lock: exports1.pthread_mutex_lock,
        pthread_mutex_timedlock: exports1.pthread_mutex_timedlock,
        pthread_mutex_trylock: exports1.pthread_mutex_trylock,
        pthread_mutex_unlock: exports1.pthread_mutex_unlock,
        pthread_once: exports1.pthread_once,
        pthread_rwlock_rdlock: exports1.pthread_rwlock_rdlock,
        pthread_rwlock_timedrdlock: exports1.pthread_rwlock_timedrdlock,
        pthread_rwlock_timedwrlock: exports1.pthread_rwlock_timedwrlock,
        pthread_rwlock_tryrdlock: exports1.pthread_rwlock_tryrdlock,
        pthread_rwlock_trywrlock: exports1.pthread_rwlock_trywrlock,
        pthread_rwlock_unlock: exports1.pthread_rwlock_unlock,
        pthread_rwlock_wrlock: exports1.pthread_rwlock_wrlock,
        pthread_self: exports1.pthread_self,
        pthread_setcancelstate: exports1.pthread_setcancelstate,
        pthread_testcancel: exports1.pthread_testcancel,
        pthread_timedjoin_np: exports1.pthread_timedjoin_np,
        pthread_tryjoin_np: exports1.pthread_tryjoin_np,
        putwc_unlocked: exports1.putwc_unlocked,
        putwchar_unlocked: exports1.putwchar_unlocked,
        qsort_r: exports1.qsort_r,
        reallocarray: exports1.reallocarray,
        stpcpy: exports1.stpcpy,
        stpncpy: exports1.stpncpy,
        strcasecmp_l: exports1.strcasecmp_l,
        strchrnul: exports1.strchrnul,
        strcoll_l: exports1.strcoll_l,
        strerror_l: exports1.strerror_l,
        strftime_l: exports1.strftime_l,
        strncasecmp_l: exports1.strncasecmp_l,
        strxfrm_l: exports1.strxfrm_l,
        thrd_current: exports1.thrd_current,
        thrd_detach: exports1.thrd_detach,
        thrd_equal: exports1.thrd_equal,
        tolower_l: exports1.tolower_l,
        toupper_l: exports1.toupper_l,
        towctrans_l: exports1.towctrans_l,
        towlower_l: exports1.towlower_l,
        towupper_l: exports1.towupper_l,
        tss_get: exports1.tss_get,
        uselocale: exports1.uselocale,
        versionsort64: exports1.versionsort64,
        wcscoll_l: exports1.wcscoll_l,
        wcsftime_l: exports1.wcsftime_l,
        wcsxfrm_l: exports1.wcsxfrm_l,
        wctrans_l: exports1.wctrans_l,
        wctype_l: exports1.wctype_l,
      },
      'wasi:cli/environment@0.2.0': {
        'get-arguments': exports0['178'],
        'get-environment': exports0['177'],
        'initial-cwd': exports0['179'],
      },
      'wasi:cli/exit@0.2.0': {
        exit: trampoline15,
      },
      'wasi:cli/stderr@0.2.0': {
        'get-stderr': trampoline14,
      },
      'wasi:cli/stdin@0.2.0': {
        'get-stdin': trampoline16,
      },
      'wasi:cli/stdout@0.2.0': {
        'get-stdout': trampoline17,
      },
      'wasi:cli/terminal-input@0.2.0': {
        '[resource-drop]terminal-input': trampoline13,
      },
      'wasi:cli/terminal-output@0.2.0': {
        '[resource-drop]terminal-output': trampoline12,
      },
      'wasi:cli/terminal-stderr@0.2.0': {
        'get-terminal-stderr': exports0['182'],
      },
      'wasi:cli/terminal-stdin@0.2.0': {
        'get-terminal-stdin': exports0['180'],
      },
      'wasi:cli/terminal-stdout@0.2.0': {
        'get-terminal-stdout': exports0['181'],
      },
      'wasi:clocks/monotonic-clock@0.2.0': {
        now: trampoline1,
        resolution: trampoline0,
        'subscribe-duration': trampoline7,
        'subscribe-instant': trampoline8,
      },
      'wasi:clocks/wall-clock@0.2.0': {
        now: exports0['183'],
        resolution: exports0['184'],
      },
      'wasi:filesystem/preopens@0.2.0': {
        'get-directories': exports0['185'],
      },
      'wasi:filesystem/types@0.2.0': {
        '[method]descriptor.advise': exports0['111'],
        '[method]descriptor.append-via-stream': exports0['110'],
        '[method]descriptor.create-directory-at': exports0['121'],
        '[method]descriptor.get-flags': exports0['113'],
        '[method]descriptor.get-type': exports0['114'],
        '[method]descriptor.is-same-object': trampoline26,
        '[method]descriptor.link-at': exports0['125'],
        '[method]descriptor.metadata-hash': exports0['132'],
        '[method]descriptor.metadata-hash-at': exports0['133'],
        '[method]descriptor.open-at': exports0['126'],
        '[method]descriptor.read': exports0['117'],
        '[method]descriptor.read-directory': exports0['119'],
        '[method]descriptor.read-via-stream': exports0['108'],
        '[method]descriptor.readlink-at': exports0['127'],
        '[method]descriptor.remove-directory-at': exports0['128'],
        '[method]descriptor.rename-at': exports0['129'],
        '[method]descriptor.set-size': exports0['115'],
        '[method]descriptor.set-times': exports0['116'],
        '[method]descriptor.set-times-at': exports0['124'],
        '[method]descriptor.stat': exports0['122'],
        '[method]descriptor.stat-at': exports0['123'],
        '[method]descriptor.symlink-at': exports0['130'],
        '[method]descriptor.sync': exports0['120'],
        '[method]descriptor.sync-data': exports0['112'],
        '[method]descriptor.unlink-file-at': exports0['131'],
        '[method]descriptor.write': exports0['118'],
        '[method]descriptor.write-via-stream': exports0['109'],
        '[method]directory-entry-stream.read-directory-entry': exports0['134'],
        '[resource-drop]descriptor': trampoline6,
        '[resource-drop]directory-entry-stream': trampoline2,
        'filesystem-error-code': exports0['135'],
      },
      'wasi:io/error@0.2.0': {
        '[method]error.to-debug-string': exports0['93'],
        '[resource-drop]error': trampoline3,
      },
      'wasi:io/poll@0.2.0': {
        '[method]pollable.block': trampoline25,
        '[method]pollable.ready': trampoline24,
        '[resource-drop]pollable': trampoline11,
        poll: exports0['94'],
      },
      'wasi:io/streams@0.2.0': {
        '[method]input-stream.blocking-read': exports0['96'],
        '[method]input-stream.blocking-skip': exports0['98'],
        '[method]input-stream.read': exports0['95'],
        '[method]input-stream.skip': exports0['97'],
        '[method]input-stream.subscribe': trampoline10,
        '[method]output-stream.blocking-flush': exports0['103'],
        '[method]output-stream.blocking-splice': exports0['107'],
        '[method]output-stream.blocking-write-and-flush': exports0['101'],
        '[method]output-stream.blocking-write-zeroes-and-flush': exports0['105'],
        '[method]output-stream.check-write': exports0['99'],
        '[method]output-stream.flush': exports0['102'],
        '[method]output-stream.splice': exports0['106'],
        '[method]output-stream.subscribe': trampoline9,
        '[method]output-stream.write': exports0['100'],
        '[method]output-stream.write-zeroes': exports0['104'],
        '[resource-drop]input-stream': trampoline4,
        '[resource-drop]output-stream': trampoline5,
      },
      'wasi:random/insecure-seed@0.2.0': {
        'insecure-seed': exports0['190'],
      },
      'wasi:random/insecure@0.2.0': {
        'get-insecure-random-bytes': exports0['189'],
        'get-insecure-random-u64': trampoline37,
      },
      'wasi:random/random@0.2.0': {
        'get-random-bytes': exports0['188'],
        'get-random-u64': trampoline36,
      },
      'wasi:sockets/instance-network@0.2.0': {
        'instance-network': trampoline27,
      },
      'wasi:sockets/ip-name-lookup@0.2.0': {
        '[method]resolve-address-stream.resolve-next-address': exports0['176'],
        '[method]resolve-address-stream.subscribe': trampoline35,
        '[resource-drop]resolve-address-stream': trampoline23,
        'resolve-addresses': exports0['175'],
      },
      'wasi:sockets/network@0.2.0': {
        '[resource-drop]network': trampoline18,
      },
      'wasi:sockets/tcp-create-socket@0.2.0': {
        'create-tcp-socket': exports0['187'],
      },
      'wasi:sockets/tcp@0.2.0': {
        '[method]tcp-socket.accept': exports0['156'],
        '[method]tcp-socket.address-family': trampoline33,
        '[method]tcp-socket.finish-bind': exports0['151'],
        '[method]tcp-socket.finish-connect': exports0['153'],
        '[method]tcp-socket.finish-listen': exports0['155'],
        '[method]tcp-socket.hop-limit': exports0['168'],
        '[method]tcp-socket.is-listening': trampoline32,
        '[method]tcp-socket.keep-alive-count': exports0['166'],
        '[method]tcp-socket.keep-alive-enabled': exports0['160'],
        '[method]tcp-socket.keep-alive-idle-time': exports0['162'],
        '[method]tcp-socket.keep-alive-interval': exports0['164'],
        '[method]tcp-socket.local-address': exports0['157'],
        '[method]tcp-socket.receive-buffer-size': exports0['170'],
        '[method]tcp-socket.remote-address': exports0['158'],
        '[method]tcp-socket.send-buffer-size': exports0['172'],
        '[method]tcp-socket.set-hop-limit': exports0['169'],
        '[method]tcp-socket.set-keep-alive-count': exports0['167'],
        '[method]tcp-socket.set-keep-alive-enabled': exports0['161'],
        '[method]tcp-socket.set-keep-alive-idle-time': exports0['163'],
        '[method]tcp-socket.set-keep-alive-interval': exports0['165'],
        '[method]tcp-socket.set-listen-backlog-size': exports0['159'],
        '[method]tcp-socket.set-receive-buffer-size': exports0['171'],
        '[method]tcp-socket.set-send-buffer-size': exports0['173'],
        '[method]tcp-socket.shutdown': exports0['174'],
        '[method]tcp-socket.start-bind': exports0['150'],
        '[method]tcp-socket.start-connect': exports0['152'],
        '[method]tcp-socket.start-listen': exports0['154'],
        '[method]tcp-socket.subscribe': trampoline34,
        '[resource-drop]tcp-socket': trampoline22,
      },
      'wasi:sockets/udp-create-socket@0.2.0': {
        'create-udp-socket': exports0['186'],
      },
      'wasi:sockets/udp@0.2.0': {
        '[method]incoming-datagram-stream.receive': exports0['147'],
        '[method]incoming-datagram-stream.subscribe': trampoline30,
        '[method]outgoing-datagram-stream.check-send': exports0['148'],
        '[method]outgoing-datagram-stream.send': exports0['149'],
        '[method]outgoing-datagram-stream.subscribe': trampoline31,
        '[method]udp-socket.address-family': trampoline28,
        '[method]udp-socket.finish-bind': exports0['137'],
        '[method]udp-socket.local-address': exports0['139'],
        '[method]udp-socket.receive-buffer-size': exports0['143'],
        '[method]udp-socket.remote-address': exports0['140'],
        '[method]udp-socket.send-buffer-size': exports0['145'],
        '[method]udp-socket.set-receive-buffer-size': exports0['144'],
        '[method]udp-socket.set-send-buffer-size': exports0['146'],
        '[method]udp-socket.set-unicast-hop-limit': exports0['142'],
        '[method]udp-socket.start-bind': exports0['136'],
        '[method]udp-socket.stream': exports0['138'],
        '[method]udp-socket.subscribe': trampoline29,
        '[method]udp-socket.unicast-hop-limit': exports0['141'],
        '[resource-drop]incoming-datagram-stream': trampoline20,
        '[resource-drop]outgoing-datagram-stream': trampoline21,
        '[resource-drop]udp-socket': trampoline19,
      },
      wasi_snapshot_preview1: {
        adapter_close_badfd: exports1['wasi_snapshot_preview1:adapter_close_badfd'],
        adapter_open_badfd: exports1['wasi_snapshot_preview1:adapter_open_badfd'],
        args_get: exports1['wasi_snapshot_preview1:args_get'],
        args_sizes_get: exports1['wasi_snapshot_preview1:args_sizes_get'],
        clock_res_get: exports1['wasi_snapshot_preview1:clock_res_get'],
        clock_time_get: exports1['wasi_snapshot_preview1:clock_time_get'],
        environ_get: exports1['wasi_snapshot_preview1:environ_get'],
        environ_sizes_get: exports1['wasi_snapshot_preview1:environ_sizes_get'],
        fd_advise: exports1['wasi_snapshot_preview1:fd_advise'],
        fd_allocate: exports1['wasi_snapshot_preview1:fd_allocate'],
        fd_close: exports1['wasi_snapshot_preview1:fd_close'],
        fd_datasync: exports1['wasi_snapshot_preview1:fd_datasync'],
        fd_fdstat_get: exports1['wasi_snapshot_preview1:fd_fdstat_get'],
        fd_fdstat_set_flags: exports1['wasi_snapshot_preview1:fd_fdstat_set_flags'],
        fd_fdstat_set_rights: exports1['wasi_snapshot_preview1:fd_fdstat_set_rights'],
        fd_filestat_get: exports1['wasi_snapshot_preview1:fd_filestat_get'],
        fd_filestat_set_size: exports1['wasi_snapshot_preview1:fd_filestat_set_size'],
        fd_filestat_set_times: exports1['wasi_snapshot_preview1:fd_filestat_set_times'],
        fd_pread: exports1['wasi_snapshot_preview1:fd_pread'],
        fd_prestat_dir_name: exports1['wasi_snapshot_preview1:fd_prestat_dir_name'],
        fd_prestat_get: exports1['wasi_snapshot_preview1:fd_prestat_get'],
        fd_pwrite: exports1['wasi_snapshot_preview1:fd_pwrite'],
        fd_read: exports1['wasi_snapshot_preview1:fd_read'],
        fd_readdir: exports1['wasi_snapshot_preview1:fd_readdir'],
        fd_renumber: exports1['wasi_snapshot_preview1:fd_renumber'],
        fd_seek: exports1['wasi_snapshot_preview1:fd_seek'],
        fd_sync: exports1['wasi_snapshot_preview1:fd_sync'],
        fd_tell: exports1['wasi_snapshot_preview1:fd_tell'],
        fd_write: exports1['wasi_snapshot_preview1:fd_write'],
        path_create_directory: exports1['wasi_snapshot_preview1:path_create_directory'],
        path_filestat_get: exports1['wasi_snapshot_preview1:path_filestat_get'],
        path_filestat_set_times: exports1['wasi_snapshot_preview1:path_filestat_set_times'],
        path_link: exports1['wasi_snapshot_preview1:path_link'],
        path_open: exports1['wasi_snapshot_preview1:path_open'],
        path_readlink: exports1['wasi_snapshot_preview1:path_readlink'],
        path_remove_directory: exports1['wasi_snapshot_preview1:path_remove_directory'],
        path_rename: exports1['wasi_snapshot_preview1:path_rename'],
        path_symlink: exports1['wasi_snapshot_preview1:path_symlink'],
        path_unlink_file: exports1['wasi_snapshot_preview1:path_unlink_file'],
        poll_oneoff: exports1['wasi_snapshot_preview1:poll_oneoff'],
        proc_exit: exports1['wasi_snapshot_preview1:proc_exit'],
        random_get: exports1['wasi_snapshot_preview1:random_get'],
        sched_yield: exports1['wasi_snapshot_preview1:sched_yield'],
        sock_accept: exports1['wasi_snapshot_preview1:sock_accept'],
        sock_recv: exports1['wasi_snapshot_preview1:sock_recv'],
        sock_send: exports1['wasi_snapshot_preview1:sock_send'],
        sock_shutdown: exports1['wasi_snapshot_preview1:sock_shutdown'],
      },
    }));
    ({ exports: exports5 } = yield instantiateCore(yield module4, {
      'GOT.mem': {
        errno: exports1['libwasi-emulated-process-clocks.so:errno'],
      },
      env: {
        __indirect_function_table: exports1.__indirect_function_table,
        __memory_base: exports1['libwasi-emulated-process-clocks.so:memory_base'],
        __stack_pointer: exports1.__stack_pointer,
        __table_base: exports1['libwasi-emulated-process-clocks.so:table_base'],
        __wasi_clock_time_get: exports4.__wasi_clock_time_get,
        clock: exports1.clock,
        memory: exports1.memory,
      },
    }));
    ({ exports: exports6 } = yield instantiateCore(yield module5, {
      'GOT.func': {
        __SIG_ERR: exports1['libwasi-emulated-signal.so:__SIG_ERR'],
        __SIG_IGN: exports1['libwasi-emulated-signal.so:__SIG_IGN'],
      },
      'GOT.mem': {
        errno: exports1['libwasi-emulated-signal.so:errno'],
        stderr: exports1['libwasi-emulated-signal.so:stderr'],
      },
      env: {
        __indirect_function_table: exports1.__indirect_function_table,
        __lctrans_cur: exports4.__lctrans_cur,
        __memory_base: exports1['libwasi-emulated-signal.so:memory_base'],
        __stack_pointer: exports1.__stack_pointer,
        __sysv_signal: exports1.__sysv_signal,
        __table_base: exports1['libwasi-emulated-signal.so:table_base'],
        abort: exports4.abort,
        bsd_signal: exports1.bsd_signal,
        fprintf: exports4.fprintf,
        memory: exports1.memory,
      },
    }));
    ({ exports: exports7 } = yield instantiateCore(yield module6, {
      env: {
        __indirect_function_table: exports1.__indirect_function_table,
        __memory_base: exports1['libwasi-emulated-getpid.so:memory_base'],
        __table_base: exports1['libwasi-emulated-getpid.so:table_base'],
        memory: exports1.memory,
      },
    }));
    ({ exports: exports8 } = yield instantiateCore(yield module7, {
      env: {
        __indirect_function_table: exports1.__indirect_function_table,
        __memory_base: exports1['libdl.so:memory_base'],
        __table_base: exports1['libdl.so:table_base'],
        memcmp: exports4.memcmp,
        memory: exports1.memory,
        strlen: exports4.strlen,
      },
    }));
    ({ exports: exports9 } = yield instantiateCore(yield module8, {
      'GOT.func': {
        PyByteArray_Concat: exports1['libpython3.14.so:PyByteArray_Concat'],
        PyDict_Contains: exports1['libpython3.14.so:PyDict_Contains'],
        PyInit__abc: exports1['libpython3.14.so:PyInit__abc'],
        PyInit__ast: exports1['libpython3.14.so:PyInit__ast'],
        PyInit__asyncio: exports1['libpython3.14.so:PyInit__asyncio'],
        PyInit__bisect: exports1['libpython3.14.so:PyInit__bisect'],
        PyInit__blake2: exports1['libpython3.14.so:PyInit__blake2'],
        PyInit__codecs: exports1['libpython3.14.so:PyInit__codecs'],
        PyInit__codecs_cn: exports1['libpython3.14.so:PyInit__codecs_cn'],
        PyInit__codecs_hk: exports1['libpython3.14.so:PyInit__codecs_hk'],
        PyInit__codecs_iso2022: exports1['libpython3.14.so:PyInit__codecs_iso2022'],
        PyInit__codecs_jp: exports1['libpython3.14.so:PyInit__codecs_jp'],
        PyInit__codecs_kr: exports1['libpython3.14.so:PyInit__codecs_kr'],
        PyInit__codecs_tw: exports1['libpython3.14.so:PyInit__codecs_tw'],
        PyInit__collections: exports1['libpython3.14.so:PyInit__collections'],
        PyInit__contextvars: exports1['libpython3.14.so:PyInit__contextvars'],
        PyInit__csv: exports1['libpython3.14.so:PyInit__csv'],
        PyInit__datetime: exports1['libpython3.14.so:PyInit__datetime'],
        PyInit__decimal: exports1['libpython3.14.so:PyInit__decimal'],
        PyInit__elementtree: exports1['libpython3.14.so:PyInit__elementtree'],
        PyInit__functools: exports1['libpython3.14.so:PyInit__functools'],
        PyInit__heapq: exports1['libpython3.14.so:PyInit__heapq'],
        PyInit__hmac: exports1['libpython3.14.so:PyInit__hmac'],
        PyInit__imp: exports1['libpython3.14.so:PyInit__imp'],
        PyInit__io: exports1['libpython3.14.so:PyInit__io'],
        PyInit__json: exports1['libpython3.14.so:PyInit__json'],
        PyInit__locale: exports1['libpython3.14.so:PyInit__locale'],
        PyInit__lsprof: exports1['libpython3.14.so:PyInit__lsprof'],
        PyInit__md5: exports1['libpython3.14.so:PyInit__md5'],
        PyInit__multibytecodec: exports1['libpython3.14.so:PyInit__multibytecodec'],
        PyInit__opcode: exports1['libpython3.14.so:PyInit__opcode'],
        PyInit__operator: exports1['libpython3.14.so:PyInit__operator'],
        PyInit__pickle: exports1['libpython3.14.so:PyInit__pickle'],
        PyInit__queue: exports1['libpython3.14.so:PyInit__queue'],
        PyInit__random: exports1['libpython3.14.so:PyInit__random'],
        PyInit__sha1: exports1['libpython3.14.so:PyInit__sha1'],
        PyInit__sha2: exports1['libpython3.14.so:PyInit__sha2'],
        PyInit__sha3: exports1['libpython3.14.so:PyInit__sha3'],
        PyInit__signal: exports1['libpython3.14.so:PyInit__signal'],
        PyInit__socket: exports1['libpython3.14.so:PyInit__socket'],
        PyInit__sqlite3: exports1['libpython3.14.so:PyInit__sqlite3'],
        PyInit__sre: exports1['libpython3.14.so:PyInit__sre'],
        PyInit__stat: exports1['libpython3.14.so:PyInit__stat'],
        PyInit__statistics: exports1['libpython3.14.so:PyInit__statistics'],
        PyInit__string: exports1['libpython3.14.so:PyInit__string'],
        PyInit__struct: exports1['libpython3.14.so:PyInit__struct'],
        PyInit__suggestions: exports1['libpython3.14.so:PyInit__suggestions'],
        PyInit__symtable: exports1['libpython3.14.so:PyInit__symtable'],
        PyInit__sysconfig: exports1['libpython3.14.so:PyInit__sysconfig'],
        PyInit__thread: exports1['libpython3.14.so:PyInit__thread'],
        PyInit__tokenize: exports1['libpython3.14.so:PyInit__tokenize'],
        PyInit__tracemalloc: exports1['libpython3.14.so:PyInit__tracemalloc'],
        PyInit__types: exports1['libpython3.14.so:PyInit__types'],
        PyInit__typing: exports1['libpython3.14.so:PyInit__typing'],
        PyInit__weakref: exports1['libpython3.14.so:PyInit__weakref'],
        PyInit__zoneinfo: exports1['libpython3.14.so:PyInit__zoneinfo'],
        PyInit_array: exports1['libpython3.14.so:PyInit_array'],
        PyInit_atexit: exports1['libpython3.14.so:PyInit_atexit'],
        PyInit_binascii: exports1['libpython3.14.so:PyInit_binascii'],
        PyInit_cmath: exports1['libpython3.14.so:PyInit_cmath'],
        PyInit_errno: exports1['libpython3.14.so:PyInit_errno'],
        PyInit_faulthandler: exports1['libpython3.14.so:PyInit_faulthandler'],
        PyInit_gc: exports1['libpython3.14.so:PyInit_gc'],
        PyInit_itertools: exports1['libpython3.14.so:PyInit_itertools'],
        PyInit_math: exports1['libpython3.14.so:PyInit_math'],
        PyInit_posix: exports1['libpython3.14.so:PyInit_posix'],
        PyInit_pyexpat: exports1['libpython3.14.so:PyInit_pyexpat'],
        PyInit_select: exports1['libpython3.14.so:PyInit_select'],
        PyInit_time: exports1['libpython3.14.so:PyInit_time'],
        PyInit_unicodedata: exports1['libpython3.14.so:PyInit_unicodedata'],
        PyInit_zlib: exports1['libpython3.14.so:PyInit_zlib'],
        PyMarshal_Init: exports1['libpython3.14.so:PyMarshal_Init'],
        PyMem_Free: exports1['libpython3.14.so:PyMem_Free'],
        PyMem_Malloc: exports1['libpython3.14.so:PyMem_Malloc'],
        PyMem_RawFree: exports1['libpython3.14.so:PyMem_RawFree'],
        PyMem_RawMalloc: exports1['libpython3.14.so:PyMem_RawMalloc'],
        PyMem_Realloc: exports1['libpython3.14.so:PyMem_Realloc'],
        PyNumber_Add: exports1['libpython3.14.so:PyNumber_Add'],
        PyNumber_And: exports1['libpython3.14.so:PyNumber_And'],
        PyNumber_FloorDivide: exports1['libpython3.14.so:PyNumber_FloorDivide'],
        PyNumber_InPlaceAdd: exports1['libpython3.14.so:PyNumber_InPlaceAdd'],
        PyNumber_InPlaceAnd: exports1['libpython3.14.so:PyNumber_InPlaceAnd'],
        PyNumber_InPlaceFloorDivide: exports1['libpython3.14.so:PyNumber_InPlaceFloorDivide'],
        PyNumber_InPlaceLshift: exports1['libpython3.14.so:PyNumber_InPlaceLshift'],
        PyNumber_InPlaceMatrixMultiply: exports1['libpython3.14.so:PyNumber_InPlaceMatrixMultiply'],
        PyNumber_InPlaceMultiply: exports1['libpython3.14.so:PyNumber_InPlaceMultiply'],
        PyNumber_InPlaceOr: exports1['libpython3.14.so:PyNumber_InPlaceOr'],
        PyNumber_InPlaceRemainder: exports1['libpython3.14.so:PyNumber_InPlaceRemainder'],
        PyNumber_InPlaceRshift: exports1['libpython3.14.so:PyNumber_InPlaceRshift'],
        PyNumber_InPlaceSubtract: exports1['libpython3.14.so:PyNumber_InPlaceSubtract'],
        PyNumber_InPlaceTrueDivide: exports1['libpython3.14.so:PyNumber_InPlaceTrueDivide'],
        PyNumber_InPlaceXor: exports1['libpython3.14.so:PyNumber_InPlaceXor'],
        PyNumber_Lshift: exports1['libpython3.14.so:PyNumber_Lshift'],
        PyNumber_MatrixMultiply: exports1['libpython3.14.so:PyNumber_MatrixMultiply'],
        PyNumber_Multiply: exports1['libpython3.14.so:PyNumber_Multiply'],
        PyNumber_Or: exports1['libpython3.14.so:PyNumber_Or'],
        PyNumber_Remainder: exports1['libpython3.14.so:PyNumber_Remainder'],
        PyNumber_Rshift: exports1['libpython3.14.so:PyNumber_Rshift'],
        PyNumber_Subtract: exports1['libpython3.14.so:PyNumber_Subtract'],
        PyNumber_TrueDivide: exports1['libpython3.14.so:PyNumber_TrueDivide'],
        PyNumber_Xor: exports1['libpython3.14.so:PyNumber_Xor'],
        PyObject_ASCII: exports1['libpython3.14.so:PyObject_ASCII'],
        PyObject_Free: exports1['libpython3.14.so:PyObject_Free'],
        PyObject_GC_Del: exports1['libpython3.14.so:PyObject_GC_Del'],
        PyObject_GenericGetAttr: exports1['libpython3.14.so:PyObject_GenericGetAttr'],
        PyObject_GenericGetDict: exports1['libpython3.14.so:PyObject_GenericGetDict'],
        PyObject_GenericHash: exports1['libpython3.14.so:PyObject_GenericHash'],
        PyObject_GenericSetAttr: exports1['libpython3.14.so:PyObject_GenericSetAttr'],
        PyObject_GenericSetDict: exports1['libpython3.14.so:PyObject_GenericSetDict'],
        PyObject_GetItem: exports1['libpython3.14.so:PyObject_GetItem'],
        PyObject_HashNotImplemented: exports1['libpython3.14.so:PyObject_HashNotImplemented'],
        PyObject_Repr: exports1['libpython3.14.so:PyObject_Repr'],
        PyObject_SelfIter: exports1['libpython3.14.so:PyObject_SelfIter'],
        PyObject_Str: exports1['libpython3.14.so:PyObject_Str'],
        PyType_GenericAlloc: exports1['libpython3.14.so:PyType_GenericAlloc'],
        PyType_GenericNew: exports1['libpython3.14.so:PyType_GenericNew'],
        PyUnicode_AsASCIIString: exports1['libpython3.14.so:PyUnicode_AsASCIIString'],
        PyUnicode_AsUTF8String: exports1['libpython3.14.so:PyUnicode_AsUTF8String'],
        PyUnicode_Concat: exports1['libpython3.14.so:PyUnicode_Concat'],
        PyUnicode_Contains: exports1['libpython3.14.so:PyUnicode_Contains'],
        PyUnicode_RichCompare: exports1['libpython3.14.so:PyUnicode_RichCompare'],
        PyVectorcall_Call: exports1['libpython3.14.so:PyVectorcall_Call'],
        Py_GenericAlias: exports1['libpython3.14.so:Py_GenericAlias'],
        _PyBytes_FromXIData: exports1['libpython3.14.so:_PyBytes_FromXIData'],
        _PyBytes_GetXIData: exports1['libpython3.14.so:_PyBytes_GetXIData'],
        _PyCode_FromXIData: exports1['libpython3.14.so:_PyCode_FromXIData'],
        _PyEval_EvalFrameDefault: exports1['libpython3.14.so:_PyEval_EvalFrameDefault'],
        _PyFunction_FromXIData: exports1['libpython3.14.so:_PyFunction_FromXIData'],
        _PyMarshal_ReadObjectFromXIData: exports1['libpython3.14.so:_PyMarshal_ReadObjectFromXIData'],
        _PyPickle_LoadFromXIData: exports1['libpython3.14.so:_PyPickle_LoadFromXIData'],
        _PyTime_gmtime: exports1['libpython3.14.so:_PyTime_gmtime'],
        _PyTime_localtime: exports1['libpython3.14.so:_PyTime_localtime'],
        _PyWarnings_Init: exports1['libpython3.14.so:_PyWarnings_Init'],
        _Py_hashtable_compare_direct: exports1['libpython3.14.so:_Py_hashtable_compare_direct'],
        _Py_hashtable_hash_ptr: exports1['libpython3.14.so:_Py_hashtable_hash_ptr'],
        _Py_union_type_or: exports1['libpython3.14.so:_Py_union_type_or'],
        __SIG_ERR: exports1['libpython3.14.so:__SIG_ERR'],
        __SIG_IGN: exports1['libpython3.14.so:__SIG_IGN'],
        access: exports1['libpython3.14.so:access'],
        acos: exports1['libpython3.14.so:acos'],
        acosh: exports1['libpython3.14.so:acosh'],
        asin: exports1['libpython3.14.so:asin'],
        asinh: exports1['libpython3.14.so:asinh'],
        atan: exports1['libpython3.14.so:atan'],
        atan2: exports1['libpython3.14.so:atan2'],
        atanh: exports1['libpython3.14.so:atanh'],
        calloc: exports1['libpython3.14.so:calloc'],
        close: exports1['libpython3.14.so:close'],
        copysign: exports1['libpython3.14.so:copysign'],
        cos: exports1['libpython3.14.so:cos'],
        cosh: exports1['libpython3.14.so:cosh'],
        exp: exports1['libpython3.14.so:exp'],
        exp2: exports1['libpython3.14.so:exp2'],
        fabs: exports1['libpython3.14.so:fabs'],
        fcntl: exports1['libpython3.14.so:fcntl'],
        fmod: exports1['libpython3.14.so:fmod'],
        free: exports1['libpython3.14.so:free'],
        fstat: exports1['libpython3.14.so:fstat'],
        ftruncate: exports1['libpython3.14.so:ftruncate'],
        getcwd: exports1['libpython3.14.so:getcwd'],
        lstat: exports1['libpython3.14.so:lstat'],
        malloc: exports1['libpython3.14.so:malloc'],
        mkdir: exports1['libpython3.14.so:mkdir'],
        pow: exports1['libpython3.14.so:pow'],
        read: exports1['libpython3.14.so:read'],
        readlink: exports1['libpython3.14.so:readlink'],
        realloc: exports1['libpython3.14.so:realloc'],
        rmdir: exports1['libpython3.14.so:rmdir'],
        sin: exports1['libpython3.14.so:sin'],
        sinh: exports1['libpython3.14.so:sinh'],
        sqrt: exports1['libpython3.14.so:sqrt'],
        stat: exports1['libpython3.14.so:stat'],
        tan: exports1['libpython3.14.so:tan'],
        tanh: exports1['libpython3.14.so:tanh'],
        trunc: exports1['libpython3.14.so:trunc'],
        unlink: exports1['libpython3.14.so:unlink'],
        write: exports1['libpython3.14.so:write'],
      },
      'GOT.mem': {
        PY_TIMEOUT_MAX: exports1['libpython3.14.so:PY_TIMEOUT_MAX'],
        PyAsyncGen_Type: exports1['libpython3.14.so:PyAsyncGen_Type'],
        PyBaseObject_Type: exports1['libpython3.14.so:PyBaseObject_Type'],
        PyBool_Type: exports1['libpython3.14.so:PyBool_Type'],
        PyByteArrayIter_Type: exports1['libpython3.14.so:PyByteArrayIter_Type'],
        PyByteArray_Type: exports1['libpython3.14.so:PyByteArray_Type'],
        PyBytesIter_Type: exports1['libpython3.14.so:PyBytesIter_Type'],
        PyBytes_Type: exports1['libpython3.14.so:PyBytes_Type'],
        PyCFunction_Type: exports1['libpython3.14.so:PyCFunction_Type'],
        PyCMethod_Type: exports1['libpython3.14.so:PyCMethod_Type'],
        PyCallIter_Type: exports1['libpython3.14.so:PyCallIter_Type'],
        PyCapsule_Type: exports1['libpython3.14.so:PyCapsule_Type'],
        PyCell_Type: exports1['libpython3.14.so:PyCell_Type'],
        PyClassMethodDescr_Type: exports1['libpython3.14.so:PyClassMethodDescr_Type'],
        PyClassMethod_Type: exports1['libpython3.14.so:PyClassMethod_Type'],
        PyCode_Type: exports1['libpython3.14.so:PyCode_Type'],
        PyComplex_Type: exports1['libpython3.14.so:PyComplex_Type'],
        PyContextToken_Type: exports1['libpython3.14.so:PyContextToken_Type'],
        PyContextVar_Type: exports1['libpython3.14.so:PyContextVar_Type'],
        PyContext_Type: exports1['libpython3.14.so:PyContext_Type'],
        PyCoro_Type: exports1['libpython3.14.so:PyCoro_Type'],
        PyDictItems_Type: exports1['libpython3.14.so:PyDictItems_Type'],
        PyDictIterItem_Type: exports1['libpython3.14.so:PyDictIterItem_Type'],
        PyDictIterKey_Type: exports1['libpython3.14.so:PyDictIterKey_Type'],
        PyDictIterValue_Type: exports1['libpython3.14.so:PyDictIterValue_Type'],
        PyDictKeys_Type: exports1['libpython3.14.so:PyDictKeys_Type'],
        PyDictProxy_Type: exports1['libpython3.14.so:PyDictProxy_Type'],
        PyDictRevIterItem_Type: exports1['libpython3.14.so:PyDictRevIterItem_Type'],
        PyDictRevIterKey_Type: exports1['libpython3.14.so:PyDictRevIterKey_Type'],
        PyDictRevIterValue_Type: exports1['libpython3.14.so:PyDictRevIterValue_Type'],
        PyDictValues_Type: exports1['libpython3.14.so:PyDictValues_Type'],
        PyDict_Type: exports1['libpython3.14.so:PyDict_Type'],
        PyEllipsis_Type: exports1['libpython3.14.so:PyEllipsis_Type'],
        PyEnum_Type: exports1['libpython3.14.so:PyEnum_Type'],
        PyExc_ArithmeticError: exports1['libpython3.14.so:PyExc_ArithmeticError'],
        PyExc_AssertionError: exports1['libpython3.14.so:PyExc_AssertionError'],
        PyExc_AttributeError: exports1['libpython3.14.so:PyExc_AttributeError'],
        PyExc_BaseException: exports1['libpython3.14.so:PyExc_BaseException'],
        PyExc_BaseExceptionGroup: exports1['libpython3.14.so:PyExc_BaseExceptionGroup'],
        PyExc_BlockingIOError: exports1['libpython3.14.so:PyExc_BlockingIOError'],
        PyExc_BrokenPipeError: exports1['libpython3.14.so:PyExc_BrokenPipeError'],
        PyExc_BufferError: exports1['libpython3.14.so:PyExc_BufferError'],
        PyExc_BytesWarning: exports1['libpython3.14.so:PyExc_BytesWarning'],
        PyExc_ChildProcessError: exports1['libpython3.14.so:PyExc_ChildProcessError'],
        PyExc_ConnectionAbortedError: exports1['libpython3.14.so:PyExc_ConnectionAbortedError'],
        PyExc_ConnectionRefusedError: exports1['libpython3.14.so:PyExc_ConnectionRefusedError'],
        PyExc_ConnectionResetError: exports1['libpython3.14.so:PyExc_ConnectionResetError'],
        PyExc_DeprecationWarning: exports1['libpython3.14.so:PyExc_DeprecationWarning'],
        PyExc_EOFError: exports1['libpython3.14.so:PyExc_EOFError'],
        PyExc_EncodingWarning: exports1['libpython3.14.so:PyExc_EncodingWarning'],
        PyExc_EnvironmentError: exports1['libpython3.14.so:PyExc_EnvironmentError'],
        PyExc_Exception: exports1['libpython3.14.so:PyExc_Exception'],
        PyExc_FileExistsError: exports1['libpython3.14.so:PyExc_FileExistsError'],
        PyExc_FileNotFoundError: exports1['libpython3.14.so:PyExc_FileNotFoundError'],
        PyExc_GeneratorExit: exports1['libpython3.14.so:PyExc_GeneratorExit'],
        PyExc_IOError: exports1['libpython3.14.so:PyExc_IOError'],
        PyExc_ImportError: exports1['libpython3.14.so:PyExc_ImportError'],
        PyExc_ImportWarning: exports1['libpython3.14.so:PyExc_ImportWarning'],
        PyExc_IndentationError: exports1['libpython3.14.so:PyExc_IndentationError'],
        PyExc_IndexError: exports1['libpython3.14.so:PyExc_IndexError'],
        PyExc_InterpreterError: exports1['libpython3.14.so:PyExc_InterpreterError'],
        PyExc_InterpreterNotFoundError: exports1['libpython3.14.so:PyExc_InterpreterNotFoundError'],
        PyExc_InterruptedError: exports1['libpython3.14.so:PyExc_InterruptedError'],
        PyExc_IsADirectoryError: exports1['libpython3.14.so:PyExc_IsADirectoryError'],
        PyExc_KeyError: exports1['libpython3.14.so:PyExc_KeyError'],
        PyExc_KeyboardInterrupt: exports1['libpython3.14.so:PyExc_KeyboardInterrupt'],
        PyExc_LookupError: exports1['libpython3.14.so:PyExc_LookupError'],
        PyExc_MemoryError: exports1['libpython3.14.so:PyExc_MemoryError'],
        PyExc_ModuleNotFoundError: exports1['libpython3.14.so:PyExc_ModuleNotFoundError'],
        PyExc_NameError: exports1['libpython3.14.so:PyExc_NameError'],
        PyExc_NotADirectoryError: exports1['libpython3.14.so:PyExc_NotADirectoryError'],
        PyExc_NotImplementedError: exports1['libpython3.14.so:PyExc_NotImplementedError'],
        PyExc_OSError: exports1['libpython3.14.so:PyExc_OSError'],
        PyExc_OverflowError: exports1['libpython3.14.so:PyExc_OverflowError'],
        PyExc_PendingDeprecationWarning: exports1['libpython3.14.so:PyExc_PendingDeprecationWarning'],
        PyExc_PermissionError: exports1['libpython3.14.so:PyExc_PermissionError'],
        PyExc_ProcessLookupError: exports1['libpython3.14.so:PyExc_ProcessLookupError'],
        PyExc_PythonFinalizationError: exports1['libpython3.14.so:PyExc_PythonFinalizationError'],
        PyExc_RecursionError: exports1['libpython3.14.so:PyExc_RecursionError'],
        PyExc_ReferenceError: exports1['libpython3.14.so:PyExc_ReferenceError'],
        PyExc_ResourceWarning: exports1['libpython3.14.so:PyExc_ResourceWarning'],
        PyExc_RuntimeError: exports1['libpython3.14.so:PyExc_RuntimeError'],
        PyExc_RuntimeWarning: exports1['libpython3.14.so:PyExc_RuntimeWarning'],
        PyExc_StopAsyncIteration: exports1['libpython3.14.so:PyExc_StopAsyncIteration'],
        PyExc_StopIteration: exports1['libpython3.14.so:PyExc_StopIteration'],
        PyExc_SyntaxError: exports1['libpython3.14.so:PyExc_SyntaxError'],
        PyExc_SyntaxWarning: exports1['libpython3.14.so:PyExc_SyntaxWarning'],
        PyExc_SystemError: exports1['libpython3.14.so:PyExc_SystemError'],
        PyExc_SystemExit: exports1['libpython3.14.so:PyExc_SystemExit'],
        PyExc_TabError: exports1['libpython3.14.so:PyExc_TabError'],
        PyExc_TimeoutError: exports1['libpython3.14.so:PyExc_TimeoutError'],
        PyExc_TypeError: exports1['libpython3.14.so:PyExc_TypeError'],
        PyExc_UnboundLocalError: exports1['libpython3.14.so:PyExc_UnboundLocalError'],
        PyExc_UnicodeDecodeError: exports1['libpython3.14.so:PyExc_UnicodeDecodeError'],
        PyExc_UnicodeEncodeError: exports1['libpython3.14.so:PyExc_UnicodeEncodeError'],
        PyExc_UnicodeError: exports1['libpython3.14.so:PyExc_UnicodeError'],
        PyExc_UnicodeTranslateError: exports1['libpython3.14.so:PyExc_UnicodeTranslateError'],
        PyExc_UserWarning: exports1['libpython3.14.so:PyExc_UserWarning'],
        PyExc_ValueError: exports1['libpython3.14.so:PyExc_ValueError'],
        PyExc_Warning: exports1['libpython3.14.so:PyExc_Warning'],
        PyExc_ZeroDivisionError: exports1['libpython3.14.so:PyExc_ZeroDivisionError'],
        PyFilter_Type: exports1['libpython3.14.so:PyFilter_Type'],
        PyFloat_Type: exports1['libpython3.14.so:PyFloat_Type'],
        PyFrameLocalsProxy_Type: exports1['libpython3.14.so:PyFrameLocalsProxy_Type'],
        PyFrame_Type: exports1['libpython3.14.so:PyFrame_Type'],
        PyFrozenSet_Type: exports1['libpython3.14.so:PyFrozenSet_Type'],
        PyFunction_Type: exports1['libpython3.14.so:PyFunction_Type'],
        PyGen_Type: exports1['libpython3.14.so:PyGen_Type'],
        PyGetSetDescr_Type: exports1['libpython3.14.so:PyGetSetDescr_Type'],
        PyImport_FrozenModules: exports1['libpython3.14.so:PyImport_FrozenModules'],
        PyImport_Inittab: exports1['libpython3.14.so:PyImport_Inittab'],
        PyInstanceMethod_Type: exports1['libpython3.14.so:PyInstanceMethod_Type'],
        PyListIter_Type: exports1['libpython3.14.so:PyListIter_Type'],
        PyListRevIter_Type: exports1['libpython3.14.so:PyListRevIter_Type'],
        PyList_Type: exports1['libpython3.14.so:PyList_Type'],
        PyLongRangeIter_Type: exports1['libpython3.14.so:PyLongRangeIter_Type'],
        PyLong_Type: exports1['libpython3.14.so:PyLong_Type'],
        PyMap_Type: exports1['libpython3.14.so:PyMap_Type'],
        PyMemberDescr_Type: exports1['libpython3.14.so:PyMemberDescr_Type'],
        PyMemoryView_Type: exports1['libpython3.14.so:PyMemoryView_Type'],
        PyMethodDescr_Type: exports1['libpython3.14.so:PyMethodDescr_Type'],
        PyMethod_Type: exports1['libpython3.14.so:PyMethod_Type'],
        PyModuleDef_Type: exports1['libpython3.14.so:PyModuleDef_Type'],
        PyModule_Type: exports1['libpython3.14.so:PyModule_Type'],
        PyODictItems_Type: exports1['libpython3.14.so:PyODictItems_Type'],
        PyODictIter_Type: exports1['libpython3.14.so:PyODictIter_Type'],
        PyODictKeys_Type: exports1['libpython3.14.so:PyODictKeys_Type'],
        PyODictValues_Type: exports1['libpython3.14.so:PyODictValues_Type'],
        PyODict_Type: exports1['libpython3.14.so:PyODict_Type'],
        PyOS_InputHook: exports1['libpython3.14.so:PyOS_InputHook'],
        PyOS_ReadlineFunctionPointer: exports1['libpython3.14.so:PyOS_ReadlineFunctionPointer'],
        PyPickleBuffer_Type: exports1['libpython3.14.so:PyPickleBuffer_Type'],
        PyProperty_Type: exports1['libpython3.14.so:PyProperty_Type'],
        PyRangeIter_Type: exports1['libpython3.14.so:PyRangeIter_Type'],
        PyRange_Type: exports1['libpython3.14.so:PyRange_Type'],
        PyReversed_Type: exports1['libpython3.14.so:PyReversed_Type'],
        PySeqIter_Type: exports1['libpython3.14.so:PySeqIter_Type'],
        PySetIter_Type: exports1['libpython3.14.so:PySetIter_Type'],
        PySet_Type: exports1['libpython3.14.so:PySet_Type'],
        PySlice_Type: exports1['libpython3.14.so:PySlice_Type'],
        PyStaticMethod_Type: exports1['libpython3.14.so:PyStaticMethod_Type'],
        PyStdPrinter_Type: exports1['libpython3.14.so:PyStdPrinter_Type'],
        PyStructSequence_UnnamedField: exports1['libpython3.14.so:PyStructSequence_UnnamedField'],
        PySuper_Type: exports1['libpython3.14.so:PySuper_Type'],
        PyTraceBack_Type: exports1['libpython3.14.so:PyTraceBack_Type'],
        PyTupleIter_Type: exports1['libpython3.14.so:PyTupleIter_Type'],
        PyTuple_Type: exports1['libpython3.14.so:PyTuple_Type'],
        PyType_Type: exports1['libpython3.14.so:PyType_Type'],
        PyUnicodeIter_Type: exports1['libpython3.14.so:PyUnicodeIter_Type'],
        PyUnicode_Type: exports1['libpython3.14.so:PyUnicode_Type'],
        PyWrapperDescr_Type: exports1['libpython3.14.so:PyWrapperDescr_Type'],
        PyZip_Type: exports1['libpython3.14.so:PyZip_Type'],
        Py_BytesWarningFlag: exports1['libpython3.14.so:Py_BytesWarningFlag'],
        Py_DebugFlag: exports1['libpython3.14.so:Py_DebugFlag'],
        Py_DontWriteBytecodeFlag: exports1['libpython3.14.so:Py_DontWriteBytecodeFlag'],
        Py_FileSystemDefaultEncodeErrors: exports1['libpython3.14.so:Py_FileSystemDefaultEncodeErrors'],
        Py_FileSystemDefaultEncoding: exports1['libpython3.14.so:Py_FileSystemDefaultEncoding'],
        Py_FrozenFlag: exports1['libpython3.14.so:Py_FrozenFlag'],
        Py_GenericAliasType: exports1['libpython3.14.so:Py_GenericAliasType'],
        Py_HasFileSystemDefaultEncoding: exports1['libpython3.14.so:Py_HasFileSystemDefaultEncoding'],
        Py_HashRandomizationFlag: exports1['libpython3.14.so:Py_HashRandomizationFlag'],
        Py_IgnoreEnvironmentFlag: exports1['libpython3.14.so:Py_IgnoreEnvironmentFlag'],
        Py_InspectFlag: exports1['libpython3.14.so:Py_InspectFlag'],
        Py_InteractiveFlag: exports1['libpython3.14.so:Py_InteractiveFlag'],
        Py_IsolatedFlag: exports1['libpython3.14.so:Py_IsolatedFlag'],
        Py_NoSiteFlag: exports1['libpython3.14.so:Py_NoSiteFlag'],
        Py_NoUserSiteDirectory: exports1['libpython3.14.so:Py_NoUserSiteDirectory'],
        Py_OptimizeFlag: exports1['libpython3.14.so:Py_OptimizeFlag'],
        Py_QuietFlag: exports1['libpython3.14.so:Py_QuietFlag'],
        Py_UTF8Mode: exports1['libpython3.14.so:Py_UTF8Mode'],
        Py_UnbufferedStdioFlag: exports1['libpython3.14.so:Py_UnbufferedStdioFlag'],
        Py_VerboseFlag: exports1['libpython3.14.so:Py_VerboseFlag'],
        Py_hexdigits: exports1['libpython3.14.so:Py_hexdigits'],
        _CLOCK_MONOTONIC: exports1['libpython3.14.so:_CLOCK_MONOTONIC'],
        _CLOCK_REALTIME: exports1['libpython3.14.so:_CLOCK_REALTIME'],
        _PyAsyncGenASend_Type: exports1['libpython3.14.so:_PyAsyncGenASend_Type'],
        _PyByteArray_empty_string: exports1['libpython3.14.so:_PyByteArray_empty_string'],
        _PyEval_BinaryOps: exports1['libpython3.14.so:_PyEval_BinaryOps'],
        _PyEval_ConversionFuncs: exports1['libpython3.14.so:_PyEval_ConversionFuncs'],
        _PyExc_IncompleteInputError: exports1['libpython3.14.so:_PyExc_IncompleteInputError'],
        _PyImport_FrozenBootstrap: exports1['libpython3.14.so:_PyImport_FrozenBootstrap'],
        _PyImport_FrozenStdlib: exports1['libpython3.14.so:_PyImport_FrozenStdlib'],
        _PyImport_FrozenTest: exports1['libpython3.14.so:_PyImport_FrozenTest'],
        _PyIntrinsics_BinaryFunctions: exports1['libpython3.14.so:_PyIntrinsics_BinaryFunctions'],
        _PyIntrinsics_UnaryFunctions: exports1['libpython3.14.so:_PyIntrinsics_UnaryFunctions'],
        _PyLong_DigitValue: exports1['libpython3.14.so:_PyLong_DigitValue'],
        _PyNone_Type: exports1['libpython3.14.so:_PyNone_Type'],
        _PyNotImplemented_Type: exports1['libpython3.14.so:_PyNotImplemented_Type'],
        _PyOS_ReadlineTState: exports1['libpython3.14.so:_PyOS_ReadlineTState'],
        _PyRuntime: exports1['libpython3.14.so:_PyRuntime'],
        _PyUnion_Type: exports1['libpython3.14.so:_PyUnion_Type'],
        _PyWeakref_CallableProxyType: exports1['libpython3.14.so:_PyWeakref_CallableProxyType'],
        _PyWeakref_ProxyType: exports1['libpython3.14.so:_PyWeakref_ProxyType'],
        _PyWeakref_RefType: exports1['libpython3.14.so:_PyWeakref_RefType'],
        _Py_EllipsisObject: exports1['libpython3.14.so:_Py_EllipsisObject'],
        _Py_FalseStruct: exports1['libpython3.14.so:_Py_FalseStruct'],
        _Py_FunctionAttributeOffsets: exports1['libpython3.14.so:_Py_FunctionAttributeOffsets'],
        _Py_HashSecret: exports1['libpython3.14.so:_Py_HashSecret'],
        _Py_InitCleanup: exports1['libpython3.14.so:_Py_InitCleanup'],
        _Py_NoneStruct: exports1['libpython3.14.so:_Py_NoneStruct'],
        _Py_NotImplementedStruct: exports1['libpython3.14.so:_Py_NotImplementedStruct'],
        _Py_SpecialMethods: exports1['libpython3.14.so:_Py_SpecialMethods'],
        _Py_SwappedOp: exports1['libpython3.14.so:_Py_SwappedOp'],
        _Py_TrueStruct: exports1['libpython3.14.so:_Py_TrueStruct'],
        _Py_ascii_whitespace: exports1['libpython3.14.so:_Py_ascii_whitespace'],
        _Py_ctype_table: exports1['libpython3.14.so:_Py_ctype_table'],
        _Py_ctype_tolower: exports1['libpython3.14.so:_Py_ctype_tolower'],
        _Py_ctype_toupper: exports1['libpython3.14.so:_Py_ctype_toupper'],
        environ: exports1['libpython3.14.so:environ'],
        errno: exports1['libpython3.14.so:errno'],
        h_errno: exports1['libpython3.14.so:h_errno'],
        stderr: exports1['libpython3.14.so:stderr'],
        stdin: exports1['libpython3.14.so:stdin'],
        stdout: exports1['libpython3.14.so:stdout'],
      },
      env: {
        __SIG_ERR: exports6.__SIG_ERR,
        __SIG_IGN: exports6.__SIG_IGN,
        __indirect_function_table: exports1.__indirect_function_table,
        __memory_base: exports1['libpython3.14.so:memory_base'],
        __stack_pointer: exports1.__stack_pointer,
        __table_base: exports1['libpython3.14.so:table_base'],
        __wasilibc_tell: exports4.__wasilibc_tell,
        _exit: exports4._Exit,
        abort: exports4.abort,
        accept: exports4.accept,
        accept4: exports4.accept4,
        access: exports4.access,
        acos: exports4.acos,
        acosh: exports4.acosh,
        asin: exports4.asin,
        asinh: exports4.asinh,
        atan: exports4.atan,
        atan2: exports4.atan2,
        atanh: exports4.atanh,
        atexit: exports4.atexit,
        bind: exports4.bind,
        calloc: exports4.calloc,
        cbrt: exports4.cbrt,
        chdir: exports4.chdir,
        clearerr: exports4.clearerr,
        clock: exports5.__clock,
        clock_getres: exports4.clock_getres,
        clock_gettime: exports4.clock_gettime,
        clock_nanosleep: exports4.clock_nanosleep,
        close: exports4.close,
        closedir: exports4.closedir,
        confstr: exports4.confstr,
        connect: exports4.connect,
        copysign: exports4.copysign,
        cos: exports4.cos,
        cosh: exports4.cosh,
        dlerror: exports8.dlerror,
        dlopen: exports8.dlopen,
        dlsym: exports8.dlsym,
        erf: exports4.erf,
        erfc: exports4.erfc,
        exit: exports4.exit,
        exp: exports4.exp,
        exp2: exports4.exp2,
        expm1: exports4.expm1,
        fabs: exports4.fabs,
        faccessat: exports4.faccessat,
        fclose: exports4.fclose,
        fcntl: exports4.fcntl,
        fdatasync: exports4.fdatasync,
        fdopen: exports4.fdopen,
        feof: exports4.feof,
        ferror: exports4.ferror,
        fflush: exports4.fflush,
        fgets: exports4.fgets,
        fileno: exports4.fileno,
        fma: exports4.fma,
        fmod: exports4.fmod,
        fopen: exports4.fopen,
        fopencookie: exports4.fopencookie,
        fpathconf: exports4.fpathconf,
        fprintf: exports4.fprintf,
        fputc: exports4.fputc,
        fputs: exports4.fputs,
        fread: exports4.fread,
        free: exports4.free,
        freeaddrinfo: exports4.freeaddrinfo,
        frexp: exports4.frexp,
        fstat: exports4.fstat,
        fstatat: exports4.fstatat,
        fsync: exports4.fsync,
        ftell: exports4.ftell,
        ftruncate: exports4.ftruncate,
        futimens: exports4.futimens,
        fwrite: exports4.fwrite,
        gai_strerror: exports4.gai_strerror,
        getaddrinfo: exports4.getaddrinfo,
        getc: exports4.getc,
        getcwd: exports4.getcwd,
        getentropy: exports4.__getentropy,
        getenv: exports4.getenv,
        gethostbyaddr: exports4.gethostbyaddr,
        gethostbyname: exports4.gethostbyname,
        getnameinfo: exports4.getnameinfo,
        getpeername: exports4.getpeername,
        getpid: exports7.getpid,
        getprotobyname: exports4.getprotobyname,
        getservbyname: exports4.getservbyname,
        getservbyport: exports4.getservbyport,
        getsockname: exports4.getsockname,
        getsockopt: exports4.getsockopt,
        gettimeofday: exports4.gettimeofday,
        gmtime_r: exports4.gmtime_r,
        hstrerror: exports4.hstrerror,
        htonl: exports4.htonl,
        htons: exports4.htons,
        hypot: exports4.hypot,
        inet_aton: exports4.inet_aton,
        inet_ntop: exports4.inet_ntop,
        inet_pton: exports4.inet_pton,
        ioctl: exports4.ioctl,
        isalnum: exports4.isalnum,
        isatty: exports4.__isatty,
        ldexp: exports4.ldexp,
        link: exports4.link,
        listen: exports4.listen,
        localeconv: exports4.localeconv,
        localtime_r: exports4.localtime_r,
        log: exports4.log,
        log10: exports4.log10,
        log1p: exports4.log1p,
        log2: exports4.log2,
        lseek: exports4.lseek,
        lstat: exports4.lstat,
        malloc: exports4.malloc,
        mbrtowc: exports4.mbrtowc,
        mbstowcs: exports4.mbstowcs,
        memchr: exports4.memchr,
        memcmp: exports4.memcmp,
        memory: exports1.memory,
        memrchr: exports4.memrchr,
        mkdir: exports4.mkdir,
        mkdirat: exports4.mkdirat,
        mktime: exports4.mktime,
        modf: exports4.modf,
        nanosleep: exports4.nanosleep,
        nextafter: exports4.nextafter,
        nl_langinfo: exports4.__nl_langinfo,
        ntohl: exports4.ntohl,
        ntohs: exports4.ntohs,
        open: exports4.open,
        openat: exports4.openat,
        opendir: exports4.opendir,
        pathconf: exports4.pathconf,
        poll: exports4.poll,
        posix_fadvise: exports4.posix_fadvise,
        pow: exports4.pow,
        pread: exports4.pread,
        printf: exports4.printf,
        pthread_attr_destroy: exports4.pthread_attr_destroy,
        pthread_attr_getguardsize: exports4.pthread_attr_getguardsize,
        pthread_attr_getstack: exports4.pthread_attr_getstack,
        pthread_attr_init: exports4.pthread_attr_init,
        pthread_attr_setstacksize: exports4.pthread_attr_setstacksize,
        pthread_cond_destroy: exports4.pthread_cond_destroy,
        pthread_cond_init: exports4.pthread_cond_init,
        pthread_cond_signal: exports4.pthread_cond_signal,
        pthread_cond_timedwait: exports4.pthread_cond_timedwait,
        pthread_cond_wait: exports4.pthread_cond_wait,
        pthread_condattr_init: exports4.pthread_condattr_init,
        pthread_condattr_setclock: exports4.pthread_condattr_setclock,
        pthread_create: exports4.pthread_create,
        pthread_detach: exports4.pthread_detach,
        pthread_getattr_np: exports4.pthread_getattr_np,
        pthread_getspecific: exports4.pthread_getspecific,
        pthread_join: exports4.pthread_join,
        pthread_key_create: exports4.pthread_key_create,
        pthread_key_delete: exports4.pthread_key_delete,
        pthread_mutex_destroy: exports4.pthread_mutex_destroy,
        pthread_mutex_init: exports4.pthread_mutex_init,
        pthread_mutex_lock: exports4.pthread_mutex_lock,
        pthread_mutex_trylock: exports4.pthread_mutex_trylock,
        pthread_mutex_unlock: exports4.pthread_mutex_unlock,
        pthread_self: exports4.pthread_self,
        pthread_setspecific: exports4.pthread_setspecific,
        putchar: exports4.putchar,
        puts: exports4.puts,
        pwrite: exports4.pwrite,
        raise: exports6.raise,
        read: exports4.read,
        readdir: exports4.readdir,
        readlink: exports4.readlink,
        readlinkat: exports4.readlinkat,
        realloc: exports4.realloc,
        realpath: exports4.realpath,
        recv: exports4.recv,
        recvfrom: exports4.recvfrom,
        rename: exports4.rename,
        renameat: exports4.renameat,
        rewind: exports4.rewind,
        rmdir: exports4.rmdir,
        round: exports4.round,
        sbrk: exports4.sbrk,
        sched_yield: exports4.sched_yield,
        select: exports4.select,
        send: exports4.send,
        sendto: exports4.sendto,
        setenv: exports4.setenv,
        setlocale: exports4.setlocale,
        setsockopt: exports4.setsockopt,
        setvbuf: exports4.setvbuf,
        shutdown: exports4.shutdown,
        signal: exports6.signal,
        sin: exports4.sin,
        sinh: exports4.sinh,
        sleep: exports4.sleep,
        snprintf: exports4.snprintf,
        socket: exports4.socket,
        sprintf: exports4.sprintf,
        sqrt: exports4.sqrt,
        stat: exports4.stat,
        strcat: exports4.strcat,
        strchr: exports4.strchr,
        strcmp: exports4.strcmp,
        strcpy: exports4.strcpy,
        strcspn: exports4.strcspn,
        strdup: exports4.strdup,
        strerror: exports4.strerror,
        strlen: exports4.strlen,
        strncat: exports4.strncat,
        strncmp: exports4.strncmp,
        strncpy: exports4.strncpy,
        strpbrk: exports4.strpbrk,
        strrchr: exports4.strrchr,
        strsignal: exports6.strsignal,
        strspn: exports4.strspn,
        strstr: exports4.strstr,
        strtol: exports4.strtol,
        strtoul: exports4.strtoul,
        symlink: exports4.symlink,
        symlinkat: exports4.symlinkat,
        sysconf: exports4.sysconf,
        tan: exports4.tan,
        tanh: exports4.tanh,
        time: exports4.time,
        times: exports5.times,
        tolower: exports4.tolower,
        toupper: exports4.toupper,
        trunc: exports4.trunc,
        truncate: exports4.truncate,
        uname: exports4.uname,
        ungetc: exports4.ungetc,
        unlink: exports4.unlink,
        unlinkat: exports4.unlinkat,
        unsetenv: exports4.unsetenv,
        utimensat: exports4.utimensat,
        utimes: exports4.utimes,
        vfprintf: exports4.vfprintf,
        vsnprintf: exports4.vsnprintf,
        wcschr: exports4.wcschr,
        wcscmp: exports4.wcscmp,
        wcscoll: exports4.wcscoll,
        wcscpy: exports4.wcscpy,
        wcsftime: exports4.wcsftime,
        wcslen: exports4.wcslen,
        wcsncmp: exports4.wcsncmp,
        wcsncpy: exports4.wcsncpy,
        wcsrchr: exports4.wcsrchr,
        wcstok: exports4.wcstok,
        wcstol: exports4.wcstol,
        wcstombs: exports4.wcstombs,
        wcsxfrm: exports4.wcsxfrm,
        wmemchr: exports4.wmemchr,
        wmemcmp: exports4.wmemcmp,
        write: exports4.write,
      },
    }));
    ({ exports: exports10 } = yield instantiateCore(yield module9, {
      $root: {
        '[context-get-0]': trampoline42,
        '[context-set-0]': trampoline41,
        '[subtask-drop]': trampoline43,
        '[waitable-join]': trampoline40,
        '[waitable-set-drop]': trampoline39,
        '[waitable-set-new]': trampoline38,
      },
      'GOT.func': {
        PyInit__eryx: exports1['liberyx_runtime.so:PyInit__eryx'],
        PyObject_GenericGetDict: exports1['liberyx_runtime.so:PyObject_GenericGetDict'],
        PyObject_GenericSetDict: exports1['liberyx_runtime.so:PyObject_GenericSetDict'],
        PyType_GenericAlloc: exports1['liberyx_runtime.so:PyType_GenericAlloc'],
        _RNvNtCs5XY3BH99Eqp_3std5alloc24default_alloc_error_hook: exports1['liberyx_runtime.so:_RNvNtCs5XY3BH99Eqp_3std5alloc24default_alloc_error_hook'],
        _RNvXNtNtCs5XY3BH99Eqp_3std2io5errorNtB2_5ErrorNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt: exports1['liberyx_runtime.so:_RNvXNtNtCs5XY3BH99Eqp_3std2io5errorNtB2_5ErrorNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt'],
        _RNvXNtNtCsidipMUxUeKa_4core3num5errorNtB2_15TryFromIntErrorNtNtB6_3fmt7Display3fmt: exports1['liberyx_runtime.so:_RNvXNtNtCsidipMUxUeKa_4core3num5errorNtB2_15TryFromIntErrorNtNtB6_3fmt7Display3fmt'],
        _RNvXNtNtNtCs5XY3BH99Eqp_3std3sys7process3envNtB2_10CommandEnvNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt: exports1['liberyx_runtime.so:_RNvXNtNtNtCs5XY3BH99Eqp_3std3sys7process3envNtB2_10CommandEnvNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt'],
        _RNvXNtNtNtCsidipMUxUeKa_4core3fmt3num3imphNtB6_7Display3fmt: exports1['liberyx_runtime.so:_RNvXNtNtNtCsidipMUxUeKa_4core3fmt3num3imphNtB6_7Display3fmt'],
        _RNvXNvMNtNtCs5XY3BH99Eqp_3std3sys9backtraceNtB5_13BacktraceLock5printNtB2_16DisplayBacktraceNtNtCsidipMUxUeKa_4core3fmt7Display3fmt: exports1['liberyx_runtime.so:_RNvXNvMNtNtCs5XY3BH99Eqp_3std3sys9backtraceNtB5_13BacktraceLock5printNtB2_16DisplayBacktraceNtNtCsidipMUxUeKa_4core3fmt7Display3fmt'],
        _RNvXNvNtCs5XY3BH99Eqp_3std9panicking13resume_unwindNtB2_9RewrapBoxNtNtCsidipMUxUeKa_4core5panic12PanicPayload8take_box: exports1['liberyx_runtime.so:_RNvXNvNtCs5XY3BH99Eqp_3std9panicking13resume_unwindNtB2_9RewrapBoxNtNtCsidipMUxUeKa_4core5panic12PanicPayload8take_box'],
        _RNvXNvXs7_NtCs5XY3BH99Eqp_3std4pathNtB8_10ComponentsNtNtCsidipMUxUeKa_4core3fmt5Debug3fmtNtB2_11DebugHelperBO_3fmt: exports1['liberyx_runtime.so:_RNvXNvXs7_NtCs5XY3BH99Eqp_3std4pathNtB8_10ComponentsNtNtCsidipMUxUeKa_4core3fmt5Debug3fmtNtB2_11DebugHelperBO_3fmt'],
        _RNvXNvXsb_NtCs5XY3BH99Eqp_3std4pathNtB8_4IterNtNtCsidipMUxUeKa_4core3fmt5Debug3fmtNtB2_11DebugHelperBH_3fmt: exports1['liberyx_runtime.so:_RNvXNvXsb_NtCs5XY3BH99Eqp_3std4pathNtB8_4IterNtNtCsidipMUxUeKa_4core3fmt5Debug3fmtNtB2_11DebugHelperBH_3fmt'],
        _RNvXs0_NtCscviJhzjbUDx_4pyo33errNtB5_5PyErrNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt: exports1['liberyx_runtime.so:_RNvXs0_NtCscviJhzjbUDx_4pyo33errNtB5_5PyErrNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt'],
        _RNvXs0_NtNtCs5XY3BH99Eqp_3std6thread6threadNtB5_6ThreadNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt: exports1['liberyx_runtime.so:_RNvXs0_NtNtCs5XY3BH99Eqp_3std6thread6threadNtB5_6ThreadNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt'],
        _RNvXs0_NtNtCsidipMUxUeKa_4core3fmt8buildersNtB5_10PadAdapterNtB7_5Write10write_char: exports1['liberyx_runtime.so:_RNvXs0_NtNtCsidipMUxUeKa_4core3fmt8buildersNtB5_10PadAdapterNtB7_5Write10write_char'],
        _RNvXs0_NtNtCsidipMUxUeKa_4core3fmt8buildersNtB5_10PadAdapterNtB7_5Write9write_str: exports1['liberyx_runtime.so:_RNvXs0_NtNtCsidipMUxUeKa_4core3fmt8buildersNtB5_10PadAdapterNtB7_5Write9write_str'],
        _RNvXs0_NtNtCsidipMUxUeKa_4core3str5lossyNtB5_5DebugNtNtB9_3fmt5Debug3fmt: exports1['liberyx_runtime.so:_RNvXs0_NtNtCsidipMUxUeKa_4core3str5lossyNtB5_5DebugNtNtB9_3fmt5Debug3fmt'],
        _RNvXs0_NvNtCs5XY3BH99Eqp_3std9panicking13panic_handlerNtB5_19FormatStringPayloadNtNtCsidipMUxUeKa_4core3fmt7Display3fmt: exports1['liberyx_runtime.so:_RNvXs0_NvNtCs5XY3BH99Eqp_3std9panicking13panic_handlerNtB5_19FormatStringPayloadNtNtCsidipMUxUeKa_4core3fmt7Display3fmt'],
        _RNvXs0_NvXsf_NtNtCs156tPVBHeXz_5alloc5boxed7convertINtBd_3BoxDNtNtCsidipMUxUeKa_4core5error5ErrorNtNtB12_6marker4SyncNtB1z_4SendEL_EINtNtB12_7convert4FromNtNtBf_6string6StringE4fromNtB5_11StringErrorNtNtB12_3fmt5Debug3fmt: exports1['liberyx_runtime.so:_RNvXs0_NvXsf_NtNtCs156tPVBHeXz_5alloc5boxed7convertINtBd_3BoxDNtNtCsidipMUxUeKa_4core5error5ErrorNtNtB12_6marker4SyncNtB1z_4SendEL_EINtNtB12_7convert4FromNtNtBf_6string6StringE4fromNtB5_11StringErrorNtNtB12_3fmt5Debug3fmt'],
        _RNvXs1_NtCs1Pv9BUWNVtS_4wasi13lib_generatedNtB5_5ErrnoNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt: exports1['liberyx_runtime.so:_RNvXs1_NtCs1Pv9BUWNVtS_4wasi13lib_generatedNtB5_5ErrnoNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt'],
        _RNvXs1_NtCscviJhzjbUDx_4pyo33errNtB5_5PyErrNtNtCsidipMUxUeKa_4core3fmt7Display3fmt: exports1['liberyx_runtime.so:_RNvXs1_NtCscviJhzjbUDx_4pyo33errNtB5_5PyErrNtNtCsidipMUxUeKa_4core3fmt7Display3fmt'],
        _RNvXs1_NtNtNtCs5XY3BH99Eqp_3std3sys4args6commonNtB5_4ArgsNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt: exports1['liberyx_runtime.so:_RNvXs1_NtNtNtCs5XY3BH99Eqp_3std3sys4args6commonNtB5_4ArgsNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt'],
        _RNvXs1_NtNtNtCs5XY3BH99Eqp_3std3sys6os_str5bytesNtB5_3BufNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt: exports1['liberyx_runtime.so:_RNvXs1_NtNtNtCs5XY3BH99Eqp_3std3sys6os_str5bytesNtB5_3BufNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt'],
        _RNvXs1_NvNtCs5XY3BH99Eqp_3std9panicking13panic_handlerNtB5_16StaticStrPayloadNtNtCsidipMUxUeKa_4core5panic12PanicPayload8take_box: exports1['liberyx_runtime.so:_RNvXs1_NvNtCs5XY3BH99Eqp_3std9panicking13panic_handlerNtB5_16StaticStrPayloadNtNtCsidipMUxUeKa_4core5panic12PanicPayload8take_box'],
        _RNvXs2Y_NtNtCsidipMUxUeKa_4core3num11niche_typesNtB6_13I32NotAllOnesNtNtBa_3fmt5Debug3fmt: exports1['liberyx_runtime.so:_RNvXs2Y_NtNtCsidipMUxUeKa_4core3num11niche_typesNtB6_13I32NotAllOnesNtNtBa_3fmt5Debug3fmt'],
        _RNvXs2_NtNtCs5XY3BH99Eqp_3std12backtrace_rs9symbolizeNtB5_10SymbolNameNtNtCsidipMUxUeKa_4core3fmt7Display3fmt: exports1['liberyx_runtime.so:_RNvXs2_NtNtCs5XY3BH99Eqp_3std12backtrace_rs9symbolizeNtB5_10SymbolNameNtNtCsidipMUxUeKa_4core3fmt7Display3fmt'],
        _RNvXs2_NtNtCsidipMUxUeKa_4core5slice5asciiNtB5_11EscapeAsciiNtNtB9_3fmt7Display3fmt: exports1['liberyx_runtime.so:_RNvXs2_NtNtCsidipMUxUeKa_4core5slice5asciiNtB5_11EscapeAsciiNtNtB9_3fmt7Display3fmt'],
        _RNvXs2_NvNtCs5XY3BH99Eqp_3std9panicking13panic_handlerNtB5_16StaticStrPayloadNtNtCsidipMUxUeKa_4core3fmt7Display3fmt: exports1['liberyx_runtime.so:_RNvXs2_NvNtCs5XY3BH99Eqp_3std9panicking13panic_handlerNtB5_16StaticStrPayloadNtNtCsidipMUxUeKa_4core3fmt7Display3fmt'],
        _RNvXs3_NtCscviJhzjbUDx_4pyo38pybackedNtB5_11PyBackedStrNtNtCsidipMUxUeKa_4core3fmt7Display3fmt: exports1['liberyx_runtime.so:_RNvXs3_NtCscviJhzjbUDx_4pyo38pybackedNtB5_11PyBackedStrNtNtCsidipMUxUeKa_4core3fmt7Display3fmt'],
        _RNvXs3_NtCsidipMUxUeKa_4core5asciiNtB5_13EscapeDefaultNtNtB7_3fmt7Display3fmt: exports1['liberyx_runtime.so:_RNvXs3_NtCsidipMUxUeKa_4core5asciiNtB5_13EscapeDefaultNtNtB7_3fmt7Display3fmt'],
        _RNvXs3_NtNtNtCs5XY3BH99Eqp_3std3sys5stdio4unixNtB5_6StderrNtNtBb_2io5Write14write_vectored: exports1['liberyx_runtime.so:_RNvXs3_NtNtNtCs5XY3BH99Eqp_3std3sys5stdio4unixNtB5_6StderrNtNtBb_2io5Write14write_vectored'],
        _RNvXs3_NtNtNtCs5XY3BH99Eqp_3std3sys5stdio4unixNtB5_6StderrNtNtBb_2io5Write5write: exports1['liberyx_runtime.so:_RNvXs3_NtNtNtCs5XY3BH99Eqp_3std3sys5stdio4unixNtB5_6StderrNtNtBb_2io5Write5write'],
        _RNvXs3_NtNtNtCsidipMUxUeKa_4core3fmt3num3imptNtB9_7Display3fmt: exports1['liberyx_runtime.so:_RNvXs3_NtNtNtCsidipMUxUeKa_4core3fmt3num3imptNtB9_7Display3fmt'],
        _RNvXs6_NtNtCsidipMUxUeKa_4core3fmt3numjNtB7_8LowerHex3fmt: exports1['liberyx_runtime.so:_RNvXs6_NtNtCsidipMUxUeKa_4core3fmt3numjNtB7_8LowerHex3fmt'],
        _RNvXs6_NtNtCsidipMUxUeKa_4core3net7ip_addrNtB5_8Ipv4AddrNtNtB9_3fmt7Display3fmt: exports1['liberyx_runtime.so:_RNvXs6_NtNtCsidipMUxUeKa_4core3net7ip_addrNtB5_8Ipv4AddrNtNtB9_3fmt7Display3fmt'],
        _RNvXs7_NtCsidipMUxUeKa_4core3fmtNtB5_9ArgumentsNtB5_5Debug3fmt: exports1['liberyx_runtime.so:_RNvXs7_NtCsidipMUxUeKa_4core3fmtNtB5_9ArgumentsNtB5_5Debug3fmt'],
        _RNvXs7_NtNtCs5XY3BH99Eqp_3std2io5errorNtB5_5ErrorNtNtCsidipMUxUeKa_4core3fmt7Display3fmt: exports1['liberyx_runtime.so:_RNvXs7_NtNtCs5XY3BH99Eqp_3std2io5errorNtB5_5ErrorNtNtCsidipMUxUeKa_4core3fmt7Display3fmt'],
        _RNvXs7_NtNtCscviJhzjbUDx_4pyo33err10cast_errorNtB5_20DisplayDowncastErrorNtNtCsidipMUxUeKa_4core3fmt7Display3fmt: exports1['liberyx_runtime.so:_RNvXs7_NtNtCscviJhzjbUDx_4pyo33err10cast_errorNtB5_20DisplayDowncastErrorNtNtCsidipMUxUeKa_4core3fmt7Display3fmt'],
        _RNvXs8_NtCsidipMUxUeKa_4core3fmtNtB5_9ArgumentsNtB5_7Display3fmt: exports1['liberyx_runtime.so:_RNvXs8_NtCsidipMUxUeKa_4core3fmtNtB5_9ArgumentsNtB5_7Display3fmt'],
        _RNvXs8_NtNtCscviJhzjbUDx_4pyo33err10cast_errorNtB5_16DisplayClassInfoNtNtCsidipMUxUeKa_4core3fmt7Display3fmt: exports1['liberyx_runtime.so:_RNvXs8_NtNtCscviJhzjbUDx_4pyo33err10cast_errorNtB5_16DisplayClassInfoNtNtCsidipMUxUeKa_4core3fmt7Display3fmt'],
        _RNvXs8_NtNtNtCsidipMUxUeKa_4core3fmt3num3impmNtB9_7Display3fmt: exports1['liberyx_runtime.so:_RNvXs8_NtNtNtCsidipMUxUeKa_4core3fmt3num3impmNtB9_7Display3fmt'],
        _RNvXs9_NtNtNtCsidipMUxUeKa_4core3fmt3num3implNtB9_7Display3fmt: exports1['liberyx_runtime.so:_RNvXs9_NtNtNtCsidipMUxUeKa_4core3fmt3num3implNtB9_7Display3fmt'],
        _RNvXsK_NtNtCsidipMUxUeKa_4core3fmt3numoNtB7_8LowerHex3fmt: exports1['liberyx_runtime.so:_RNvXsK_NtNtCsidipMUxUeKa_4core3fmt3numoNtB7_8LowerHex3fmt'],
        _RNvXsP_NtNtCs5XY3BH99Eqp_3std3ffi6os_strNtB5_7DisplayNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt: exports1['liberyx_runtime.so:_RNvXsP_NtNtCs5XY3BH99Eqp_3std3ffi6os_strNtB5_7DisplayNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt'],
        _RNvXs_NtNtCs5XY3BH99Eqp_3std6thread5localNtB4_11AccessErrorNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt: exports1['liberyx_runtime.so:_RNvXs_NtNtCs5XY3BH99Eqp_3std6thread5localNtB4_11AccessErrorNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt'],
        _RNvXs_NtNtNtCs5XY3BH99Eqp_3std3sys3env6commonNtB4_3EnvNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt: exports1['liberyx_runtime.so:_RNvXs_NtNtNtCs5XY3BH99Eqp_3std3sys3env6commonNtB4_3EnvNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt'],
        _RNvXs_NvNtCs5XY3BH99Eqp_3std9panicking13panic_handlerNtB4_19FormatStringPayloadNtNtCsidipMUxUeKa_4core5panic12PanicPayload3get: exports1['liberyx_runtime.so:_RNvXs_NvNtCs5XY3BH99Eqp_3std9panicking13panic_handlerNtB4_19FormatStringPayloadNtNtCsidipMUxUeKa_4core5panic12PanicPayload3get'],
        _RNvXs_NvNtCs5XY3BH99Eqp_3std9panicking13panic_handlerNtB4_19FormatStringPayloadNtNtCsidipMUxUeKa_4core5panic12PanicPayload8take_box: exports1['liberyx_runtime.so:_RNvXs_NvNtCs5XY3BH99Eqp_3std9panicking13panic_handlerNtB4_19FormatStringPayloadNtNtCsidipMUxUeKa_4core5panic12PanicPayload8take_box'],
        _RNvXs_NvNtCs5XY3BH99Eqp_3std9panicking13resume_unwindNtB4_9RewrapBoxNtNtCsidipMUxUeKa_4core3fmt7Display3fmt: exports1['liberyx_runtime.so:_RNvXs_NvNtCs5XY3BH99Eqp_3std9panicking13resume_unwindNtB4_9RewrapBoxNtNtCsidipMUxUeKa_4core3fmt7Display3fmt'],
        _RNvXs_NvXsf_NtNtCs156tPVBHeXz_5alloc5boxed7convertINtBc_3BoxDNtNtCsidipMUxUeKa_4core5error5ErrorNtNtB11_6marker4SyncNtB1y_4SendEL_EINtNtB11_7convert4FromNtNtBe_6string6StringE4fromNtB4_11StringErrorNtNtB11_3fmt7Display3fmt: exports1['liberyx_runtime.so:_RNvXs_NvXsf_NtNtCs156tPVBHeXz_5alloc5boxed7convertINtBc_3BoxDNtNtCsidipMUxUeKa_4core5error5ErrorNtNtB11_6marker4SyncNtB1y_4SendEL_EINtNtB11_7convert4FromNtNtBe_6string6StringE4fromNtB4_11StringErrorNtNtB11_3fmt7Display3fmt'],
        _RNvXsa_NtCs5XY3BH99Eqp_3std4timeNtB5_10SystemTimeNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt: exports1['liberyx_runtime.so:_RNvXsa_NtCs5XY3BH99Eqp_3std4timeNtB5_10SystemTimeNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt'],
        _RNvXsc_NtNtCsidipMUxUeKa_4core3num11niche_typesNtB5_11NanosecondsNtNtB9_3fmt5Debug3fmt: exports1['liberyx_runtime.so:_RNvXsc_NtNtCsidipMUxUeKa_4core3num11niche_typesNtB5_11NanosecondsNtNtB9_3fmt5Debug3fmt'],
        _RNvXsd_NtNtNtCsidipMUxUeKa_4core3fmt3num3impyNtB9_7Display3fmt: exports1['liberyx_runtime.so:_RNvXsd_NtNtNtCsidipMUxUeKa_4core3fmt3num3impyNtB9_7Display3fmt'],
        _RNvXse_NtNtCsidipMUxUeKa_4core3fmt3numhNtB7_8LowerHex3fmt: exports1['liberyx_runtime.so:_RNvXse_NtNtCsidipMUxUeKa_4core3fmt3numhNtB7_8LowerHex3fmt'],
        _RNvXsg_NtNtCsidipMUxUeKa_4core3fmt3numhNtB7_8UpperHex3fmt: exports1['liberyx_runtime.so:_RNvXsg_NtNtCsidipMUxUeKa_4core3fmt3numhNtB7_8UpperHex3fmt'],
        _RNvXsi_NtNtNtCsidipMUxUeKa_4core3fmt3num3impjNtB9_7Display3fmt: exports1['liberyx_runtime.so:_RNvXsi_NtNtNtCsidipMUxUeKa_4core3fmt3num3impjNtB9_7Display3fmt'],
        _RNvXsj_NtCscviJhzjbUDx_4pyo36pycellNtB5_13PyBorrowErrorNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt: exports1['liberyx_runtime.so:_RNvXsj_NtCscviJhzjbUDx_4pyo36pycellNtB5_13PyBorrowErrorNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt'],
        _RNvXsj_NtCsidipMUxUeKa_4core3fmtcNtB5_5Debug3fmt: exports1['liberyx_runtime.so:_RNvXsj_NtCsidipMUxUeKa_4core3fmtcNtB5_5Debug3fmt'],
        _RNvXsj_NtNtNtCsidipMUxUeKa_4core3fmt3num3impiNtB9_7Display3fmt: exports1['liberyx_runtime.so:_RNvXsj_NtNtNtCsidipMUxUeKa_4core3fmt3num3impiNtB9_7Display3fmt'],
        _RNvXsk_NtCscviJhzjbUDx_4pyo36pycellNtB5_13PyBorrowErrorNtNtCsidipMUxUeKa_4core3fmt7Display3fmt: exports1['liberyx_runtime.so:_RNvXsk_NtCscviJhzjbUDx_4pyo36pycellNtB5_13PyBorrowErrorNtNtCsidipMUxUeKa_4core3fmt7Display3fmt'],
        _RNvXsk_NtCsidipMUxUeKa_4core3fmtcNtB5_7Display3fmt: exports1['liberyx_runtime.so:_RNvXsk_NtCsidipMUxUeKa_4core3fmtcNtB5_7Display3fmt'],
        _RNvXsm_NtNtCsidipMUxUeKa_4core3fmt3numtNtB7_8LowerHex3fmt: exports1['liberyx_runtime.so:_RNvXsm_NtNtCsidipMUxUeKa_4core3fmt3numtNtB7_8LowerHex3fmt'],
        _RNvXsn_NtCscviJhzjbUDx_4pyo36pycellNtB5_16PyBorrowMutErrorNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt: exports1['liberyx_runtime.so:_RNvXsn_NtCscviJhzjbUDx_4pyo36pycellNtB5_16PyBorrowMutErrorNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt'],
        _RNvXsn_NtCsidipMUxUeKa_4core4cellNtB5_11BorrowErrorNtNtB7_3fmt7Display3fmt: exports1['liberyx_runtime.so:_RNvXsn_NtCsidipMUxUeKa_4core4cellNtB5_11BorrowErrorNtNtB7_3fmt7Display3fmt'],
        _RNvXso_NtCscviJhzjbUDx_4pyo36pycellNtB5_16PyBorrowMutErrorNtNtCsidipMUxUeKa_4core3fmt7Display3fmt: exports1['liberyx_runtime.so:_RNvXso_NtCscviJhzjbUDx_4pyo36pycellNtB5_16PyBorrowMutErrorNtNtCsidipMUxUeKa_4core3fmt7Display3fmt'],
        _RNvXso_NtCsidipMUxUeKa_4core4cellNtB5_14BorrowMutErrorNtNtB7_3fmt7Display3fmt: exports1['liberyx_runtime.so:_RNvXso_NtCsidipMUxUeKa_4core4cellNtB5_14BorrowMutErrorNtNtB7_3fmt7Display3fmt'],
        _RNvXso_NtNtCsidipMUxUeKa_4core3fmt3numtNtB7_8UpperHex3fmt: exports1['liberyx_runtime.so:_RNvXso_NtNtCsidipMUxUeKa_4core3fmt3numtNtB7_8UpperHex3fmt'],
        _RNvXss_NtNtCs156tPVBHeXz_5alloc3ffi5c_strNtB5_8NulErrorNtNtCsidipMUxUeKa_4core3fmt7Display3fmt: exports1['liberyx_runtime.so:_RNvXss_NtNtCs156tPVBHeXz_5alloc3ffi5c_strNtB5_8NulErrorNtNtCsidipMUxUeKa_4core3fmt7Display3fmt'],
        _RNvXss_NtNtCsidipMUxUeKa_4core3fmt3nummNtB7_5Octal3fmt: exports1['liberyx_runtime.so:_RNvXss_NtNtCsidipMUxUeKa_4core3fmt3nummNtB7_5Octal3fmt'],
        _RNvXsu_NtNtCsidipMUxUeKa_4core3fmt3nummNtB7_8LowerHex3fmt: exports1['liberyx_runtime.so:_RNvXsu_NtNtCsidipMUxUeKa_4core3fmt3nummNtB7_8LowerHex3fmt'],
        _RNvXsu_NtNtNtCs5XY3BH99Eqp_3std3sys2fs4unixNtB5_4ModeNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt: exports1['liberyx_runtime.so:_RNvXsu_NtNtNtCs5XY3BH99Eqp_3std3sys2fs4unixNtB5_4ModeNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt'],
        _RNvXsx_NtCs5XY3BH99Eqp_3std2fsNtB5_8FileTypeNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt: exports1['liberyx_runtime.so:_RNvXsx_NtCs5XY3BH99Eqp_3std2fsNtB5_8FileTypeNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt'],
      },
      'GOT.mem': {
        PyBaseObject_Type: exports1['liberyx_runtime.so:PyBaseObject_Type'],
        PyBool_Type: exports1['liberyx_runtime.so:PyBool_Type'],
        PyByteArray_Type: exports1['liberyx_runtime.so:PyByteArray_Type'],
        PyBytes_Type: exports1['liberyx_runtime.so:PyBytes_Type'],
        PyDict_Type: exports1['liberyx_runtime.so:PyDict_Type'],
        PyExc_AttributeError: exports1['liberyx_runtime.so:PyExc_AttributeError'],
        PyExc_BaseException: exports1['liberyx_runtime.so:PyExc_BaseException'],
        PyExc_BlockingIOError: exports1['liberyx_runtime.so:PyExc_BlockingIOError'],
        PyExc_BrokenPipeError: exports1['liberyx_runtime.so:PyExc_BrokenPipeError'],
        PyExc_ConnectionAbortedError: exports1['liberyx_runtime.so:PyExc_ConnectionAbortedError'],
        PyExc_ConnectionRefusedError: exports1['liberyx_runtime.so:PyExc_ConnectionRefusedError'],
        PyExc_ConnectionResetError: exports1['liberyx_runtime.so:PyExc_ConnectionResetError'],
        PyExc_FileExistsError: exports1['liberyx_runtime.so:PyExc_FileExistsError'],
        PyExc_FileNotFoundError: exports1['liberyx_runtime.so:PyExc_FileNotFoundError'],
        PyExc_ImportError: exports1['liberyx_runtime.so:PyExc_ImportError'],
        PyExc_InterruptedError: exports1['liberyx_runtime.so:PyExc_InterruptedError'],
        PyExc_IsADirectoryError: exports1['liberyx_runtime.so:PyExc_IsADirectoryError'],
        PyExc_MemoryError: exports1['liberyx_runtime.so:PyExc_MemoryError'],
        PyExc_NotADirectoryError: exports1['liberyx_runtime.so:PyExc_NotADirectoryError'],
        PyExc_OSError: exports1['liberyx_runtime.so:PyExc_OSError'],
        PyExc_OverflowError: exports1['liberyx_runtime.so:PyExc_OverflowError'],
        PyExc_PermissionError: exports1['liberyx_runtime.so:PyExc_PermissionError'],
        PyExc_RuntimeError: exports1['liberyx_runtime.so:PyExc_RuntimeError'],
        PyExc_SystemError: exports1['liberyx_runtime.so:PyExc_SystemError'],
        PyExc_TimeoutError: exports1['liberyx_runtime.so:PyExc_TimeoutError'],
        PyExc_TypeError: exports1['liberyx_runtime.so:PyExc_TypeError'],
        PyExc_UnicodeDecodeError: exports1['liberyx_runtime.so:PyExc_UnicodeDecodeError'],
        PyExc_ValueError: exports1['liberyx_runtime.so:PyExc_ValueError'],
        PyList_Type: exports1['liberyx_runtime.so:PyList_Type'],
        PyLong_Type: exports1['liberyx_runtime.so:PyLong_Type'],
        PyModule_Type: exports1['liberyx_runtime.so:PyModule_Type'],
        PyRange_Type: exports1['liberyx_runtime.so:PyRange_Type'],
        PySuper_Type: exports1['liberyx_runtime.so:PySuper_Type'],
        PyTuple_Type: exports1['liberyx_runtime.so:PyTuple_Type'],
        PyType_Type: exports1['liberyx_runtime.so:PyType_Type'],
        PyUnicode_Type: exports1['liberyx_runtime.so:PyUnicode_Type'],
        _CLOCK_MONOTONIC: exports1['liberyx_runtime.so:_CLOCK_MONOTONIC'],
        _CLOCK_REALTIME: exports1['liberyx_runtime.so:_CLOCK_REALTIME'],
        _PyWeakref_CallableProxyType: exports1['liberyx_runtime.so:_PyWeakref_CallableProxyType'],
        _PyWeakref_ProxyType: exports1['liberyx_runtime.so:_PyWeakref_ProxyType'],
        _PyWeakref_RefType: exports1['liberyx_runtime.so:_PyWeakref_RefType'],
        _Py_FalseStruct: exports1['liberyx_runtime.so:_Py_FalseStruct'],
        _Py_NoneStruct: exports1['liberyx_runtime.so:_Py_NoneStruct'],
        _Py_TrueStruct: exports1['liberyx_runtime.so:_Py_TrueStruct'],
        _RNvCsfk0Zuc3kHNL_13wit_dylib_ffi5WIT_T: exports1['liberyx_runtime.so:_RNvCsfk0Zuc3kHNL_13wit_dylib_ffi5WIT_T'],
        _RNvNCNvNtNtCs5XY3BH99Eqp_3std6thread9spawnhook11SPAWN_HOOKS023___RUST_STD_INTERNAL_VAL: exports1['liberyx_runtime.so:_RNvNCNvNtNtCs5XY3BH99Eqp_3std6thread9spawnhook11SPAWN_HOOKS023___RUST_STD_INTERNAL_VAL'],
        _RNvNCNvNtNtCscviJhzjbUDx_4pyo38internal5state12ATTACH_COUNT023___RUST_STD_INTERNAL_VAL: exports1['liberyx_runtime.so:_RNvNCNvNtNtCscviJhzjbUDx_4pyo38internal5state12ATTACH_COUNT023___RUST_STD_INTERNAL_VAL'],
        _RNvNCNvNvMNtNtCs5XY3BH99Eqp_3std4hash6randomNtB8_11RandomState3new4KEYS023___RUST_STD_INTERNAL_VAL: exports1['liberyx_runtime.so:_RNvNCNvNvMNtNtCs5XY3BH99Eqp_3std4hash6randomNtB8_11RandomState3new4KEYS023___RUST_STD_INTERNAL_VAL'],
        _RNvNCNvNvNtNtNtCs5XY3BH99Eqp_3std4sync4mpmc5waker17current_thread_id5DUMMY023___RUST_STD_INTERNAL_VAL: exports1['liberyx_runtime.so:_RNvNCNvNvNtNtNtCs5XY3BH99Eqp_3std4sync4mpmc5waker17current_thread_id5DUMMY023___RUST_STD_INTERNAL_VAL'],
        _RNvNCNvXs1_NtNtNtCscviJhzjbUDx_4pyo35types7weakref9referenceNtB9_18PyWeakrefReferenceNtNtBf_11type_object10PyTypeInfo15type_object_raw04TYPE: exports1['liberyx_runtime.so:_RNvNCNvXs1_NtNtNtCscviJhzjbUDx_4pyo35types7weakref9referenceNtB9_18PyWeakrefReferenceNtNtBf_11type_object10PyTypeInfo15type_object_raw04TYPE'],
        _RNvNCNvXs6_NtNtCscviJhzjbUDx_4pyo35types8datetimeNtB9_6PyDateNtNtBd_11type_object10PyTypeInfo15type_object_raw04TYPE: exports1['liberyx_runtime.so:_RNvNCNvXs6_NtNtCscviJhzjbUDx_4pyo35types8datetimeNtB9_6PyDateNtNtBd_11type_object10PyTypeInfo15type_object_raw04TYPE'],
        _RNvNCNvXs9_NtNtCscviJhzjbUDx_4pyo35types8datetimeNtB9_10PyDateTimeNtNtBd_11type_object10PyTypeInfo15type_object_raw04TYPE: exports1['liberyx_runtime.so:_RNvNCNvXs9_NtNtCscviJhzjbUDx_4pyo35types8datetimeNtB9_10PyDateTimeNtNtBd_11type_object10PyTypeInfo15type_object_raw04TYPE'],
        _RNvNCNvXsc_NtNtCscviJhzjbUDx_4pyo35types8datetimeNtB9_6PyTimeNtNtBd_11type_object10PyTypeInfo15type_object_raw04TYPE: exports1['liberyx_runtime.so:_RNvNCNvXsc_NtNtCscviJhzjbUDx_4pyo35types8datetimeNtB9_6PyTimeNtNtBd_11type_object10PyTypeInfo15type_object_raw04TYPE'],
        _RNvNCNvXsf_NtNtCscviJhzjbUDx_4pyo35types8datetimeNtB9_8PyTzInfoNtNtBd_11type_object10PyTypeInfo15type_object_raw04TYPE: exports1['liberyx_runtime.so:_RNvNCNvXsf_NtNtCscviJhzjbUDx_4pyo35types8datetimeNtB9_8PyTzInfoNtNtBd_11type_object10PyTypeInfo15type_object_raw04TYPE'],
        _RNvNCNvXsi_NtNtCscviJhzjbUDx_4pyo35types8datetimeNtB9_7PyDeltaNtNtBd_11type_object10PyTypeInfo15type_object_raw04TYPE: exports1['liberyx_runtime.so:_RNvNCNvXsi_NtNtCscviJhzjbUDx_4pyo35types8datetimeNtB9_7PyDeltaNtNtBd_11type_object10PyTypeInfo15type_object_raw04TYPE'],
        _RNvNtCs5XY3BH99Eqp_3std5alloc4HOOK: exports1['liberyx_runtime.so:_RNvNtCs5XY3BH99Eqp_3std5alloc4HOOK'],
        _RNvNtCs5XY3BH99Eqp_3std9panicking4HOOK: exports1['liberyx_runtime.so:_RNvNtCs5XY3BH99Eqp_3std9panicking4HOOK'],
        _RNvNtCsaVdva8B9hP2_4libc4wasi14CLOCK_REALTIME: exports1['liberyx_runtime.so:_RNvNtCsaVdva8B9hP2_4libc4wasi14CLOCK_REALTIME'],
        _RNvNtNtCs5XY3BH99Eqp_3std6thread7current7CURRENT: exports1['liberyx_runtime.so:_RNvNtNtCs5XY3BH99Eqp_3std6thread7current7CURRENT'],
        _RNvNtNtCs5XY3BH99Eqp_3std9panicking11panic_count18GLOBAL_PANIC_COUNT: exports1['liberyx_runtime.so:_RNvNtNtCs5XY3BH99Eqp_3std9panicking11panic_count18GLOBAL_PANIC_COUNT'],
        _RNvNtNtNtCs5XY3BH99Eqp_3std6thread7current2id2ID: exports1['liberyx_runtime.so:_RNvNtNtNtCs5XY3BH99Eqp_3std6thread7current2id2ID'],
        _RNvNtNtNtCsidipMUxUeKa_4core3num7dec2flt5table17POWER_OF_FIVE_128: exports1['liberyx_runtime.so:_RNvNtNtNtCsidipMUxUeKa_4core3num7dec2flt5table17POWER_OF_FIVE_128'],
        _RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9lowercase14BITSET_MAPPING: exports1['liberyx_runtime.so:_RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9lowercase14BITSET_MAPPING'],
        _RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9lowercase16BITSET_CANONICAL: exports1['liberyx_runtime.so:_RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9lowercase16BITSET_CANONICAL'],
        _RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9lowercase17BITSET_CHUNKS_MAP: exports1['liberyx_runtime.so:_RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9lowercase17BITSET_CHUNKS_MAP'],
        _RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9lowercase19BITSET_INDEX_CHUNKS: exports1['liberyx_runtime.so:_RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9lowercase19BITSET_INDEX_CHUNKS'],
        _RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9uppercase14BITSET_MAPPING: exports1['liberyx_runtime.so:_RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9uppercase14BITSET_MAPPING'],
        _RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9uppercase16BITSET_CANONICAL: exports1['liberyx_runtime.so:_RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9uppercase16BITSET_CANONICAL'],
        _RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9uppercase17BITSET_CHUNKS_MAP: exports1['liberyx_runtime.so:_RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9uppercase17BITSET_CHUNKS_MAP'],
        _RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9uppercase19BITSET_INDEX_CHUNKS: exports1['liberyx_runtime.so:_RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9uppercase19BITSET_INDEX_CHUNKS'],
        _RNvNtNtNtNtCsidipMUxUeKa_4core3num7flt2dec8strategy5grisu12CACHED_POW10: exports1['liberyx_runtime.so:_RNvNtNtNtNtCsidipMUxUeKa_4core3num7flt2dec8strategy5grisu12CACHED_POW10'],
        _RNvNvMs6_NtNtCsidipMUxUeKa_4core4task4wakeNtB7_5Waker11from_fn_ptr6VTABLE: exports1['liberyx_runtime.so:_RNvNvMs6_NtNtCsidipMUxUeKa_4core4task4wakeNtB7_5Waker11from_fn_ptr6VTABLE'],
        _RNvNvMsb_NtNtCsidipMUxUeKa_4core4task4wakeNtB7_10LocalWaker11from_fn_ptr6VTABLE: exports1['liberyx_runtime.so:_RNvNvMsb_NtNtCsidipMUxUeKa_4core4task4wakeNtB7_10LocalWaker11from_fn_ptr6VTABLE'],
        _RNvNvNtNtCs5XY3BH99Eqp_3std2io5stdio6stderr8INSTANCE: exports1['liberyx_runtime.so:_RNvNvNtNtCs5XY3BH99Eqp_3std2io5stdio6stderr8INSTANCE'],
        _RNvNvXNtNtCscviJhzjbUDx_4pyo35types8sequenceNtB4_10PySequenceNtNtB8_11type_object10PyTypeInfo15type_object_raw4TYPE: exports1['liberyx_runtime.so:_RNvNvXNtNtCscviJhzjbUDx_4pyo35types8sequenceNtB4_10PySequenceNtNtB8_11type_object10PyTypeInfo15type_object_raw4TYPE'],
        errno: exports1['liberyx_runtime.so:errno'],
      },
      env: {
        PyBuffer_Release: exports9.PyBuffer_Release,
        PyByteArray_AsString: exports9.PyByteArray_AsString,
        PyByteArray_FromObject: exports9.PyByteArray_FromObject,
        PyByteArray_FromStringAndSize: exports9.PyByteArray_FromStringAndSize,
        PyByteArray_Resize: exports9.PyByteArray_Resize,
        PyByteArray_Size: exports9.PyByteArray_Size,
        PyBytes_AsString: exports9.PyBytes_AsString,
        PyBytes_FromStringAndSize: exports9.PyBytes_FromStringAndSize,
        PyBytes_Size: exports9.PyBytes_Size,
        PyCMethod_New: exports9.PyCMethod_New,
        PyCallable_Check: exports9.PyCallable_Check,
        PyCapsule_GetContext: exports9.PyCapsule_GetContext,
        PyCapsule_GetName: exports9.PyCapsule_GetName,
        PyCapsule_GetPointer: exports9.PyCapsule_GetPointer,
        PyCapsule_IsValid: exports9.PyCapsule_IsValid,
        PyCapsule_SetContext: exports9.PyCapsule_SetContext,
        PyComplex_FromDoubles: exports9.PyComplex_FromDoubles,
        PyComplex_ImagAsDouble: exports9.PyComplex_ImagAsDouble,
        PyComplex_RealAsDouble: exports9.PyComplex_RealAsDouble,
        PyDictProxy_New: exports9.PyDictProxy_New,
        PyDict_Clear: exports9.PyDict_Clear,
        PyDict_Contains: exports9.PyDict_Contains,
        PyDict_Copy: exports9.PyDict_Copy,
        PyDict_DelItem: exports9.PyDict_DelItem,
        PyDict_GetItemString: exports9.PyDict_GetItemString,
        PyDict_GetItemWithError: exports9.PyDict_GetItemWithError,
        PyDict_Items: exports9.PyDict_Items,
        PyDict_Keys: exports9.PyDict_Keys,
        PyDict_Merge: exports9.PyDict_Merge,
        PyDict_MergeFromSeq2: exports9.PyDict_MergeFromSeq2,
        PyDict_New: exports9.PyDict_New,
        PyDict_SetItem: exports9.PyDict_SetItem,
        PyDict_SetItemString: exports9.PyDict_SetItemString,
        PyDict_Size: exports9.PyDict_Size,
        PyDict_Update: exports9.PyDict_Update,
        PyDict_Values: exports9.PyDict_Values,
        PyErr_CheckSignals: exports9.PyErr_CheckSignals,
        PyErr_Clear: exports9.PyErr_Clear,
        PyErr_DisplayException: exports9.PyErr_DisplayException,
        PyErr_GetRaisedException: exports9.PyErr_GetRaisedException,
        PyErr_GivenExceptionMatches: exports9.PyErr_GivenExceptionMatches,
        PyErr_NewExceptionWithDoc: exports9.PyErr_NewExceptionWithDoc,
        PyErr_Occurred: exports9.PyErr_Occurred,
        PyErr_Print: exports9.PyErr_Print,
        PyErr_PrintEx: exports9.PyErr_PrintEx,
        PyErr_SetObject: exports9.PyErr_SetObject,
        PyErr_SetRaisedException: exports9.PyErr_SetRaisedException,
        PyErr_SetString: exports9.PyErr_SetString,
        PyErr_WarnEx: exports9.PyErr_WarnEx,
        PyErr_WarnExplicit: exports9.PyErr_WarnExplicit,
        PyErr_WriteUnraisable: exports9.PyErr_WriteUnraisable,
        PyEval_EvalCode: exports9.PyEval_EvalCode,
        PyEval_GetBuiltins: exports9.PyEval_GetBuiltins,
        PyEval_RestoreThread: exports9.PyEval_RestoreThread,
        PyEval_SaveThread: exports9.PyEval_SaveThread,
        PyException_GetCause: exports9.PyException_GetCause,
        PyException_GetTraceback: exports9.PyException_GetTraceback,
        PyException_SetCause: exports9.PyException_SetCause,
        PyException_SetTraceback: exports9.PyException_SetTraceback,
        PyFloat_AsDouble: exports9.PyFloat_AsDouble,
        PyFloat_FromDouble: exports9.PyFloat_FromDouble,
        PyFrozenSet_New: exports9.PyFrozenSet_New,
        PyGILState_Ensure: exports9.PyGILState_Ensure,
        PyGILState_Release: exports9.PyGILState_Release,
        PyImport_AddModule: exports9.PyImport_AddModule,
        PyImport_AppendInittab: exports9.PyImport_AppendInittab,
        PyImport_ExecCodeModuleEx: exports9.PyImport_ExecCodeModuleEx,
        PyImport_Import: exports9.PyImport_Import,
        PyInterpreterState_Get: exports9.PyInterpreterState_Get,
        PyInterpreterState_GetID: exports9.PyInterpreterState_GetID,
        PyIter_Next: exports9.PyIter_Next,
        PyList_Append: exports9.PyList_Append,
        PyList_AsTuple: exports9.PyList_AsTuple,
        PyList_GetItem: exports9.PyList_GetItem,
        PyList_GetSlice: exports9.PyList_GetSlice,
        PyList_Insert: exports9.PyList_Insert,
        PyList_New: exports9.PyList_New,
        PyList_Reverse: exports9.PyList_Reverse,
        PyList_SetItem: exports9.PyList_SetItem,
        PyList_Size: exports9.PyList_Size,
        PyList_Sort: exports9.PyList_Sort,
        PyLong_AsLong: exports9.PyLong_AsLong,
        PyLong_AsLongLong: exports9.PyLong_AsLongLong,
        PyLong_AsUnsignedLongLong: exports9.PyLong_AsUnsignedLongLong,
        PyLong_AsUnsignedLongLongMask: exports9.PyLong_AsUnsignedLongLongMask,
        PyLong_FromLong: exports9.PyLong_FromLong,
        PyLong_FromLongLong: exports9.PyLong_FromLongLong,
        PyLong_FromSsize_t: exports9.PyLong_FromSsize_t,
        PyLong_FromUnsignedLongLong: exports9.PyLong_FromUnsignedLongLong,
        PyMemoryView_FromObject: exports9.PyMemoryView_FromObject,
        PyModule_Create2: exports9.PyModule_Create2,
        PyModule_GetDict: exports9.PyModule_GetDict,
        PyModule_GetFilenameObject: exports9.PyModule_GetFilenameObject,
        PyModule_GetNameObject: exports9.PyModule_GetNameObject,
        PyModule_NewObject: exports9.PyModule_NewObject,
        PyNumber_Absolute: exports9.PyNumber_Absolute,
        PyNumber_Add: exports9.PyNumber_Add,
        PyNumber_And: exports9.PyNumber_And,
        PyNumber_Divmod: exports9.PyNumber_Divmod,
        PyNumber_FloorDivide: exports9.PyNumber_FloorDivide,
        PyNumber_Index: exports9.PyNumber_Index,
        PyNumber_Invert: exports9.PyNumber_Invert,
        PyNumber_Lshift: exports9.PyNumber_Lshift,
        PyNumber_MatrixMultiply: exports9.PyNumber_MatrixMultiply,
        PyNumber_Multiply: exports9.PyNumber_Multiply,
        PyNumber_Negative: exports9.PyNumber_Negative,
        PyNumber_Or: exports9.PyNumber_Or,
        PyNumber_Positive: exports9.PyNumber_Positive,
        PyNumber_Power: exports9.PyNumber_Power,
        PyNumber_Remainder: exports9.PyNumber_Remainder,
        PyNumber_Rshift: exports9.PyNumber_Rshift,
        PyNumber_Subtract: exports9.PyNumber_Subtract,
        PyNumber_TrueDivide: exports9.PyNumber_TrueDivide,
        PyNumber_Xor: exports9.PyNumber_Xor,
        PyOS_FSPath: exports9.PyOS_FSPath,
        PyObject_Call: exports9.PyObject_Call,
        PyObject_CallNoArgs: exports9.PyObject_CallNoArgs,
        PyObject_DelItem: exports9.PyObject_DelItem,
        PyObject_Dir: exports9.PyObject_Dir,
        PyObject_GetAttr: exports9.PyObject_GetAttr,
        PyObject_GetItem: exports9.PyObject_GetItem,
        PyObject_GetIter: exports9.PyObject_GetIter,
        PyObject_Hash: exports9.PyObject_Hash,
        PyObject_IsSubclass: exports9.PyObject_IsSubclass,
        PyObject_IsTrue: exports9.PyObject_IsTrue,
        PyObject_Repr: exports9.PyObject_Repr,
        PyObject_RichCompare: exports9.PyObject_RichCompare,
        PyObject_SetAttr: exports9.PyObject_SetAttr,
        PyObject_SetAttrString: exports9.PyObject_SetAttrString,
        PyObject_SetItem: exports9.PyObject_SetItem,
        PyObject_Size: exports9.PyObject_Size,
        PyObject_Str: exports9.PyObject_Str,
        PyObject_Vectorcall: exports9.PyObject_Vectorcall,
        PyObject_VectorcallMethod: exports9.PyObject_VectorcallMethod,
        PyRun_SimpleString: exports9.PyRun_SimpleString,
        PySequence_Check: exports9.PySequence_Check,
        PySequence_Contains: exports9.PySequence_Contains,
        PySequence_Count: exports9.PySequence_Count,
        PySequence_Index: exports9.PySequence_Index,
        PySequence_List: exports9.PySequence_List,
        PySequence_SetItem: exports9.PySequence_SetItem,
        PySet_Add: exports9.PySet_Add,
        PySet_Contains: exports9.PySet_Contains,
        PySet_Discard: exports9.PySet_Discard,
        PySet_New: exports9.PySet_New,
        PySet_Pop: exports9.PySet_Pop,
        PySet_Size: exports9.PySet_Size,
        PySlice_AdjustIndices: exports9.PySlice_AdjustIndices,
        PySlice_New: exports9.PySlice_New,
        PySlice_Unpack: exports9.PySlice_Unpack,
        PyTraceBack_Print: exports9.PyTraceBack_Print,
        PyTuple_GetItem: exports9.PyTuple_GetItem,
        PyTuple_GetSlice: exports9.PyTuple_GetSlice,
        PyTuple_New: exports9.PyTuple_New,
        PyTuple_SetItem: exports9.PyTuple_SetItem,
        PyTuple_Size: exports9.PyTuple_Size,
        PyType_FromSpec: exports9.PyType_FromSpec,
        PyType_GetFlags: exports9.PyType_GetFlags,
        PyType_GetName: exports9.PyType_GetName,
        PyType_GetQualName: exports9.PyType_GetQualName,
        PyType_GetSlot: exports9.PyType_GetSlot,
        PyType_IsSubtype: exports9.PyType_IsSubtype,
        PyUnicodeDecodeError_Create: exports9.PyUnicodeDecodeError_Create,
        PyUnicode_AsEncodedString: exports9.PyUnicode_AsEncodedString,
        PyUnicode_AsUTF8: exports9.PyUnicode_AsUTF8,
        PyUnicode_AsUTF8AndSize: exports9.PyUnicode_AsUTF8AndSize,
        PyUnicode_AsUTF8String: exports9.PyUnicode_AsUTF8String,
        PyUnicode_DecodeFSDefaultAndSize: exports9.PyUnicode_DecodeFSDefaultAndSize,
        PyUnicode_EncodeFSDefault: exports9.PyUnicode_EncodeFSDefault,
        PyUnicode_FromEncodedObject: exports9.PyUnicode_FromEncodedObject,
        PyUnicode_FromStringAndSize: exports9.PyUnicode_FromStringAndSize,
        PyUnicode_InternInPlace: exports9.PyUnicode_InternInPlace,
        PyWeakref_GetObject: exports9.PyWeakref_GetObject,
        PyWeakref_NewProxy: exports9.PyWeakref_NewProxy,
        PyWeakref_NewRef: exports9.PyWeakref_NewRef,
        Py_CompileString: exports9.Py_CompileString,
        Py_DecRef: exports9.Py_DecRef,
        Py_GenericAlias: exports9.Py_GenericAlias,
        Py_GetVersion: exports9.Py_GetVersion,
        Py_IncRef: exports9.Py_IncRef,
        Py_InitializeEx: exports9.Py_InitializeEx,
        Py_IsInitialized: exports9.Py_IsInitialized,
        Py_NewRef: exports9.Py_NewRef,
        Py_XNewRef: exports9.Py_XNewRef,
        _Py_DecRef: exports9._Py_DecRef,
        _Py_IncRef: exports9._Py_IncRef,
        __indirect_function_table: exports1.__indirect_function_table,
        __memory_base: exports1['liberyx_runtime.so:memory_base'],
        __stack_pointer: exports1.__stack_pointer,
        __table_base: exports1['liberyx_runtime.so:table_base'],
        __wasilibc_get_environ: exports4.__wasilibc_get_environ,
        __wasilibc_reset_preopens: exports4.__wasilibc_reset_preopens,
        abort: exports4.abort,
        calloc: exports4.calloc,
        chdir: exports4.chdir,
        chmod: exports4.chmod,
        clock_gettime: exports4.clock_gettime,
        clock_nanosleep: exports4.clock_nanosleep,
        close: exports4.close,
        closedir: exports4.closedir,
        dirfd: exports4.dirfd,
        exit: exports4.exit,
        fchmod: exports4.fchmod,
        fcntl: exports4.fcntl,
        fdopendir: exports4.fdopendir,
        free: exports4.free,
        fstat: exports4.fstat,
        fsync: exports4.fsync,
        ftruncate: exports4.ftruncate,
        futimens: exports4.futimens,
        getcwd: exports4.getcwd,
        getenv: exports4.getenv,
        linkat: exports4.linkat,
        lseek: exports4.lseek,
        lstat: exports4.lstat,
        malloc: exports4.malloc,
        memcmp: exports4.memcmp,
        memory: exports1.memory,
        mkdir: exports4.mkdir,
        open: exports4.open,
        openat: exports4.openat,
        opendir: exports4.opendir,
        posix_memalign: exports4.posix_memalign,
        pread: exports4.pread,
        pthread_attr_destroy: exports4.pthread_attr_destroy,
        pthread_attr_init: exports4.pthread_attr_init,
        pthread_attr_setstacksize: exports4.pthread_attr_setstacksize,
        pthread_create: exports4.pthread_create,
        pthread_detach: exports4.pthread_detach,
        pthread_join: exports4.pthread_join,
        pwrite: exports4.pwrite,
        read: exports4.read,
        readdir: exports4.readdir,
        readlink: exports4.readlink,
        readv: exports4.readv,
        realloc: exports4.realloc,
        realpath: exports4.realpath,
        rename: exports4.rename,
        rmdir: exports4.rmdir,
        sched_yield: exports4.sched_yield,
        setenv: exports4.setenv,
        stat: exports4.stat,
        strerror_r: exports4.strerror_r,
        strlen: exports4.strlen,
        symlink: exports4.symlink,
        sysconf: exports4.sysconf,
        unlink: exports4.unlink,
        unlinkat: exports4.unlinkat,
        unsetenv: exports4.unsetenv,
        utimensat: exports4.utimensat,
        write: exports4.write,
        writev: exports4.writev,
      },
      wasi_snapshot_preview1: {
        args_get: exports1['wasi_snapshot_preview1:args_get'],
        args_sizes_get: exports1['wasi_snapshot_preview1:args_sizes_get'],
        clock_res_get: exports1['wasi_snapshot_preview1:clock_res_get'],
        clock_time_get: exports1['wasi_snapshot_preview1:clock_time_get'],
        environ_get: exports1['wasi_snapshot_preview1:environ_get'],
        environ_sizes_get: exports1['wasi_snapshot_preview1:environ_sizes_get'],
        fd_advise: exports1['wasi_snapshot_preview1:fd_advise'],
        fd_allocate: exports1['wasi_snapshot_preview1:fd_allocate'],
        fd_close: exports1['wasi_snapshot_preview1:fd_close'],
        fd_datasync: exports1['wasi_snapshot_preview1:fd_datasync'],
        fd_fdstat_get: exports1['wasi_snapshot_preview1:fd_fdstat_get'],
        fd_fdstat_set_flags: exports1['wasi_snapshot_preview1:fd_fdstat_set_flags'],
        fd_fdstat_set_rights: exports1['wasi_snapshot_preview1:fd_fdstat_set_rights'],
        fd_filestat_get: exports1['wasi_snapshot_preview1:fd_filestat_get'],
        fd_filestat_set_size: exports1['wasi_snapshot_preview1:fd_filestat_set_size'],
        fd_filestat_set_times: exports1['wasi_snapshot_preview1:fd_filestat_set_times'],
        fd_pread: exports1['wasi_snapshot_preview1:fd_pread'],
        fd_prestat_dir_name: exports1['wasi_snapshot_preview1:fd_prestat_dir_name'],
        fd_prestat_get: exports1['wasi_snapshot_preview1:fd_prestat_get'],
        fd_pwrite: exports1['wasi_snapshot_preview1:fd_pwrite'],
        fd_read: exports1['wasi_snapshot_preview1:fd_read'],
        fd_readdir: exports1['wasi_snapshot_preview1:fd_readdir'],
        fd_renumber: exports1['wasi_snapshot_preview1:fd_renumber'],
        fd_seek: exports1['wasi_snapshot_preview1:fd_seek'],
        fd_sync: exports1['wasi_snapshot_preview1:fd_sync'],
        fd_tell: exports1['wasi_snapshot_preview1:fd_tell'],
        fd_write: exports1['wasi_snapshot_preview1:fd_write'],
        path_create_directory: exports1['wasi_snapshot_preview1:path_create_directory'],
        path_filestat_get: exports1['wasi_snapshot_preview1:path_filestat_get'],
        path_filestat_set_times: exports1['wasi_snapshot_preview1:path_filestat_set_times'],
        path_link: exports1['wasi_snapshot_preview1:path_link'],
        path_open: exports1['wasi_snapshot_preview1:path_open'],
        path_readlink: exports1['wasi_snapshot_preview1:path_readlink'],
        path_remove_directory: exports1['wasi_snapshot_preview1:path_remove_directory'],
        path_rename: exports1['wasi_snapshot_preview1:path_rename'],
        path_symlink: exports1['wasi_snapshot_preview1:path_symlink'],
        path_unlink_file: exports1['wasi_snapshot_preview1:path_unlink_file'],
        poll_oneoff: exports1['wasi_snapshot_preview1:poll_oneoff'],
        proc_exit: exports1['wasi_snapshot_preview1:proc_exit'],
        proc_raise: exports1['wasi_snapshot_preview1:proc_raise'],
        random_get: exports1['wasi_snapshot_preview1:random_get'],
        reset_adapter_state: exports1['wasi_snapshot_preview1:reset_adapter_state'],
        sched_yield: exports1['wasi_snapshot_preview1:sched_yield'],
        sock_accept: exports1['wasi_snapshot_preview1:sock_accept'],
        sock_recv: exports1['wasi_snapshot_preview1:sock_recv'],
        sock_send: exports1['wasi_snapshot_preview1:sock_send'],
        sock_shutdown: exports1['wasi_snapshot_preview1:sock_shutdown'],
      },
    }));
    ({ exports: exports11 } = yield instantiateCore(yield module10, {
      $root: {
        '[async-lower]invoke': GlobalComponentAsyncLowers.lookup(10, '$root#invoke')?.bind(null, exports0['197']),
        'list-callbacks': exports0['198'],
        'report-trace': exports0['199'],
      },
      '[export]$root': {
        '[task-return]clear-state': trampoline46,
        '[task-return]execute': trampoline164,
        '[task-return]restore-state': trampoline166,
        '[task-return]snapshot-state': trampoline165,
      },
      env: {
        __indirect_function_table: exports1.__indirect_function_table,
        __memory_base: exports1['liberyx_bindings.so:memory_base'],
        __stack_pointer: exports1.__stack_pointer,
        __table_base: exports1['liberyx_bindings.so:table_base'],
        cabi_realloc: exports4.cabi_realloc,
        memory: exports1.memory,
        wit_dylib_dealloc_bytes: exports10.wit_dylib_dealloc_bytes,
        wit_dylib_export_async_call: exports10.wit_dylib_export_async_call,
        wit_dylib_export_async_callback: exports10.wit_dylib_export_async_callback,
        wit_dylib_export_call: exports10.wit_dylib_export_call,
        wit_dylib_export_finish: exports10.wit_dylib_export_finish,
        wit_dylib_export_start: exports10.wit_dylib_export_start,
        wit_dylib_initialize: exports10.wit_dylib_initialize,
        wit_dylib_list_append: exports10.wit_dylib_list_append,
        wit_dylib_pop_bool: exports10.wit_dylib_pop_bool,
        wit_dylib_pop_borrow: exports10.wit_dylib_pop_borrow,
        wit_dylib_pop_char: exports10.wit_dylib_pop_char,
        wit_dylib_pop_enum: exports10.wit_dylib_pop_enum,
        wit_dylib_pop_f32: exports10.wit_dylib_pop_f32,
        wit_dylib_pop_f64: exports10.wit_dylib_pop_f64,
        wit_dylib_pop_flags: exports10.wit_dylib_pop_flags,
        wit_dylib_pop_future: exports10.wit_dylib_pop_future,
        wit_dylib_pop_iter: exports10.wit_dylib_pop_iter,
        wit_dylib_pop_iter_next: exports10.wit_dylib_pop_iter,
        wit_dylib_pop_list: exports10.wit_dylib_pop_list,
        wit_dylib_pop_option: exports10.wit_dylib_pop_option,
        wit_dylib_pop_own: exports10.wit_dylib_pop_borrow,
        wit_dylib_pop_record: exports10.wit_dylib_pop_record,
        wit_dylib_pop_result: exports10.wit_dylib_pop_result,
        wit_dylib_pop_s16: exports10.wit_dylib_pop_s16,
        wit_dylib_pop_s32: exports10.wit_dylib_pop_s32,
        wit_dylib_pop_s64: exports10.wit_dylib_pop_s64,
        wit_dylib_pop_s8: exports10.wit_dylib_pop_s8,
        wit_dylib_pop_stream: exports10.wit_dylib_pop_stream,
        wit_dylib_pop_string: exports10.wit_dylib_pop_string,
        wit_dylib_pop_tuple: exports10.wit_dylib_pop_tuple,
        wit_dylib_pop_u16: exports10.wit_dylib_pop_u16,
        wit_dylib_pop_u32: exports10.wit_dylib_pop_u32,
        wit_dylib_pop_u64: exports10.wit_dylib_pop_u64,
        wit_dylib_pop_u8: exports10.wit_dylib_pop_u8,
        wit_dylib_pop_variant: exports10.wit_dylib_pop_variant,
        wit_dylib_push_bool: exports10.wit_dylib_push_bool,
        wit_dylib_push_borrow: exports10.wit_dylib_push_borrow,
        wit_dylib_push_char: exports10.wit_dylib_push_char,
        wit_dylib_push_enum: exports10.wit_dylib_push_enum,
        wit_dylib_push_f32: exports10.wit_dylib_push_f32,
        wit_dylib_push_f64: exports10.wit_dylib_push_f64,
        wit_dylib_push_flags: exports10.wit_dylib_push_flags,
        wit_dylib_push_future: exports10.wit_dylib_push_future,
        wit_dylib_push_list: exports10.wit_dylib_push_list,
        wit_dylib_push_option: exports10.wit_dylib_push_option,
        wit_dylib_push_own: exports10.wit_dylib_push_borrow,
        wit_dylib_push_record: exports10.wit_dylib_pop_record,
        wit_dylib_push_result: exports10.wit_dylib_push_result,
        wit_dylib_push_s16: exports10.wit_dylib_push_s16,
        wit_dylib_push_s32: exports10.wit_dylib_push_s32,
        wit_dylib_push_s64: exports10.wit_dylib_push_s64,
        wit_dylib_push_s8: exports10.wit_dylib_push_s8,
        wit_dylib_push_stream: exports10.wit_dylib_push_stream,
        wit_dylib_push_string: exports10.wit_dylib_push_string,
        wit_dylib_push_tuple: exports10.wit_dylib_pop_tuple,
        wit_dylib_push_u16: exports10.wit_dylib_push_u16,
        wit_dylib_push_u32: exports10.wit_dylib_push_u32,
        wit_dylib_push_u64: exports10.wit_dylib_push_u64,
        wit_dylib_push_u8: exports10.wit_dylib_push_u8,
        wit_dylib_push_variant: exports10.wit_dylib_push_variant,
        wit_dylib_resource_dtor: exports10.wit_dylib_resource_dtor,
      },
      'eryx:net/tcp@0.1.0': {
        close: trampoline44,
        connect: exports0['191'],
        read: exports0['192'],
        write: exports0['193'],
      },
      'eryx:net/tls@0.1.0': {
        close: trampoline45,
        read: exports0['195'],
        upgrade: exports0['194'],
        write: exports0['196'],
      },
    }));
    memory0 = exports1.memory;
    GlobalComponentMemories.save({ idx: 0, componentIdx: 1, memory: memory0 });
    realloc0 = exports2.cabi_import_realloc;
    realloc1 = exports4.cabi_realloc;
    realloc2 = exports11.cabi_realloc;
    ({ exports: exports12 } = yield instantiateCore(yield module13, {
      '': {
        $imports: exports0.$imports,
        '0': exports2.adapter_close_badfd,
        '1': exports2.adapter_open_badfd,
        '10': exports2.fd_close,
        '100': trampoline81,
        '101': trampoline82,
        '102': trampoline97,
        '103': trampoline83,
        '104': trampoline98,
        '105': trampoline99,
        '106': trampoline100,
        '107': trampoline101,
        '108': trampoline63,
        '109': trampoline64,
        '11': exports2.fd_datasync,
        '110': trampoline65,
        '111': trampoline50,
        '112': trampoline51,
        '113': trampoline66,
        '114': trampoline52,
        '115': trampoline53,
        '116': trampoline67,
        '117': trampoline102,
        '118': trampoline54,
        '119': trampoline56,
        '12': exports2.fd_fdstat_get,
        '120': trampoline57,
        '121': trampoline58,
        '122': trampoline69,
        '123': trampoline70,
        '124': trampoline71,
        '125': trampoline72,
        '126': trampoline73,
        '127': trampoline103,
        '128': trampoline59,
        '129': trampoline60,
        '13': exports2.fd_fdstat_set_flags,
        '130': trampoline61,
        '131': trampoline62,
        '132': trampoline75,
        '133': trampoline76,
        '134': trampoline104,
        '135': trampoline55,
        '136': trampoline105,
        '137': trampoline106,
        '138': trampoline107,
        '139': trampoline108,
        '14': exports2.fd_fdstat_set_rights,
        '140': trampoline109,
        '141': trampoline110,
        '142': trampoline111,
        '143': trampoline112,
        '144': trampoline113,
        '145': trampoline114,
        '146': trampoline115,
        '147': trampoline116,
        '148': trampoline117,
        '149': trampoline118,
        '15': exports2.fd_filestat_get,
        '150': trampoline119,
        '151': trampoline120,
        '152': trampoline121,
        '153': trampoline122,
        '154': trampoline123,
        '155': trampoline124,
        '156': trampoline125,
        '157': trampoline126,
        '158': trampoline127,
        '159': trampoline128,
        '16': exports2.fd_filestat_set_size,
        '160': trampoline129,
        '161': trampoline130,
        '162': trampoline131,
        '163': trampoline132,
        '164': trampoline133,
        '165': trampoline134,
        '166': trampoline135,
        '167': trampoline136,
        '168': trampoline137,
        '169': trampoline138,
        '17': exports2.fd_filestat_set_times,
        '170': trampoline139,
        '171': trampoline140,
        '172': trampoline141,
        '173': trampoline142,
        '174': trampoline143,
        '175': trampoline144,
        '176': trampoline145,
        '177': trampoline146,
        '178': trampoline147,
        '179': trampoline148,
        '18': exports2.fd_pread,
        '180': trampoline88,
        '181': trampoline89,
        '182': trampoline90,
        '183': trampoline49,
        '184': trampoline48,
        '185': trampoline149,
        '186': trampoline150,
        '187': trampoline151,
        '188': trampoline152,
        '189': trampoline153,
        '19': exports2.fd_prestat_dir_name,
        '190': trampoline154,
        '191': trampoline155,
        '192': trampoline156,
        '193': trampoline157,
        '194': trampoline158,
        '195': trampoline159,
        '196': trampoline160,
        '197': trampoline161,
        '198': trampoline162,
        '199': trampoline163,
        '2': exports2.args_get,
        '20': exports2.fd_prestat_get,
        '200': trampoline164,
        '201': trampoline165,
        '202': trampoline166,
        '21': exports2.fd_pwrite,
        '22': exports2.fd_read,
        '23': exports2.fd_readdir,
        '24': exports2.fd_renumber,
        '25': exports2.fd_seek,
        '26': exports2.fd_sync,
        '27': exports2.fd_tell,
        '28': exports2.fd_write,
        '29': exports2.path_create_directory,
        '3': exports2.args_sizes_get,
        '30': exports2.path_filestat_get,
        '31': exports2.path_filestat_set_times,
        '32': exports2.path_link,
        '33': exports2.path_open,
        '34': exports2.path_readlink,
        '35': exports2.path_remove_directory,
        '36': exports2.path_rename,
        '37': exports2.path_symlink,
        '38': exports2.path_unlink_file,
        '39': exports2.poll_oneoff,
        '4': exports2.clock_res_get,
        '40': exports2.proc_exit,
        '41': exports2.random_get,
        '42': exports2.sched_yield,
        '43': exports2.sock_accept,
        '44': exports2.sock_recv,
        '45': exports2.sock_send,
        '46': exports2.sock_shutdown,
        '47': exports2.proc_raise,
        '48': exports2.reset_adapter_state,
        '49': trampoline47,
        '5': exports2.clock_time_get,
        '50': trampoline48,
        '51': trampoline49,
        '52': trampoline50,
        '53': trampoline51,
        '54': trampoline52,
        '55': trampoline53,
        '56': trampoline54,
        '57': trampoline55,
        '58': trampoline56,
        '59': trampoline57,
        '6': exports2.environ_get,
        '60': trampoline58,
        '61': trampoline59,
        '62': trampoline60,
        '63': trampoline61,
        '64': trampoline62,
        '65': trampoline63,
        '66': trampoline64,
        '67': trampoline65,
        '68': trampoline66,
        '69': trampoline67,
        '7': exports2.environ_sizes_get,
        '70': trampoline68,
        '71': trampoline69,
        '72': trampoline70,
        '73': trampoline71,
        '74': trampoline72,
        '75': trampoline73,
        '76': trampoline74,
        '77': trampoline75,
        '78': trampoline76,
        '79': trampoline77,
        '8': exports2.fd_advise,
        '80': trampoline78,
        '81': trampoline79,
        '82': trampoline80,
        '83': trampoline81,
        '84': trampoline82,
        '85': trampoline83,
        '86': trampoline84,
        '87': trampoline85,
        '88': trampoline86,
        '89': trampoline87,
        '9': exports2.fd_allocate,
        '90': trampoline88,
        '91': trampoline89,
        '92': trampoline90,
        '93': trampoline91,
        '94': trampoline92,
        '95': trampoline93,
        '96': trampoline94,
        '97': trampoline95,
        '98': trampoline96,
        '99': trampoline80,
      },
    }));
    ({ exports: exports13 } = yield instantiateCore(yield module11, {
      env: {
        __indirect_function_table: exports1.__indirect_function_table,
        'libc.so:_CLOCK_REALTIME': exports1['libc.so:_CLOCK_REALTIME'],
        'libc.so:__optpos': exports1['libc.so:__optpos'],
        'libc.so:__optreset': exports1['libc.so:__optreset'],
        'libc.so:__signgam': exports1['libc.so:__signgam'],
        'libc.so:__stack_chk_guard': exports1['libc.so:__stack_chk_guard'],
        'libc.so:__wasi_sockets_services_db': exports1['libc.so:__wasi_sockets_services_db'],
        'libc.so:__wasilibc_cwd': exports1['libc.so:__wasilibc_cwd'],
        'libc.so:__wasilibc_environ': exports1['libc.so:__wasilibc_environ'],
        'libc.so:__wasilibc_pthread_self': exports1['libc.so:__wasilibc_pthread_self'],
        'libc.so:errno': exports1['libc.so:errno'],
        'libc.so:getdate_err': exports1['libc.so:getdate_err'],
        'libc.so:memory_base': exports1['libc.so:memory_base'],
        'libc.so:optarg': exports1['libc.so:optarg'],
        'libc.so:opterr': exports1['libc.so:opterr'],
        'libc.so:optind': exports1['libc.so:optind'],
        'libc.so:optopt': exports1['libc.so:optopt'],
        'liberyx_runtime.so:PyBaseObject_Type': exports1['liberyx_runtime.so:PyBaseObject_Type'],
        'liberyx_runtime.so:PyBool_Type': exports1['liberyx_runtime.so:PyBool_Type'],
        'liberyx_runtime.so:PyByteArray_Type': exports1['liberyx_runtime.so:PyByteArray_Type'],
        'liberyx_runtime.so:PyBytes_Type': exports1['liberyx_runtime.so:PyBytes_Type'],
        'liberyx_runtime.so:PyDict_Type': exports1['liberyx_runtime.so:PyDict_Type'],
        'liberyx_runtime.so:PyExc_AttributeError': exports1['liberyx_runtime.so:PyExc_AttributeError'],
        'liberyx_runtime.so:PyExc_BaseException': exports1['liberyx_runtime.so:PyExc_BaseException'],
        'liberyx_runtime.so:PyExc_BlockingIOError': exports1['liberyx_runtime.so:PyExc_BlockingIOError'],
        'liberyx_runtime.so:PyExc_BrokenPipeError': exports1['liberyx_runtime.so:PyExc_BrokenPipeError'],
        'liberyx_runtime.so:PyExc_ConnectionAbortedError': exports1['liberyx_runtime.so:PyExc_ConnectionAbortedError'],
        'liberyx_runtime.so:PyExc_ConnectionRefusedError': exports1['liberyx_runtime.so:PyExc_ConnectionRefusedError'],
        'liberyx_runtime.so:PyExc_ConnectionResetError': exports1['liberyx_runtime.so:PyExc_ConnectionResetError'],
        'liberyx_runtime.so:PyExc_FileExistsError': exports1['liberyx_runtime.so:PyExc_FileExistsError'],
        'liberyx_runtime.so:PyExc_FileNotFoundError': exports1['liberyx_runtime.so:PyExc_FileNotFoundError'],
        'liberyx_runtime.so:PyExc_ImportError': exports1['liberyx_runtime.so:PyExc_ImportError'],
        'liberyx_runtime.so:PyExc_InterruptedError': exports1['liberyx_runtime.so:PyExc_InterruptedError'],
        'liberyx_runtime.so:PyExc_IsADirectoryError': exports1['liberyx_runtime.so:PyExc_IsADirectoryError'],
        'liberyx_runtime.so:PyExc_MemoryError': exports1['liberyx_runtime.so:PyExc_MemoryError'],
        'liberyx_runtime.so:PyExc_NotADirectoryError': exports1['liberyx_runtime.so:PyExc_NotADirectoryError'],
        'liberyx_runtime.so:PyExc_OSError': exports1['liberyx_runtime.so:PyExc_OSError'],
        'liberyx_runtime.so:PyExc_OverflowError': exports1['liberyx_runtime.so:PyExc_OverflowError'],
        'liberyx_runtime.so:PyExc_PermissionError': exports1['liberyx_runtime.so:PyExc_PermissionError'],
        'liberyx_runtime.so:PyExc_RuntimeError': exports1['liberyx_runtime.so:PyExc_RuntimeError'],
        'liberyx_runtime.so:PyExc_SystemError': exports1['liberyx_runtime.so:PyExc_SystemError'],
        'liberyx_runtime.so:PyExc_TimeoutError': exports1['liberyx_runtime.so:PyExc_TimeoutError'],
        'liberyx_runtime.so:PyExc_TypeError': exports1['liberyx_runtime.so:PyExc_TypeError'],
        'liberyx_runtime.so:PyExc_UnicodeDecodeError': exports1['liberyx_runtime.so:PyExc_UnicodeDecodeError'],
        'liberyx_runtime.so:PyExc_ValueError': exports1['liberyx_runtime.so:PyExc_ValueError'],
        'liberyx_runtime.so:PyList_Type': exports1['liberyx_runtime.so:PyList_Type'],
        'liberyx_runtime.so:PyLong_Type': exports1['liberyx_runtime.so:PyLong_Type'],
        'liberyx_runtime.so:PyModule_Type': exports1['liberyx_runtime.so:PyModule_Type'],
        'liberyx_runtime.so:PyRange_Type': exports1['liberyx_runtime.so:PyRange_Type'],
        'liberyx_runtime.so:PySuper_Type': exports1['liberyx_runtime.so:PySuper_Type'],
        'liberyx_runtime.so:PyTuple_Type': exports1['liberyx_runtime.so:PyTuple_Type'],
        'liberyx_runtime.so:PyType_Type': exports1['liberyx_runtime.so:PyType_Type'],
        'liberyx_runtime.so:PyUnicode_Type': exports1['liberyx_runtime.so:PyUnicode_Type'],
        'liberyx_runtime.so:_CLOCK_MONOTONIC': exports1['liberyx_runtime.so:_CLOCK_MONOTONIC'],
        'liberyx_runtime.so:_CLOCK_REALTIME': exports1['liberyx_runtime.so:_CLOCK_REALTIME'],
        'liberyx_runtime.so:_PyWeakref_CallableProxyType': exports1['liberyx_runtime.so:_PyWeakref_CallableProxyType'],
        'liberyx_runtime.so:_PyWeakref_ProxyType': exports1['liberyx_runtime.so:_PyWeakref_ProxyType'],
        'liberyx_runtime.so:_PyWeakref_RefType': exports1['liberyx_runtime.so:_PyWeakref_RefType'],
        'liberyx_runtime.so:_Py_FalseStruct': exports1['liberyx_runtime.so:_Py_FalseStruct'],
        'liberyx_runtime.so:_Py_NoneStruct': exports1['liberyx_runtime.so:_Py_NoneStruct'],
        'liberyx_runtime.so:_Py_TrueStruct': exports1['liberyx_runtime.so:_Py_TrueStruct'],
        'liberyx_runtime.so:_RNvCsfk0Zuc3kHNL_13wit_dylib_ffi5WIT_T': exports1['liberyx_runtime.so:_RNvCsfk0Zuc3kHNL_13wit_dylib_ffi5WIT_T'],
        'liberyx_runtime.so:_RNvNCNvNtNtCs5XY3BH99Eqp_3std6thread9spawnhook11SPAWN_HOOKS023___RUST_STD_INTERNAL_VAL': exports1['liberyx_runtime.so:_RNvNCNvNtNtCs5XY3BH99Eqp_3std6thread9spawnhook11SPAWN_HOOKS023___RUST_STD_INTERNAL_VAL'],
        'liberyx_runtime.so:_RNvNCNvNtNtCscviJhzjbUDx_4pyo38internal5state12ATTACH_COUNT023___RUST_STD_INTERNAL_VAL': exports1['liberyx_runtime.so:_RNvNCNvNtNtCscviJhzjbUDx_4pyo38internal5state12ATTACH_COUNT023___RUST_STD_INTERNAL_VAL'],
        'liberyx_runtime.so:_RNvNCNvNvMNtNtCs5XY3BH99Eqp_3std4hash6randomNtB8_11RandomState3new4KEYS023___RUST_STD_INTERNAL_VAL': exports1['liberyx_runtime.so:_RNvNCNvNvMNtNtCs5XY3BH99Eqp_3std4hash6randomNtB8_11RandomState3new4KEYS023___RUST_STD_INTERNAL_VAL'],
        'liberyx_runtime.so:_RNvNCNvNvNtNtNtCs5XY3BH99Eqp_3std4sync4mpmc5waker17current_thread_id5DUMMY023___RUST_STD_INTERNAL_VAL': exports1['liberyx_runtime.so:_RNvNCNvNvNtNtNtCs5XY3BH99Eqp_3std4sync4mpmc5waker17current_thread_id5DUMMY023___RUST_STD_INTERNAL_VAL'],
        'liberyx_runtime.so:_RNvNCNvXs1_NtNtNtCscviJhzjbUDx_4pyo35types7weakref9referenceNtB9_18PyWeakrefReferenceNtNtBf_11type_object10PyTypeInfo15type_object_raw04TYPE': exports1['liberyx_runtime.so:_RNvNCNvXs1_NtNtNtCscviJhzjbUDx_4pyo35types7weakref9referenceNtB9_18PyWeakrefReferenceNtNtBf_11type_object10PyTypeInfo15type_object_raw04TYPE'],
        'liberyx_runtime.so:_RNvNCNvXs6_NtNtCscviJhzjbUDx_4pyo35types8datetimeNtB9_6PyDateNtNtBd_11type_object10PyTypeInfo15type_object_raw04TYPE': exports1['liberyx_runtime.so:_RNvNCNvXs6_NtNtCscviJhzjbUDx_4pyo35types8datetimeNtB9_6PyDateNtNtBd_11type_object10PyTypeInfo15type_object_raw04TYPE'],
        'liberyx_runtime.so:_RNvNCNvXs9_NtNtCscviJhzjbUDx_4pyo35types8datetimeNtB9_10PyDateTimeNtNtBd_11type_object10PyTypeInfo15type_object_raw04TYPE': exports1['liberyx_runtime.so:_RNvNCNvXs9_NtNtCscviJhzjbUDx_4pyo35types8datetimeNtB9_10PyDateTimeNtNtBd_11type_object10PyTypeInfo15type_object_raw04TYPE'],
        'liberyx_runtime.so:_RNvNCNvXsc_NtNtCscviJhzjbUDx_4pyo35types8datetimeNtB9_6PyTimeNtNtBd_11type_object10PyTypeInfo15type_object_raw04TYPE': exports1['liberyx_runtime.so:_RNvNCNvXsc_NtNtCscviJhzjbUDx_4pyo35types8datetimeNtB9_6PyTimeNtNtBd_11type_object10PyTypeInfo15type_object_raw04TYPE'],
        'liberyx_runtime.so:_RNvNCNvXsf_NtNtCscviJhzjbUDx_4pyo35types8datetimeNtB9_8PyTzInfoNtNtBd_11type_object10PyTypeInfo15type_object_raw04TYPE': exports1['liberyx_runtime.so:_RNvNCNvXsf_NtNtCscviJhzjbUDx_4pyo35types8datetimeNtB9_8PyTzInfoNtNtBd_11type_object10PyTypeInfo15type_object_raw04TYPE'],
        'liberyx_runtime.so:_RNvNCNvXsi_NtNtCscviJhzjbUDx_4pyo35types8datetimeNtB9_7PyDeltaNtNtBd_11type_object10PyTypeInfo15type_object_raw04TYPE': exports1['liberyx_runtime.so:_RNvNCNvXsi_NtNtCscviJhzjbUDx_4pyo35types8datetimeNtB9_7PyDeltaNtNtBd_11type_object10PyTypeInfo15type_object_raw04TYPE'],
        'liberyx_runtime.so:_RNvNtCs5XY3BH99Eqp_3std5alloc4HOOK': exports1['liberyx_runtime.so:_RNvNtCs5XY3BH99Eqp_3std5alloc4HOOK'],
        'liberyx_runtime.so:_RNvNtCs5XY3BH99Eqp_3std9panicking4HOOK': exports1['liberyx_runtime.so:_RNvNtCs5XY3BH99Eqp_3std9panicking4HOOK'],
        'liberyx_runtime.so:_RNvNtCsaVdva8B9hP2_4libc4wasi14CLOCK_REALTIME': exports1['liberyx_runtime.so:_RNvNtCsaVdva8B9hP2_4libc4wasi14CLOCK_REALTIME'],
        'liberyx_runtime.so:_RNvNtNtCs5XY3BH99Eqp_3std6thread7current7CURRENT': exports1['liberyx_runtime.so:_RNvNtNtCs5XY3BH99Eqp_3std6thread7current7CURRENT'],
        'liberyx_runtime.so:_RNvNtNtCs5XY3BH99Eqp_3std9panicking11panic_count18GLOBAL_PANIC_COUNT': exports1['liberyx_runtime.so:_RNvNtNtCs5XY3BH99Eqp_3std9panicking11panic_count18GLOBAL_PANIC_COUNT'],
        'liberyx_runtime.so:_RNvNtNtNtCs5XY3BH99Eqp_3std6thread7current2id2ID': exports1['liberyx_runtime.so:_RNvNtNtNtCs5XY3BH99Eqp_3std6thread7current2id2ID'],
        'liberyx_runtime.so:_RNvNtNtNtCsidipMUxUeKa_4core3num7dec2flt5table17POWER_OF_FIVE_128': exports1['liberyx_runtime.so:_RNvNtNtNtCsidipMUxUeKa_4core3num7dec2flt5table17POWER_OF_FIVE_128'],
        'liberyx_runtime.so:_RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9lowercase14BITSET_MAPPING': exports1['liberyx_runtime.so:_RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9lowercase14BITSET_MAPPING'],
        'liberyx_runtime.so:_RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9lowercase16BITSET_CANONICAL': exports1['liberyx_runtime.so:_RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9lowercase16BITSET_CANONICAL'],
        'liberyx_runtime.so:_RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9lowercase17BITSET_CHUNKS_MAP': exports1['liberyx_runtime.so:_RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9lowercase17BITSET_CHUNKS_MAP'],
        'liberyx_runtime.so:_RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9lowercase19BITSET_INDEX_CHUNKS': exports1['liberyx_runtime.so:_RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9lowercase19BITSET_INDEX_CHUNKS'],
        'liberyx_runtime.so:_RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9uppercase14BITSET_MAPPING': exports1['liberyx_runtime.so:_RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9uppercase14BITSET_MAPPING'],
        'liberyx_runtime.so:_RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9uppercase16BITSET_CANONICAL': exports1['liberyx_runtime.so:_RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9uppercase16BITSET_CANONICAL'],
        'liberyx_runtime.so:_RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9uppercase17BITSET_CHUNKS_MAP': exports1['liberyx_runtime.so:_RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9uppercase17BITSET_CHUNKS_MAP'],
        'liberyx_runtime.so:_RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9uppercase19BITSET_INDEX_CHUNKS': exports1['liberyx_runtime.so:_RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9uppercase19BITSET_INDEX_CHUNKS'],
        'liberyx_runtime.so:_RNvNtNtNtNtCsidipMUxUeKa_4core3num7flt2dec8strategy5grisu12CACHED_POW10': exports1['liberyx_runtime.so:_RNvNtNtNtNtCsidipMUxUeKa_4core3num7flt2dec8strategy5grisu12CACHED_POW10'],
        'liberyx_runtime.so:_RNvNvMs6_NtNtCsidipMUxUeKa_4core4task4wakeNtB7_5Waker11from_fn_ptr6VTABLE': exports1['liberyx_runtime.so:_RNvNvMs6_NtNtCsidipMUxUeKa_4core4task4wakeNtB7_5Waker11from_fn_ptr6VTABLE'],
        'liberyx_runtime.so:_RNvNvMsb_NtNtCsidipMUxUeKa_4core4task4wakeNtB7_10LocalWaker11from_fn_ptr6VTABLE': exports1['liberyx_runtime.so:_RNvNvMsb_NtNtCsidipMUxUeKa_4core4task4wakeNtB7_10LocalWaker11from_fn_ptr6VTABLE'],
        'liberyx_runtime.so:_RNvNvNtNtCs5XY3BH99Eqp_3std2io5stdio6stderr8INSTANCE': exports1['liberyx_runtime.so:_RNvNvNtNtCs5XY3BH99Eqp_3std2io5stdio6stderr8INSTANCE'],
        'liberyx_runtime.so:_RNvNvXNtNtCscviJhzjbUDx_4pyo35types8sequenceNtB4_10PySequenceNtNtB8_11type_object10PyTypeInfo15type_object_raw4TYPE': exports1['liberyx_runtime.so:_RNvNvXNtNtCscviJhzjbUDx_4pyo35types8sequenceNtB4_10PySequenceNtNtB8_11type_object10PyTypeInfo15type_object_raw4TYPE'],
        'liberyx_runtime.so:errno': exports1['liberyx_runtime.so:errno'],
        'liberyx_runtime.so:memory_base': exports1['liberyx_runtime.so:memory_base'],
        'libpython3.14.so:PY_TIMEOUT_MAX': exports1['libpython3.14.so:PY_TIMEOUT_MAX'],
        'libpython3.14.so:PyAsyncGen_Type': exports1['libpython3.14.so:PyAsyncGen_Type'],
        'libpython3.14.so:PyBaseObject_Type': exports1['libpython3.14.so:PyBaseObject_Type'],
        'libpython3.14.so:PyBool_Type': exports1['libpython3.14.so:PyBool_Type'],
        'libpython3.14.so:PyByteArrayIter_Type': exports1['libpython3.14.so:PyByteArrayIter_Type'],
        'libpython3.14.so:PyByteArray_Type': exports1['libpython3.14.so:PyByteArray_Type'],
        'libpython3.14.so:PyBytesIter_Type': exports1['libpython3.14.so:PyBytesIter_Type'],
        'libpython3.14.so:PyBytes_Type': exports1['libpython3.14.so:PyBytes_Type'],
        'libpython3.14.so:PyCFunction_Type': exports1['libpython3.14.so:PyCFunction_Type'],
        'libpython3.14.so:PyCMethod_Type': exports1['libpython3.14.so:PyCMethod_Type'],
        'libpython3.14.so:PyCallIter_Type': exports1['libpython3.14.so:PyCallIter_Type'],
        'libpython3.14.so:PyCapsule_Type': exports1['libpython3.14.so:PyCapsule_Type'],
        'libpython3.14.so:PyCell_Type': exports1['libpython3.14.so:PyCell_Type'],
        'libpython3.14.so:PyClassMethodDescr_Type': exports1['libpython3.14.so:PyClassMethodDescr_Type'],
        'libpython3.14.so:PyClassMethod_Type': exports1['libpython3.14.so:PyClassMethod_Type'],
        'libpython3.14.so:PyCode_Type': exports1['libpython3.14.so:PyCode_Type'],
        'libpython3.14.so:PyComplex_Type': exports1['libpython3.14.so:PyComplex_Type'],
        'libpython3.14.so:PyContextToken_Type': exports1['libpython3.14.so:PyContextToken_Type'],
        'libpython3.14.so:PyContextVar_Type': exports1['libpython3.14.so:PyContextVar_Type'],
        'libpython3.14.so:PyContext_Type': exports1['libpython3.14.so:PyContext_Type'],
        'libpython3.14.so:PyCoro_Type': exports1['libpython3.14.so:PyCoro_Type'],
        'libpython3.14.so:PyDictItems_Type': exports1['libpython3.14.so:PyDictItems_Type'],
        'libpython3.14.so:PyDictIterItem_Type': exports1['libpython3.14.so:PyDictIterItem_Type'],
        'libpython3.14.so:PyDictIterKey_Type': exports1['libpython3.14.so:PyDictIterKey_Type'],
        'libpython3.14.so:PyDictIterValue_Type': exports1['libpython3.14.so:PyDictIterValue_Type'],
        'libpython3.14.so:PyDictKeys_Type': exports1['libpython3.14.so:PyDictKeys_Type'],
        'libpython3.14.so:PyDictProxy_Type': exports1['libpython3.14.so:PyDictProxy_Type'],
        'libpython3.14.so:PyDictRevIterItem_Type': exports1['libpython3.14.so:PyDictRevIterItem_Type'],
        'libpython3.14.so:PyDictRevIterKey_Type': exports1['libpython3.14.so:PyDictRevIterKey_Type'],
        'libpython3.14.so:PyDictRevIterValue_Type': exports1['libpython3.14.so:PyDictRevIterValue_Type'],
        'libpython3.14.so:PyDictValues_Type': exports1['libpython3.14.so:PyDictValues_Type'],
        'libpython3.14.so:PyDict_Type': exports1['libpython3.14.so:PyDict_Type'],
        'libpython3.14.so:PyEllipsis_Type': exports1['libpython3.14.so:PyEllipsis_Type'],
        'libpython3.14.so:PyEnum_Type': exports1['libpython3.14.so:PyEnum_Type'],
        'libpython3.14.so:PyExc_ArithmeticError': exports1['libpython3.14.so:PyExc_ArithmeticError'],
        'libpython3.14.so:PyExc_AssertionError': exports1['libpython3.14.so:PyExc_AssertionError'],
        'libpython3.14.so:PyExc_AttributeError': exports1['libpython3.14.so:PyExc_AttributeError'],
        'libpython3.14.so:PyExc_BaseException': exports1['libpython3.14.so:PyExc_BaseException'],
        'libpython3.14.so:PyExc_BaseExceptionGroup': exports1['libpython3.14.so:PyExc_BaseExceptionGroup'],
        'libpython3.14.so:PyExc_BlockingIOError': exports1['libpython3.14.so:PyExc_BlockingIOError'],
        'libpython3.14.so:PyExc_BrokenPipeError': exports1['libpython3.14.so:PyExc_BrokenPipeError'],
        'libpython3.14.so:PyExc_BufferError': exports1['libpython3.14.so:PyExc_BufferError'],
        'libpython3.14.so:PyExc_BytesWarning': exports1['libpython3.14.so:PyExc_BytesWarning'],
        'libpython3.14.so:PyExc_ChildProcessError': exports1['libpython3.14.so:PyExc_ChildProcessError'],
        'libpython3.14.so:PyExc_ConnectionAbortedError': exports1['libpython3.14.so:PyExc_ConnectionAbortedError'],
        'libpython3.14.so:PyExc_ConnectionRefusedError': exports1['libpython3.14.so:PyExc_ConnectionRefusedError'],
        'libpython3.14.so:PyExc_ConnectionResetError': exports1['libpython3.14.so:PyExc_ConnectionResetError'],
        'libpython3.14.so:PyExc_DeprecationWarning': exports1['libpython3.14.so:PyExc_DeprecationWarning'],
        'libpython3.14.so:PyExc_EOFError': exports1['libpython3.14.so:PyExc_EOFError'],
        'libpython3.14.so:PyExc_EncodingWarning': exports1['libpython3.14.so:PyExc_EncodingWarning'],
        'libpython3.14.so:PyExc_EnvironmentError': exports1['libpython3.14.so:PyExc_EnvironmentError'],
        'libpython3.14.so:PyExc_Exception': exports1['libpython3.14.so:PyExc_Exception'],
        'libpython3.14.so:PyExc_FileExistsError': exports1['libpython3.14.so:PyExc_FileExistsError'],
        'libpython3.14.so:PyExc_FileNotFoundError': exports1['libpython3.14.so:PyExc_FileNotFoundError'],
        'libpython3.14.so:PyExc_GeneratorExit': exports1['libpython3.14.so:PyExc_GeneratorExit'],
        'libpython3.14.so:PyExc_IOError': exports1['libpython3.14.so:PyExc_IOError'],
        'libpython3.14.so:PyExc_ImportError': exports1['libpython3.14.so:PyExc_ImportError'],
        'libpython3.14.so:PyExc_ImportWarning': exports1['libpython3.14.so:PyExc_ImportWarning'],
        'libpython3.14.so:PyExc_IndentationError': exports1['libpython3.14.so:PyExc_IndentationError'],
        'libpython3.14.so:PyExc_IndexError': exports1['libpython3.14.so:PyExc_IndexError'],
        'libpython3.14.so:PyExc_InterpreterError': exports1['libpython3.14.so:PyExc_InterpreterError'],
        'libpython3.14.so:PyExc_InterpreterNotFoundError': exports1['libpython3.14.so:PyExc_InterpreterNotFoundError'],
        'libpython3.14.so:PyExc_InterruptedError': exports1['libpython3.14.so:PyExc_InterruptedError'],
        'libpython3.14.so:PyExc_IsADirectoryError': exports1['libpython3.14.so:PyExc_IsADirectoryError'],
        'libpython3.14.so:PyExc_KeyError': exports1['libpython3.14.so:PyExc_KeyError'],
        'libpython3.14.so:PyExc_KeyboardInterrupt': exports1['libpython3.14.so:PyExc_KeyboardInterrupt'],
        'libpython3.14.so:PyExc_LookupError': exports1['libpython3.14.so:PyExc_LookupError'],
        'libpython3.14.so:PyExc_MemoryError': exports1['libpython3.14.so:PyExc_MemoryError'],
        'libpython3.14.so:PyExc_ModuleNotFoundError': exports1['libpython3.14.so:PyExc_ModuleNotFoundError'],
        'libpython3.14.so:PyExc_NameError': exports1['libpython3.14.so:PyExc_NameError'],
        'libpython3.14.so:PyExc_NotADirectoryError': exports1['libpython3.14.so:PyExc_NotADirectoryError'],
        'libpython3.14.so:PyExc_NotImplementedError': exports1['libpython3.14.so:PyExc_NotImplementedError'],
        'libpython3.14.so:PyExc_OSError': exports1['libpython3.14.so:PyExc_OSError'],
        'libpython3.14.so:PyExc_OverflowError': exports1['libpython3.14.so:PyExc_OverflowError'],
        'libpython3.14.so:PyExc_PendingDeprecationWarning': exports1['libpython3.14.so:PyExc_PendingDeprecationWarning'],
        'libpython3.14.so:PyExc_PermissionError': exports1['libpython3.14.so:PyExc_PermissionError'],
        'libpython3.14.so:PyExc_ProcessLookupError': exports1['libpython3.14.so:PyExc_ProcessLookupError'],
        'libpython3.14.so:PyExc_PythonFinalizationError': exports1['libpython3.14.so:PyExc_PythonFinalizationError'],
        'libpython3.14.so:PyExc_RecursionError': exports1['libpython3.14.so:PyExc_RecursionError'],
        'libpython3.14.so:PyExc_ReferenceError': exports1['libpython3.14.so:PyExc_ReferenceError'],
        'libpython3.14.so:PyExc_ResourceWarning': exports1['libpython3.14.so:PyExc_ResourceWarning'],
        'libpython3.14.so:PyExc_RuntimeError': exports1['libpython3.14.so:PyExc_RuntimeError'],
        'libpython3.14.so:PyExc_RuntimeWarning': exports1['libpython3.14.so:PyExc_RuntimeWarning'],
        'libpython3.14.so:PyExc_StopAsyncIteration': exports1['libpython3.14.so:PyExc_StopAsyncIteration'],
        'libpython3.14.so:PyExc_StopIteration': exports1['libpython3.14.so:PyExc_StopIteration'],
        'libpython3.14.so:PyExc_SyntaxError': exports1['libpython3.14.so:PyExc_SyntaxError'],
        'libpython3.14.so:PyExc_SyntaxWarning': exports1['libpython3.14.so:PyExc_SyntaxWarning'],
        'libpython3.14.so:PyExc_SystemError': exports1['libpython3.14.so:PyExc_SystemError'],
        'libpython3.14.so:PyExc_SystemExit': exports1['libpython3.14.so:PyExc_SystemExit'],
        'libpython3.14.so:PyExc_TabError': exports1['libpython3.14.so:PyExc_TabError'],
        'libpython3.14.so:PyExc_TimeoutError': exports1['libpython3.14.so:PyExc_TimeoutError'],
        'libpython3.14.so:PyExc_TypeError': exports1['libpython3.14.so:PyExc_TypeError'],
        'libpython3.14.so:PyExc_UnboundLocalError': exports1['libpython3.14.so:PyExc_UnboundLocalError'],
        'libpython3.14.so:PyExc_UnicodeDecodeError': exports1['libpython3.14.so:PyExc_UnicodeDecodeError'],
        'libpython3.14.so:PyExc_UnicodeEncodeError': exports1['libpython3.14.so:PyExc_UnicodeEncodeError'],
        'libpython3.14.so:PyExc_UnicodeError': exports1['libpython3.14.so:PyExc_UnicodeError'],
        'libpython3.14.so:PyExc_UnicodeTranslateError': exports1['libpython3.14.so:PyExc_UnicodeTranslateError'],
        'libpython3.14.so:PyExc_UserWarning': exports1['libpython3.14.so:PyExc_UserWarning'],
        'libpython3.14.so:PyExc_ValueError': exports1['libpython3.14.so:PyExc_ValueError'],
        'libpython3.14.so:PyExc_Warning': exports1['libpython3.14.so:PyExc_Warning'],
        'libpython3.14.so:PyExc_ZeroDivisionError': exports1['libpython3.14.so:PyExc_ZeroDivisionError'],
        'libpython3.14.so:PyFilter_Type': exports1['libpython3.14.so:PyFilter_Type'],
        'libpython3.14.so:PyFloat_Type': exports1['libpython3.14.so:PyFloat_Type'],
        'libpython3.14.so:PyFrameLocalsProxy_Type': exports1['libpython3.14.so:PyFrameLocalsProxy_Type'],
        'libpython3.14.so:PyFrame_Type': exports1['libpython3.14.so:PyFrame_Type'],
        'libpython3.14.so:PyFrozenSet_Type': exports1['libpython3.14.so:PyFrozenSet_Type'],
        'libpython3.14.so:PyFunction_Type': exports1['libpython3.14.so:PyFunction_Type'],
        'libpython3.14.so:PyGen_Type': exports1['libpython3.14.so:PyGen_Type'],
        'libpython3.14.so:PyGetSetDescr_Type': exports1['libpython3.14.so:PyGetSetDescr_Type'],
        'libpython3.14.so:PyImport_FrozenModules': exports1['libpython3.14.so:PyImport_FrozenModules'],
        'libpython3.14.so:PyImport_Inittab': exports1['libpython3.14.so:PyImport_Inittab'],
        'libpython3.14.so:PyInstanceMethod_Type': exports1['libpython3.14.so:PyInstanceMethod_Type'],
        'libpython3.14.so:PyListIter_Type': exports1['libpython3.14.so:PyListIter_Type'],
        'libpython3.14.so:PyListRevIter_Type': exports1['libpython3.14.so:PyListRevIter_Type'],
        'libpython3.14.so:PyList_Type': exports1['libpython3.14.so:PyList_Type'],
        'libpython3.14.so:PyLongRangeIter_Type': exports1['libpython3.14.so:PyLongRangeIter_Type'],
        'libpython3.14.so:PyLong_Type': exports1['libpython3.14.so:PyLong_Type'],
        'libpython3.14.so:PyMap_Type': exports1['libpython3.14.so:PyMap_Type'],
        'libpython3.14.so:PyMemberDescr_Type': exports1['libpython3.14.so:PyMemberDescr_Type'],
        'libpython3.14.so:PyMemoryView_Type': exports1['libpython3.14.so:PyMemoryView_Type'],
        'libpython3.14.so:PyMethodDescr_Type': exports1['libpython3.14.so:PyMethodDescr_Type'],
        'libpython3.14.so:PyMethod_Type': exports1['libpython3.14.so:PyMethod_Type'],
        'libpython3.14.so:PyModuleDef_Type': exports1['libpython3.14.so:PyModuleDef_Type'],
        'libpython3.14.so:PyModule_Type': exports1['libpython3.14.so:PyModule_Type'],
        'libpython3.14.so:PyODictItems_Type': exports1['libpython3.14.so:PyODictItems_Type'],
        'libpython3.14.so:PyODictIter_Type': exports1['libpython3.14.so:PyODictIter_Type'],
        'libpython3.14.so:PyODictKeys_Type': exports1['libpython3.14.so:PyODictKeys_Type'],
        'libpython3.14.so:PyODictValues_Type': exports1['libpython3.14.so:PyODictValues_Type'],
        'libpython3.14.so:PyODict_Type': exports1['libpython3.14.so:PyODict_Type'],
        'libpython3.14.so:PyOS_InputHook': exports1['libpython3.14.so:PyOS_InputHook'],
        'libpython3.14.so:PyOS_ReadlineFunctionPointer': exports1['libpython3.14.so:PyOS_ReadlineFunctionPointer'],
        'libpython3.14.so:PyPickleBuffer_Type': exports1['libpython3.14.so:PyPickleBuffer_Type'],
        'libpython3.14.so:PyProperty_Type': exports1['libpython3.14.so:PyProperty_Type'],
        'libpython3.14.so:PyRangeIter_Type': exports1['libpython3.14.so:PyRangeIter_Type'],
        'libpython3.14.so:PyRange_Type': exports1['libpython3.14.so:PyRange_Type'],
        'libpython3.14.so:PyReversed_Type': exports1['libpython3.14.so:PyReversed_Type'],
        'libpython3.14.so:PySeqIter_Type': exports1['libpython3.14.so:PySeqIter_Type'],
        'libpython3.14.so:PySetIter_Type': exports1['libpython3.14.so:PySetIter_Type'],
        'libpython3.14.so:PySet_Type': exports1['libpython3.14.so:PySet_Type'],
        'libpython3.14.so:PySlice_Type': exports1['libpython3.14.so:PySlice_Type'],
        'libpython3.14.so:PyStaticMethod_Type': exports1['libpython3.14.so:PyStaticMethod_Type'],
        'libpython3.14.so:PyStdPrinter_Type': exports1['libpython3.14.so:PyStdPrinter_Type'],
        'libpython3.14.so:PyStructSequence_UnnamedField': exports1['libpython3.14.so:PyStructSequence_UnnamedField'],
        'libpython3.14.so:PySuper_Type': exports1['libpython3.14.so:PySuper_Type'],
        'libpython3.14.so:PyTraceBack_Type': exports1['libpython3.14.so:PyTraceBack_Type'],
        'libpython3.14.so:PyTupleIter_Type': exports1['libpython3.14.so:PyTupleIter_Type'],
        'libpython3.14.so:PyTuple_Type': exports1['libpython3.14.so:PyTuple_Type'],
        'libpython3.14.so:PyType_Type': exports1['libpython3.14.so:PyType_Type'],
        'libpython3.14.so:PyUnicodeIter_Type': exports1['libpython3.14.so:PyUnicodeIter_Type'],
        'libpython3.14.so:PyUnicode_Type': exports1['libpython3.14.so:PyUnicode_Type'],
        'libpython3.14.so:PyWrapperDescr_Type': exports1['libpython3.14.so:PyWrapperDescr_Type'],
        'libpython3.14.so:PyZip_Type': exports1['libpython3.14.so:PyZip_Type'],
        'libpython3.14.so:Py_BytesWarningFlag': exports1['libpython3.14.so:Py_BytesWarningFlag'],
        'libpython3.14.so:Py_DebugFlag': exports1['libpython3.14.so:Py_DebugFlag'],
        'libpython3.14.so:Py_DontWriteBytecodeFlag': exports1['libpython3.14.so:Py_DontWriteBytecodeFlag'],
        'libpython3.14.so:Py_FileSystemDefaultEncodeErrors': exports1['libpython3.14.so:Py_FileSystemDefaultEncodeErrors'],
        'libpython3.14.so:Py_FileSystemDefaultEncoding': exports1['libpython3.14.so:Py_FileSystemDefaultEncoding'],
        'libpython3.14.so:Py_FrozenFlag': exports1['libpython3.14.so:Py_FrozenFlag'],
        'libpython3.14.so:Py_GenericAliasType': exports1['libpython3.14.so:Py_GenericAliasType'],
        'libpython3.14.so:Py_HasFileSystemDefaultEncoding': exports1['libpython3.14.so:Py_HasFileSystemDefaultEncoding'],
        'libpython3.14.so:Py_HashRandomizationFlag': exports1['libpython3.14.so:Py_HashRandomizationFlag'],
        'libpython3.14.so:Py_IgnoreEnvironmentFlag': exports1['libpython3.14.so:Py_IgnoreEnvironmentFlag'],
        'libpython3.14.so:Py_InspectFlag': exports1['libpython3.14.so:Py_InspectFlag'],
        'libpython3.14.so:Py_InteractiveFlag': exports1['libpython3.14.so:Py_InteractiveFlag'],
        'libpython3.14.so:Py_IsolatedFlag': exports1['libpython3.14.so:Py_IsolatedFlag'],
        'libpython3.14.so:Py_NoSiteFlag': exports1['libpython3.14.so:Py_NoSiteFlag'],
        'libpython3.14.so:Py_NoUserSiteDirectory': exports1['libpython3.14.so:Py_NoUserSiteDirectory'],
        'libpython3.14.so:Py_OptimizeFlag': exports1['libpython3.14.so:Py_OptimizeFlag'],
        'libpython3.14.so:Py_QuietFlag': exports1['libpython3.14.so:Py_QuietFlag'],
        'libpython3.14.so:Py_UTF8Mode': exports1['libpython3.14.so:Py_UTF8Mode'],
        'libpython3.14.so:Py_UnbufferedStdioFlag': exports1['libpython3.14.so:Py_UnbufferedStdioFlag'],
        'libpython3.14.so:Py_VerboseFlag': exports1['libpython3.14.so:Py_VerboseFlag'],
        'libpython3.14.so:Py_hexdigits': exports1['libpython3.14.so:Py_hexdigits'],
        'libpython3.14.so:_CLOCK_MONOTONIC': exports1['libpython3.14.so:_CLOCK_MONOTONIC'],
        'libpython3.14.so:_CLOCK_REALTIME': exports1['libpython3.14.so:_CLOCK_REALTIME'],
        'libpython3.14.so:_PyAsyncGenASend_Type': exports1['libpython3.14.so:_PyAsyncGenASend_Type'],
        'libpython3.14.so:_PyByteArray_empty_string': exports1['libpython3.14.so:_PyByteArray_empty_string'],
        'libpython3.14.so:_PyEval_BinaryOps': exports1['libpython3.14.so:_PyEval_BinaryOps'],
        'libpython3.14.so:_PyEval_ConversionFuncs': exports1['libpython3.14.so:_PyEval_ConversionFuncs'],
        'libpython3.14.so:_PyExc_IncompleteInputError': exports1['libpython3.14.so:_PyExc_IncompleteInputError'],
        'libpython3.14.so:_PyImport_FrozenBootstrap': exports1['libpython3.14.so:_PyImport_FrozenBootstrap'],
        'libpython3.14.so:_PyImport_FrozenStdlib': exports1['libpython3.14.so:_PyImport_FrozenStdlib'],
        'libpython3.14.so:_PyImport_FrozenTest': exports1['libpython3.14.so:_PyImport_FrozenTest'],
        'libpython3.14.so:_PyIntrinsics_BinaryFunctions': exports1['libpython3.14.so:_PyIntrinsics_BinaryFunctions'],
        'libpython3.14.so:_PyIntrinsics_UnaryFunctions': exports1['libpython3.14.so:_PyIntrinsics_UnaryFunctions'],
        'libpython3.14.so:_PyLong_DigitValue': exports1['libpython3.14.so:_PyLong_DigitValue'],
        'libpython3.14.so:_PyNone_Type': exports1['libpython3.14.so:_PyNone_Type'],
        'libpython3.14.so:_PyNotImplemented_Type': exports1['libpython3.14.so:_PyNotImplemented_Type'],
        'libpython3.14.so:_PyOS_ReadlineTState': exports1['libpython3.14.so:_PyOS_ReadlineTState'],
        'libpython3.14.so:_PyRuntime': exports1['libpython3.14.so:_PyRuntime'],
        'libpython3.14.so:_PyUnion_Type': exports1['libpython3.14.so:_PyUnion_Type'],
        'libpython3.14.so:_PyWeakref_CallableProxyType': exports1['libpython3.14.so:_PyWeakref_CallableProxyType'],
        'libpython3.14.so:_PyWeakref_ProxyType': exports1['libpython3.14.so:_PyWeakref_ProxyType'],
        'libpython3.14.so:_PyWeakref_RefType': exports1['libpython3.14.so:_PyWeakref_RefType'],
        'libpython3.14.so:_Py_EllipsisObject': exports1['libpython3.14.so:_Py_EllipsisObject'],
        'libpython3.14.so:_Py_FalseStruct': exports1['libpython3.14.so:_Py_FalseStruct'],
        'libpython3.14.so:_Py_FunctionAttributeOffsets': exports1['libpython3.14.so:_Py_FunctionAttributeOffsets'],
        'libpython3.14.so:_Py_HashSecret': exports1['libpython3.14.so:_Py_HashSecret'],
        'libpython3.14.so:_Py_InitCleanup': exports1['libpython3.14.so:_Py_InitCleanup'],
        'libpython3.14.so:_Py_NoneStruct': exports1['libpython3.14.so:_Py_NoneStruct'],
        'libpython3.14.so:_Py_NotImplementedStruct': exports1['libpython3.14.so:_Py_NotImplementedStruct'],
        'libpython3.14.so:_Py_SpecialMethods': exports1['libpython3.14.so:_Py_SpecialMethods'],
        'libpython3.14.so:_Py_SwappedOp': exports1['libpython3.14.so:_Py_SwappedOp'],
        'libpython3.14.so:_Py_TrueStruct': exports1['libpython3.14.so:_Py_TrueStruct'],
        'libpython3.14.so:_Py_ascii_whitespace': exports1['libpython3.14.so:_Py_ascii_whitespace'],
        'libpython3.14.so:_Py_ctype_table': exports1['libpython3.14.so:_Py_ctype_table'],
        'libpython3.14.so:_Py_ctype_tolower': exports1['libpython3.14.so:_Py_ctype_tolower'],
        'libpython3.14.so:_Py_ctype_toupper': exports1['libpython3.14.so:_Py_ctype_toupper'],
        'libpython3.14.so:environ': exports1['libpython3.14.so:environ'],
        'libpython3.14.so:errno': exports1['libpython3.14.so:errno'],
        'libpython3.14.so:h_errno': exports1['libpython3.14.so:h_errno'],
        'libpython3.14.so:memory_base': exports1['libpython3.14.so:memory_base'],
        'libpython3.14.so:stderr': exports1['libpython3.14.so:stderr'],
        'libpython3.14.so:stdin': exports1['libpython3.14.so:stdin'],
        'libpython3.14.so:stdout': exports1['libpython3.14.so:stdout'],
        'libwasi-emulated-process-clocks.so:errno': exports1['libwasi-emulated-process-clocks.so:errno'],
        'libwasi-emulated-signal.so:errno': exports1['libwasi-emulated-signal.so:errno'],
        'libwasi-emulated-signal.so:stderr': exports1['libwasi-emulated-signal.so:stderr'],
        memory: exports1.memory,
      },
      'libc.so': {
        _CLOCK_MONOTONIC: exports4._CLOCK_MONOTONIC,
        _CLOCK_REALTIME: exports4._CLOCK_REALTIME,
        _IO_feof_unlocked: exports4.feof,
        _IO_ferror_unlocked: exports4.ferror,
        _IO_getc: exports4.getc,
        _IO_getc_unlocked: exports4.getc_unlocked,
        _IO_putc: exports4.putc,
        _IO_putc_unlocked: exports4.putc_unlocked,
        __freelocale: exports4.freelocale,
        __getdelim: exports4.getdelim,
        __isoc99_fscanf: exports4.fscanf,
        __isoc99_fwscanf: exports4.fwscanf,
        __isoc99_scanf: exports4.scanf,
        __isoc99_sscanf: exports4.sscanf,
        __isoc99_swscanf: exports4.swscanf,
        __isoc99_vfscanf: exports4.vfscanf,
        __isoc99_vfwscanf: exports4.vfwscanf,
        __isoc99_vscanf: exports4.vscanf,
        __isoc99_vsscanf: exports4.vsscanf,
        __isoc99_vswscanf: exports4.vswscanf,
        __isoc99_vwscanf: exports4.vwscanf,
        __isoc99_wscanf: exports4.wscanf,
        __main_void: exports4.__main_void,
        __optpos: exports4.__optpos,
        __optreset: exports4.__optreset,
        __posix_getopt: exports4.getopt,
        __signgam: exports4.__signgam,
        __small_printf: exports4.printf,
        __stack_chk_guard: exports4.__stack_chk_guard,
        __strtod_l: exports4.strtod_l,
        __strtof_l: exports4.strtof_l,
        __strtoimax_internal: exports4.strtoimax,
        __strtol_internal: exports4.strtol,
        __strtold_l: exports4.strtold_l,
        __strtoll_internal: exports4.strtoll,
        __strtoul_internal: exports4.strtoul,
        __strtoull_internal: exports4.strtoull,
        __strtoumax_internal: exports4.strtoumax,
        __wasi_sockets_services_db: exports4.__wasi_sockets_services_db,
        __wasilibc_cwd: exports4.__wasilibc_cwd,
        __wasilibc_environ: exports4.__wasilibc_environ,
        __wasilibc_find_relpath_alloc: exports4.__wasilibc_find_relpath_alloc,
        __wasilibc_pthread_self: exports4.__wasilibc_pthread_self,
        __wasm_apply_data_relocs: exports4.__wasm_apply_data_relocs,
        __xpg_basename: exports4.basename,
        __xpg_strerror_r: exports4.strerror_r,
        _initialize: exports4._initialize,
        access: exports4.access,
        acos: exports4.acos,
        acosh: exports4.acosh,
        alphasort64: exports4.alphasort,
        asctime_r: exports4.asctime_r,
        asin: exports4.asin,
        asinh: exports4.asinh,
        atan: exports4.atan,
        atan2: exports4.atan2,
        atanh: exports4.atanh,
        cabi_realloc: exports4.cabi_realloc,
        calloc: exports4.calloc,
        clearerr_unlocked: exports4.clearerr,
        clock_gettime: exports4.clock_gettime,
        close: exports4.close,
        copysign: exports4.copysign,
        cos: exports4.cos,
        cosh: exports4.cosh,
        creat64: exports4.creat,
        crypt_r: exports4.crypt_r,
        drem: exports4.remainder,
        dremf: exports4.remainderf,
        duplocale: exports4.__duplocale,
        environ: exports4.environ,
        errno: exports4.errno,
        exp: exports4.exp,
        exp2: exports4.exp2,
        fabs: exports4.fabs,
        fcntl: exports4.fcntl,
        fdopen: exports4.fdopen,
        feof_unlocked: exports4.feof,
        ferror_unlocked: exports4.ferror,
        fflush_unlocked: exports4.fflush,
        fgetc_unlocked: exports4.getc_unlocked,
        fgetpos64: exports4.fgetpos,
        fgets_unlocked: exports4.fgets,
        fgetwc_unlocked: exports4.__fgetwc_unlocked,
        fgetws_unlocked: exports4.fgetws,
        fileno_unlocked: exports4.fileno,
        fmod: exports4.fmod,
        fopen64: exports4.fopen,
        fpurge: exports4.__fpurge,
        fputc_unlocked: exports4.putc_unlocked,
        fputs_unlocked: exports4.fputs,
        fputwc_unlocked: exports4.__fputwc_unlocked,
        fputws_unlocked: exports4.fputws,
        fread_unlocked: exports4.fread,
        free: exports4.free,
        freopen64: exports4.freopen,
        fseeko: exports4.fseeko,
        fseeko64: exports4.fseeko,
        fsetpos64: exports4.fsetpos,
        fstat: exports4.fstat,
        ftello: exports4.ftello,
        ftello64: exports4.ftello,
        ftruncate: exports4.ftruncate,
        futimesat: exports4.futimesat,
        fwrite_unlocked: exports4.fwrite,
        getcwd: exports4.getcwd,
        getdate_err: exports4.getdate_err,
        getentropy: exports4.__getentropy,
        getwc_unlocked: exports4.__fgetwc_unlocked,
        getwchar_unlocked: exports4.getwchar,
        glob64: exports4.glob,
        globfree64: exports4.globfree,
        gmtime_r: exports4.gmtime_r,
        h_errno: exports4.h_errno,
        hcreate_r: exports4.hcreate_r,
        hdestroy_r: exports4.hdestroy_r,
        hsearch_r: exports4.hsearch_r,
        inet_aton: exports4.inet_aton,
        iprintf: exports4.printf,
        isalnum_l: exports4.__isalnum_l,
        isalpha_l: exports4.__isalpha_l,
        isatty: exports4.__isatty,
        isblank_l: exports4.__isblank_l,
        iscntrl_l: exports4.__iscntrl_l,
        isdigit_l: exports4.__isdigit_l,
        isgraph_l: exports4.__isgraph_l,
        islower_l: exports4.__islower_l,
        isprint_l: exports4.__isprint_l,
        ispunct_l: exports4.__ispunct_l,
        isspace_l: exports4.__isspace_l,
        isupper_l: exports4.__isupper_l,
        iswalnum_l: exports4.__iswalnum_l,
        iswalpha_l: exports4.__iswalpha_l,
        iswblank_l: exports4.__iswblank_l,
        iswcntrl_l: exports4.__iswcntrl_l,
        iswctype_l: exports4.__iswctype_l,
        iswdigit_l: exports4.__iswdigit_l,
        iswgraph_l: exports4.__iswgraph_l,
        iswlower_l: exports4.__iswlower_l,
        iswprint_l: exports4.__iswprint_l,
        iswpunct_l: exports4.__iswpunct_l,
        iswspace_l: exports4.__iswspace_l,
        iswupper_l: exports4.__iswupper_l,
        iswxdigit_l: exports4.__iswxdigit_l,
        isxdigit_l: exports4.__isxdigit_l,
        lgamma_r: exports4.lgamma_r,
        lgammaf_r: exports4.lgammaf_r,
        lgammal_r: exports4.__lgammal_r,
        localtime_r: exports4.localtime_r,
        lseek: exports4.lseek,
        lstat: exports4.lstat,
        malloc: exports4.malloc,
        memrchr: exports4.memrchr,
        mkdir: exports4.mkdir,
        newlocale: exports4.__newlocale,
        nftw64: exports4.nftw,
        nl_langinfo: exports4.__nl_langinfo,
        nl_langinfo_l: exports4.__nl_langinfo_l,
        optarg: exports4.optarg,
        opterr: exports4.opterr,
        optind: exports4.optind,
        optopt: exports4.optopt,
        pow: exports4.pow,
        pow10: exports4.exp10,
        pow10f: exports4.exp10f,
        pow10l: exports4.exp10l,
        pthread_cond_timedwait: exports4.pthread_cond_timedwait,
        pthread_create: exports4.pthread_create,
        pthread_detach: exports4.pthread_detach,
        pthread_equal: exports4.pthread_equal,
        pthread_getspecific: exports4.pthread_getspecific,
        pthread_join: exports4.pthread_join,
        pthread_key_create: exports4.pthread_key_create,
        pthread_key_delete: exports4.pthread_key_delete,
        pthread_mutex_lock: exports4.pthread_mutex_lock,
        pthread_mutex_timedlock: exports4.pthread_mutex_timedlock,
        pthread_mutex_trylock: exports4.pthread_mutex_trylock,
        pthread_mutex_unlock: exports4.pthread_mutex_unlock,
        pthread_once: exports4.pthread_once,
        pthread_rwlock_rdlock: exports4.pthread_rwlock_rdlock,
        pthread_rwlock_timedrdlock: exports4.pthread_rwlock_timedrdlock,
        pthread_rwlock_timedwrlock: exports4.pthread_rwlock_timedwrlock,
        pthread_rwlock_tryrdlock: exports4.pthread_rwlock_tryrdlock,
        pthread_rwlock_trywrlock: exports4.pthread_rwlock_trywrlock,
        pthread_rwlock_unlock: exports4.pthread_rwlock_unlock,
        pthread_rwlock_wrlock: exports4.pthread_rwlock_wrlock,
        pthread_self: exports4.pthread_self,
        pthread_setcancelstate: exports4.pthread_setcancelstate,
        pthread_testcancel: exports4.pthread_testcancel,
        pthread_timedjoin_np: exports4.pthread_timedjoin_np,
        pthread_tryjoin_np: exports4.pthread_tryjoin_np,
        putwc_unlocked: exports4.__fputwc_unlocked,
        putwchar_unlocked: exports4.putwchar,
        qsort_r: exports4.qsort_r,
        read: exports4.read,
        readlink: exports4.readlink,
        realloc: exports4.realloc,
        reallocarray: exports4.__reallocarray,
        rmdir: exports4.rmdir,
        sin: exports4.sin,
        sinh: exports4.sinh,
        sqrt: exports4.sqrt,
        stat: exports4.stat,
        stderr: exports4.stderr,
        stdin: exports4.stdin,
        stdout: exports4.stdout,
        stpcpy: exports4.stpcpy,
        stpncpy: exports4.stpncpy,
        strcasecmp_l: exports4.__strcasecmp_l,
        strchrnul: exports4.strchrnul,
        strcoll_l: exports4.__strcoll_l,
        strerror_l: exports4.__strerror_l,
        strftime_l: exports4.strftime_l,
        strncasecmp_l: exports4.__strncasecmp_l,
        strxfrm_l: exports4.__strxfrm_l,
        tan: exports4.tan,
        tanh: exports4.tanh,
        thrd_current: exports4.pthread_self,
        thrd_detach: exports4.pthread_detach,
        thrd_equal: exports4.pthread_equal,
        tolower_l: exports4.__tolower_l,
        toupper_l: exports4.__toupper_l,
        towctrans_l: exports4.__towctrans_l,
        towlower_l: exports4.__towlower_l,
        towupper_l: exports4.__towupper_l,
        trunc: exports4.trunc,
        tss_get: exports4.pthread_getspecific,
        unlink: exports4.unlink,
        uselocale: exports4.__uselocale,
        versionsort64: exports4.versionsort,
        wcscoll_l: exports4.__wcscoll_l,
        wcsftime_l: exports4.__wcsftime_l,
        wcsxfrm_l: exports4.__wcsxfrm_l,
        wctrans_l: exports4.__wctrans_l,
        wctype_l: exports4.__wctype_l,
        write: exports4.write,
      },
      'libdl.so': {
        __wasm_set_libraries: exports8.__wasm_set_libraries,
        _initialize: exports8._initialize,
      },
      'liberyx_bindings.so': {
        __wasm_apply_data_relocs: exports11.__wasm_apply_data_relocs,
        __wasm_call_ctors: exports11.__wasm_call_ctors,
      },
      'liberyx_runtime.so': {
        PyInit__eryx: exports10.PyInit__eryx,
        _RNvCsfk0Zuc3kHNL_13wit_dylib_ffi5WIT_T: exports10._RNvCsfk0Zuc3kHNL_13wit_dylib_ffi5WIT_T,
        _RNvNCNvNtNtCs5XY3BH99Eqp_3std6thread9spawnhook11SPAWN_HOOKS023___RUST_STD_INTERNAL_VAL: exports10._RNvNCNvNtNtCs5XY3BH99Eqp_3std6thread9spawnhook11SPAWN_HOOKS023___RUST_STD_INTERNAL_VAL,
        _RNvNCNvNtNtCscviJhzjbUDx_4pyo38internal5state12ATTACH_COUNT023___RUST_STD_INTERNAL_VAL: exports10._RNvNCNvNtNtCscviJhzjbUDx_4pyo38internal5state12ATTACH_COUNT023___RUST_STD_INTERNAL_VAL,
        _RNvNCNvNvMNtNtCs5XY3BH99Eqp_3std4hash6randomNtB8_11RandomState3new4KEYS023___RUST_STD_INTERNAL_VAL: exports10._RNvNCNvNvMNtNtCs5XY3BH99Eqp_3std4hash6randomNtB8_11RandomState3new4KEYS023___RUST_STD_INTERNAL_VAL,
        _RNvNCNvNvNtNtNtCs5XY3BH99Eqp_3std4sync4mpmc5waker17current_thread_id5DUMMY023___RUST_STD_INTERNAL_VAL: exports10._RNvNCNvNvNtNtNtCs5XY3BH99Eqp_3std4sync4mpmc5waker17current_thread_id5DUMMY023___RUST_STD_INTERNAL_VAL,
        _RNvNCNvXs1_NtNtNtCscviJhzjbUDx_4pyo35types7weakref9referenceNtB9_18PyWeakrefReferenceNtNtBf_11type_object10PyTypeInfo15type_object_raw04TYPE: exports10._RNvNCNvXs1_NtNtNtCscviJhzjbUDx_4pyo35types7weakref9referenceNtB9_18PyWeakrefReferenceNtNtBf_11type_object10PyTypeInfo15type_object_raw04TYPE,
        _RNvNCNvXs6_NtNtCscviJhzjbUDx_4pyo35types8datetimeNtB9_6PyDateNtNtBd_11type_object10PyTypeInfo15type_object_raw04TYPE: exports10._RNvNCNvXs6_NtNtCscviJhzjbUDx_4pyo35types8datetimeNtB9_6PyDateNtNtBd_11type_object10PyTypeInfo15type_object_raw04TYPE,
        _RNvNCNvXs9_NtNtCscviJhzjbUDx_4pyo35types8datetimeNtB9_10PyDateTimeNtNtBd_11type_object10PyTypeInfo15type_object_raw04TYPE: exports10._RNvNCNvXs9_NtNtCscviJhzjbUDx_4pyo35types8datetimeNtB9_10PyDateTimeNtNtBd_11type_object10PyTypeInfo15type_object_raw04TYPE,
        _RNvNCNvXsc_NtNtCscviJhzjbUDx_4pyo35types8datetimeNtB9_6PyTimeNtNtBd_11type_object10PyTypeInfo15type_object_raw04TYPE: exports10._RNvNCNvXsc_NtNtCscviJhzjbUDx_4pyo35types8datetimeNtB9_6PyTimeNtNtBd_11type_object10PyTypeInfo15type_object_raw04TYPE,
        _RNvNCNvXsf_NtNtCscviJhzjbUDx_4pyo35types8datetimeNtB9_8PyTzInfoNtNtBd_11type_object10PyTypeInfo15type_object_raw04TYPE: exports10._RNvNCNvXsf_NtNtCscviJhzjbUDx_4pyo35types8datetimeNtB9_8PyTzInfoNtNtBd_11type_object10PyTypeInfo15type_object_raw04TYPE,
        _RNvNCNvXsi_NtNtCscviJhzjbUDx_4pyo35types8datetimeNtB9_7PyDeltaNtNtBd_11type_object10PyTypeInfo15type_object_raw04TYPE: exports10._RNvNCNvXsi_NtNtCscviJhzjbUDx_4pyo35types8datetimeNtB9_7PyDeltaNtNtBd_11type_object10PyTypeInfo15type_object_raw04TYPE,
        _RNvNtCs5XY3BH99Eqp_3std5alloc24default_alloc_error_hook: exports10._RNvNtCs5XY3BH99Eqp_3std5alloc24default_alloc_error_hook,
        _RNvNtCs5XY3BH99Eqp_3std5alloc4HOOK: exports10._RNvNtCs5XY3BH99Eqp_3std5alloc4HOOK,
        _RNvNtCs5XY3BH99Eqp_3std9panicking4HOOK: exports10._RNvNtCs5XY3BH99Eqp_3std9panicking4HOOK,
        _RNvNtCsaVdva8B9hP2_4libc4wasi14CLOCK_REALTIME: exports10._RNvNtCsaVdva8B9hP2_4libc4wasi14CLOCK_REALTIME,
        _RNvNtNtCs5XY3BH99Eqp_3std6thread7current7CURRENT: exports10._RNvNtNtCs5XY3BH99Eqp_3std6thread7current7CURRENT,
        _RNvNtNtCs5XY3BH99Eqp_3std9panicking11panic_count18GLOBAL_PANIC_COUNT: exports10._RNvNtNtCs5XY3BH99Eqp_3std9panicking11panic_count18GLOBAL_PANIC_COUNT,
        _RNvNtNtNtCs5XY3BH99Eqp_3std6thread7current2id2ID: exports10._RNvNtNtNtCs5XY3BH99Eqp_3std6thread7current2id2ID,
        _RNvNtNtNtCsidipMUxUeKa_4core3num7dec2flt5table17POWER_OF_FIVE_128: exports10._RNvNtNtNtCsidipMUxUeKa_4core3num7dec2flt5table17POWER_OF_FIVE_128,
        _RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9lowercase14BITSET_MAPPING: exports10._RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9lowercase14BITSET_MAPPING,
        _RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9lowercase16BITSET_CANONICAL: exports10._RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9lowercase16BITSET_CANONICAL,
        _RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9lowercase17BITSET_CHUNKS_MAP: exports10._RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9lowercase17BITSET_CHUNKS_MAP,
        _RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9lowercase19BITSET_INDEX_CHUNKS: exports10._RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9lowercase19BITSET_INDEX_CHUNKS,
        _RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9uppercase14BITSET_MAPPING: exports10._RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9uppercase14BITSET_MAPPING,
        _RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9uppercase16BITSET_CANONICAL: exports10._RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9uppercase16BITSET_CANONICAL,
        _RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9uppercase17BITSET_CHUNKS_MAP: exports10._RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9uppercase17BITSET_CHUNKS_MAP,
        _RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9uppercase19BITSET_INDEX_CHUNKS: exports10._RNvNtNtNtCsidipMUxUeKa_4core7unicode12unicode_data9uppercase19BITSET_INDEX_CHUNKS,
        _RNvNtNtNtNtCsidipMUxUeKa_4core3num7flt2dec8strategy5grisu12CACHED_POW10: exports10._RNvNtNtNtNtCsidipMUxUeKa_4core3num7flt2dec8strategy5grisu12CACHED_POW10,
        _RNvNvMs6_NtNtCsidipMUxUeKa_4core4task4wakeNtB7_5Waker11from_fn_ptr6VTABLE: exports10._RNvNvMs6_NtNtCsidipMUxUeKa_4core4task4wakeNtB7_5Waker11from_fn_ptr6VTABLE,
        _RNvNvMsb_NtNtCsidipMUxUeKa_4core4task4wakeNtB7_10LocalWaker11from_fn_ptr6VTABLE: exports10._RNvNvMsb_NtNtCsidipMUxUeKa_4core4task4wakeNtB7_10LocalWaker11from_fn_ptr6VTABLE,
        _RNvNvNtNtCs5XY3BH99Eqp_3std2io5stdio6stderr8INSTANCE: exports10._RNvNvNtNtCs5XY3BH99Eqp_3std2io5stdio6stderr8INSTANCE,
        _RNvNvXNtNtCscviJhzjbUDx_4pyo35types8sequenceNtB4_10PySequenceNtNtB8_11type_object10PyTypeInfo15type_object_raw4TYPE: exports10._RNvNvXNtNtCscviJhzjbUDx_4pyo35types8sequenceNtB4_10PySequenceNtNtB8_11type_object10PyTypeInfo15type_object_raw4TYPE,
        _RNvXNtNtCs5XY3BH99Eqp_3std2io5errorNtB2_5ErrorNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt: exports10._RNvXNtNtCs5XY3BH99Eqp_3std2io5errorNtB2_5ErrorNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt,
        _RNvXNtNtCsidipMUxUeKa_4core3num5errorNtB2_15TryFromIntErrorNtNtB6_3fmt7Display3fmt: exports10._RNvXNtNtCsidipMUxUeKa_4core3num5errorNtB2_15TryFromIntErrorNtNtB6_3fmt7Display3fmt,
        _RNvXNtNtNtCs5XY3BH99Eqp_3std3sys7process3envNtB2_10CommandEnvNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt: exports10._RNvXNtNtNtCs5XY3BH99Eqp_3std3sys7process3envNtB2_10CommandEnvNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt,
        _RNvXNtNtNtCsidipMUxUeKa_4core3fmt3num3imphNtB6_7Display3fmt: exports10._RNvXNtNtNtCsidipMUxUeKa_4core3fmt3num3imphNtB6_7Display3fmt,
        _RNvXNvMNtNtCs5XY3BH99Eqp_3std3sys9backtraceNtB5_13BacktraceLock5printNtB2_16DisplayBacktraceNtNtCsidipMUxUeKa_4core3fmt7Display3fmt: exports10._RNvXNvMNtNtCs5XY3BH99Eqp_3std3sys9backtraceNtB5_13BacktraceLock5printNtB2_16DisplayBacktraceNtNtCsidipMUxUeKa_4core3fmt7Display3fmt,
        _RNvXNvNtCs5XY3BH99Eqp_3std9panicking13resume_unwindNtB2_9RewrapBoxNtNtCsidipMUxUeKa_4core5panic12PanicPayload8take_box: exports10._RNvXNvNtCs5XY3BH99Eqp_3std9panicking13resume_unwindNtB2_9RewrapBoxNtNtCsidipMUxUeKa_4core5panic12PanicPayload8take_box,
        _RNvXNvXs7_NtCs5XY3BH99Eqp_3std4pathNtB8_10ComponentsNtNtCsidipMUxUeKa_4core3fmt5Debug3fmtNtB2_11DebugHelperBO_3fmt: exports10._RNvXNvXs7_NtCs5XY3BH99Eqp_3std4pathNtB8_10ComponentsNtNtCsidipMUxUeKa_4core3fmt5Debug3fmtNtB2_11DebugHelperBO_3fmt,
        _RNvXNvXsb_NtCs5XY3BH99Eqp_3std4pathNtB8_4IterNtNtCsidipMUxUeKa_4core3fmt5Debug3fmtNtB2_11DebugHelperBH_3fmt: exports10._RNvXNvXsb_NtCs5XY3BH99Eqp_3std4pathNtB8_4IterNtNtCsidipMUxUeKa_4core3fmt5Debug3fmtNtB2_11DebugHelperBH_3fmt,
        _RNvXs0_NtCscviJhzjbUDx_4pyo33errNtB5_5PyErrNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt: exports10._RNvXs0_NtCscviJhzjbUDx_4pyo33errNtB5_5PyErrNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt,
        _RNvXs0_NtNtCs5XY3BH99Eqp_3std6thread6threadNtB5_6ThreadNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt: exports10._RNvXs0_NtNtCs5XY3BH99Eqp_3std6thread6threadNtB5_6ThreadNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt,
        _RNvXs0_NtNtCsidipMUxUeKa_4core3fmt8buildersNtB5_10PadAdapterNtB7_5Write10write_char: exports10._RNvXs0_NtNtCsidipMUxUeKa_4core3fmt8buildersNtB5_10PadAdapterNtB7_5Write10write_char,
        _RNvXs0_NtNtCsidipMUxUeKa_4core3fmt8buildersNtB5_10PadAdapterNtB7_5Write9write_str: exports10._RNvXs0_NtNtCsidipMUxUeKa_4core3fmt8buildersNtB5_10PadAdapterNtB7_5Write9write_str,
        _RNvXs0_NtNtCsidipMUxUeKa_4core3str5lossyNtB5_5DebugNtNtB9_3fmt5Debug3fmt: exports10._RNvXs0_NtNtCsidipMUxUeKa_4core3str5lossyNtB5_5DebugNtNtB9_3fmt5Debug3fmt,
        _RNvXs0_NvNtCs5XY3BH99Eqp_3std9panicking13panic_handlerNtB5_19FormatStringPayloadNtNtCsidipMUxUeKa_4core3fmt7Display3fmt: exports10._RNvXs0_NvNtCs5XY3BH99Eqp_3std9panicking13panic_handlerNtB5_19FormatStringPayloadNtNtCsidipMUxUeKa_4core3fmt7Display3fmt,
        _RNvXs0_NvXsf_NtNtCs156tPVBHeXz_5alloc5boxed7convertINtBd_3BoxDNtNtCsidipMUxUeKa_4core5error5ErrorNtNtB12_6marker4SyncNtB1z_4SendEL_EINtNtB12_7convert4FromNtNtBf_6string6StringE4fromNtB5_11StringErrorNtNtB12_3fmt5Debug3fmt: exports10._RNvXs0_NvXsf_NtNtCs156tPVBHeXz_5alloc5boxed7convertINtBd_3BoxDNtNtCsidipMUxUeKa_4core5error5ErrorNtNtB12_6marker4SyncNtB1z_4SendEL_EINtNtB12_7convert4FromNtNtBf_6string6StringE4fromNtB5_11StringErrorNtNtB12_3fmt5Debug3fmt,
        _RNvXs1_NtCs1Pv9BUWNVtS_4wasi13lib_generatedNtB5_5ErrnoNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt: exports10._RNvXs1_NtCs1Pv9BUWNVtS_4wasi13lib_generatedNtB5_5ErrnoNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt,
        _RNvXs1_NtCscviJhzjbUDx_4pyo33errNtB5_5PyErrNtNtCsidipMUxUeKa_4core3fmt7Display3fmt: exports10._RNvXs1_NtCscviJhzjbUDx_4pyo33errNtB5_5PyErrNtNtCsidipMUxUeKa_4core3fmt7Display3fmt,
        _RNvXs1_NtNtNtCs5XY3BH99Eqp_3std3sys4args6commonNtB5_4ArgsNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt: exports10._RNvXs1_NtNtNtCs5XY3BH99Eqp_3std3sys4args6commonNtB5_4ArgsNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt,
        _RNvXs1_NtNtNtCs5XY3BH99Eqp_3std3sys6os_str5bytesNtB5_3BufNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt: exports10._RNvXs1_NtNtNtCs5XY3BH99Eqp_3std3sys6os_str5bytesNtB5_3BufNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt,
        _RNvXs1_NvNtCs5XY3BH99Eqp_3std9panicking13panic_handlerNtB5_16StaticStrPayloadNtNtCsidipMUxUeKa_4core5panic12PanicPayload8take_box: exports10._RNvXs1_NvNtCs5XY3BH99Eqp_3std9panicking13panic_handlerNtB5_16StaticStrPayloadNtNtCsidipMUxUeKa_4core5panic12PanicPayload8take_box,
        _RNvXs2Y_NtNtCsidipMUxUeKa_4core3num11niche_typesNtB6_13I32NotAllOnesNtNtBa_3fmt5Debug3fmt: exports10._RNvXs2Y_NtNtCsidipMUxUeKa_4core3num11niche_typesNtB6_13I32NotAllOnesNtNtBa_3fmt5Debug3fmt,
        _RNvXs2_NtNtCs5XY3BH99Eqp_3std12backtrace_rs9symbolizeNtB5_10SymbolNameNtNtCsidipMUxUeKa_4core3fmt7Display3fmt: exports10._RNvXs2_NtNtCs5XY3BH99Eqp_3std12backtrace_rs9symbolizeNtB5_10SymbolNameNtNtCsidipMUxUeKa_4core3fmt7Display3fmt,
        _RNvXs2_NtNtCsidipMUxUeKa_4core5slice5asciiNtB5_11EscapeAsciiNtNtB9_3fmt7Display3fmt: exports10._RNvXs2_NtNtCsidipMUxUeKa_4core5slice5asciiNtB5_11EscapeAsciiNtNtB9_3fmt7Display3fmt,
        _RNvXs2_NvNtCs5XY3BH99Eqp_3std9panicking13panic_handlerNtB5_16StaticStrPayloadNtNtCsidipMUxUeKa_4core3fmt7Display3fmt: exports10._RNvXs2_NvNtCs5XY3BH99Eqp_3std9panicking13panic_handlerNtB5_16StaticStrPayloadNtNtCsidipMUxUeKa_4core3fmt7Display3fmt,
        _RNvXs3_NtCscviJhzjbUDx_4pyo38pybackedNtB5_11PyBackedStrNtNtCsidipMUxUeKa_4core3fmt7Display3fmt: exports10._RNvXs3_NtCscviJhzjbUDx_4pyo38pybackedNtB5_11PyBackedStrNtNtCsidipMUxUeKa_4core3fmt7Display3fmt,
        _RNvXs3_NtCsidipMUxUeKa_4core5asciiNtB5_13EscapeDefaultNtNtB7_3fmt7Display3fmt: exports10._RNvXs3_NtCsidipMUxUeKa_4core5asciiNtB5_13EscapeDefaultNtNtB7_3fmt7Display3fmt,
        _RNvXs3_NtNtNtCs5XY3BH99Eqp_3std3sys5stdio4unixNtB5_6StderrNtNtBb_2io5Write14write_vectored: exports10._RNvXs3_NtNtNtCs5XY3BH99Eqp_3std3sys5stdio4unixNtB5_6StderrNtNtBb_2io5Write14write_vectored,
        _RNvXs3_NtNtNtCs5XY3BH99Eqp_3std3sys5stdio4unixNtB5_6StderrNtNtBb_2io5Write5write: exports10._RNvXs3_NtNtNtCs5XY3BH99Eqp_3std3sys5stdio4unixNtB5_6StderrNtNtBb_2io5Write5write,
        _RNvXs3_NtNtNtCsidipMUxUeKa_4core3fmt3num3imptNtB9_7Display3fmt: exports10._RNvXs3_NtNtNtCsidipMUxUeKa_4core3fmt3num3imptNtB9_7Display3fmt,
        _RNvXs6_NtNtCsidipMUxUeKa_4core3fmt3numjNtB7_8LowerHex3fmt: exports10._RNvXsu_NtNtCsidipMUxUeKa_4core3fmt3nummNtB7_8LowerHex3fmt,
        _RNvXs6_NtNtCsidipMUxUeKa_4core3net7ip_addrNtB5_8Ipv4AddrNtNtB9_3fmt7Display3fmt: exports10._RNvXs6_NtNtCsidipMUxUeKa_4core3net7ip_addrNtB5_8Ipv4AddrNtNtB9_3fmt7Display3fmt,
        _RNvXs7_NtCsidipMUxUeKa_4core3fmtNtB5_9ArgumentsNtB5_5Debug3fmt: exports10._RNvXs7_NtCsidipMUxUeKa_4core3fmtNtB5_9ArgumentsNtB5_5Debug3fmt,
        _RNvXs7_NtNtCs5XY3BH99Eqp_3std2io5errorNtB5_5ErrorNtNtCsidipMUxUeKa_4core3fmt7Display3fmt: exports10._RNvXs7_NtNtCs5XY3BH99Eqp_3std2io5errorNtB5_5ErrorNtNtCsidipMUxUeKa_4core3fmt7Display3fmt,
        _RNvXs7_NtNtCscviJhzjbUDx_4pyo33err10cast_errorNtB5_20DisplayDowncastErrorNtNtCsidipMUxUeKa_4core3fmt7Display3fmt: exports10._RNvXs7_NtNtCscviJhzjbUDx_4pyo33err10cast_errorNtB5_20DisplayDowncastErrorNtNtCsidipMUxUeKa_4core3fmt7Display3fmt,
        _RNvXs8_NtCsidipMUxUeKa_4core3fmtNtB5_9ArgumentsNtB5_7Display3fmt: exports10._RNvXs8_NtCsidipMUxUeKa_4core3fmtNtB5_9ArgumentsNtB5_7Display3fmt,
        _RNvXs8_NtNtCscviJhzjbUDx_4pyo33err10cast_errorNtB5_16DisplayClassInfoNtNtCsidipMUxUeKa_4core3fmt7Display3fmt: exports10._RNvXs8_NtNtCscviJhzjbUDx_4pyo33err10cast_errorNtB5_16DisplayClassInfoNtNtCsidipMUxUeKa_4core3fmt7Display3fmt,
        _RNvXs8_NtNtNtCsidipMUxUeKa_4core3fmt3num3impmNtB9_7Display3fmt: exports10._RNvXsi_NtNtNtCsidipMUxUeKa_4core3fmt3num3impjNtB9_7Display3fmt,
        _RNvXs9_NtNtNtCsidipMUxUeKa_4core3fmt3num3implNtB9_7Display3fmt: exports10._RNvXs9_NtNtNtCsidipMUxUeKa_4core3fmt3num3implNtB9_7Display3fmt,
        _RNvXsK_NtNtCsidipMUxUeKa_4core3fmt3numoNtB7_8LowerHex3fmt: exports10._RNvXsK_NtNtCsidipMUxUeKa_4core3fmt3numoNtB7_8LowerHex3fmt,
        _RNvXsP_NtNtCs5XY3BH99Eqp_3std3ffi6os_strNtB5_7DisplayNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt: exports10._RNvXsP_NtNtCs5XY3BH99Eqp_3std3ffi6os_strNtB5_7DisplayNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt,
        _RNvXs_NtNtCs5XY3BH99Eqp_3std6thread5localNtB4_11AccessErrorNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt: exports10._RNvXs_NtNtCs5XY3BH99Eqp_3std6thread5localNtB4_11AccessErrorNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt,
        _RNvXs_NtNtNtCs5XY3BH99Eqp_3std3sys3env6commonNtB4_3EnvNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt: exports10._RNvXs_NtNtNtCs5XY3BH99Eqp_3std3sys3env6commonNtB4_3EnvNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt,
        _RNvXs_NvNtCs5XY3BH99Eqp_3std9panicking13panic_handlerNtB4_19FormatStringPayloadNtNtCsidipMUxUeKa_4core5panic12PanicPayload3get: exports10._RNvXs_NvNtCs5XY3BH99Eqp_3std9panicking13panic_handlerNtB4_19FormatStringPayloadNtNtCsidipMUxUeKa_4core5panic12PanicPayload3get,
        _RNvXs_NvNtCs5XY3BH99Eqp_3std9panicking13panic_handlerNtB4_19FormatStringPayloadNtNtCsidipMUxUeKa_4core5panic12PanicPayload8take_box: exports10._RNvXs_NvNtCs5XY3BH99Eqp_3std9panicking13panic_handlerNtB4_19FormatStringPayloadNtNtCsidipMUxUeKa_4core5panic12PanicPayload8take_box,
        _RNvXs_NvNtCs5XY3BH99Eqp_3std9panicking13resume_unwindNtB4_9RewrapBoxNtNtCsidipMUxUeKa_4core3fmt7Display3fmt: exports10._RNvXs_NvNtCs5XY3BH99Eqp_3std9panicking13resume_unwindNtB4_9RewrapBoxNtNtCsidipMUxUeKa_4core3fmt7Display3fmt,
        _RNvXs_NvXsf_NtNtCs156tPVBHeXz_5alloc5boxed7convertINtBc_3BoxDNtNtCsidipMUxUeKa_4core5error5ErrorNtNtB11_6marker4SyncNtB1y_4SendEL_EINtNtB11_7convert4FromNtNtBe_6string6StringE4fromNtB4_11StringErrorNtNtB11_3fmt7Display3fmt: exports10._RNvXs_NvXsf_NtNtCs156tPVBHeXz_5alloc5boxed7convertINtBc_3BoxDNtNtCsidipMUxUeKa_4core5error5ErrorNtNtB11_6marker4SyncNtB1y_4SendEL_EINtNtB11_7convert4FromNtNtBe_6string6StringE4fromNtB4_11StringErrorNtNtB11_3fmt7Display3fmt,
        _RNvXsa_NtCs5XY3BH99Eqp_3std4timeNtB5_10SystemTimeNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt: exports10._RNvXsa_NtCs5XY3BH99Eqp_3std4timeNtB5_10SystemTimeNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt,
        _RNvXsc_NtNtCsidipMUxUeKa_4core3num11niche_typesNtB5_11NanosecondsNtNtB9_3fmt5Debug3fmt: exports10._RNvXsc_NtNtCsidipMUxUeKa_4core3num11niche_typesNtB5_11NanosecondsNtNtB9_3fmt5Debug3fmt,
        _RNvXsd_NtNtNtCsidipMUxUeKa_4core3fmt3num3impyNtB9_7Display3fmt: exports10._RNvXsd_NtNtNtCsidipMUxUeKa_4core3fmt3num3impyNtB9_7Display3fmt,
        _RNvXse_NtNtCsidipMUxUeKa_4core3fmt3numhNtB7_8LowerHex3fmt: exports10._RNvXse_NtNtCsidipMUxUeKa_4core3fmt3numhNtB7_8LowerHex3fmt,
        _RNvXsg_NtNtCsidipMUxUeKa_4core3fmt3numhNtB7_8UpperHex3fmt: exports10._RNvXsg_NtNtCsidipMUxUeKa_4core3fmt3numhNtB7_8UpperHex3fmt,
        _RNvXsi_NtNtNtCsidipMUxUeKa_4core3fmt3num3impjNtB9_7Display3fmt: exports10._RNvXsi_NtNtNtCsidipMUxUeKa_4core3fmt3num3impjNtB9_7Display3fmt,
        _RNvXsj_NtCscviJhzjbUDx_4pyo36pycellNtB5_13PyBorrowErrorNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt: exports10._RNvXsj_NtCscviJhzjbUDx_4pyo36pycellNtB5_13PyBorrowErrorNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt,
        _RNvXsj_NtCsidipMUxUeKa_4core3fmtcNtB5_5Debug3fmt: exports10._RNvXsj_NtCsidipMUxUeKa_4core3fmtcNtB5_5Debug3fmt,
        _RNvXsj_NtNtNtCsidipMUxUeKa_4core3fmt3num3impiNtB9_7Display3fmt: exports10._RNvXs9_NtNtNtCsidipMUxUeKa_4core3fmt3num3implNtB9_7Display3fmt,
        _RNvXsk_NtCscviJhzjbUDx_4pyo36pycellNtB5_13PyBorrowErrorNtNtCsidipMUxUeKa_4core3fmt7Display3fmt: exports10._RNvXsk_NtCscviJhzjbUDx_4pyo36pycellNtB5_13PyBorrowErrorNtNtCsidipMUxUeKa_4core3fmt7Display3fmt,
        _RNvXsk_NtCsidipMUxUeKa_4core3fmtcNtB5_7Display3fmt: exports10._RNvXsk_NtCsidipMUxUeKa_4core3fmtcNtB5_7Display3fmt,
        _RNvXsm_NtNtCsidipMUxUeKa_4core3fmt3numtNtB7_8LowerHex3fmt: exports10._RNvXsm_NtNtCsidipMUxUeKa_4core3fmt3numtNtB7_8LowerHex3fmt,
        _RNvXsn_NtCscviJhzjbUDx_4pyo36pycellNtB5_16PyBorrowMutErrorNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt: exports10._RNvXsn_NtCscviJhzjbUDx_4pyo36pycellNtB5_16PyBorrowMutErrorNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt,
        _RNvXsn_NtCsidipMUxUeKa_4core4cellNtB5_11BorrowErrorNtNtB7_3fmt7Display3fmt: exports10._RNvXsn_NtCsidipMUxUeKa_4core4cellNtB5_11BorrowErrorNtNtB7_3fmt7Display3fmt,
        _RNvXso_NtCscviJhzjbUDx_4pyo36pycellNtB5_16PyBorrowMutErrorNtNtCsidipMUxUeKa_4core3fmt7Display3fmt: exports10._RNvXso_NtCscviJhzjbUDx_4pyo36pycellNtB5_16PyBorrowMutErrorNtNtCsidipMUxUeKa_4core3fmt7Display3fmt,
        _RNvXso_NtCsidipMUxUeKa_4core4cellNtB5_14BorrowMutErrorNtNtB7_3fmt7Display3fmt: exports10._RNvXso_NtCsidipMUxUeKa_4core4cellNtB5_14BorrowMutErrorNtNtB7_3fmt7Display3fmt,
        _RNvXso_NtNtCsidipMUxUeKa_4core3fmt3numtNtB7_8UpperHex3fmt: exports10._RNvXso_NtNtCsidipMUxUeKa_4core3fmt3numtNtB7_8UpperHex3fmt,
        _RNvXss_NtNtCs156tPVBHeXz_5alloc3ffi5c_strNtB5_8NulErrorNtNtCsidipMUxUeKa_4core3fmt7Display3fmt: exports10._RNvXss_NtNtCs156tPVBHeXz_5alloc3ffi5c_strNtB5_8NulErrorNtNtCsidipMUxUeKa_4core3fmt7Display3fmt,
        _RNvXss_NtNtCsidipMUxUeKa_4core3fmt3nummNtB7_5Octal3fmt: exports10._RNvXss_NtNtCsidipMUxUeKa_4core3fmt3nummNtB7_5Octal3fmt,
        _RNvXsu_NtNtCsidipMUxUeKa_4core3fmt3nummNtB7_8LowerHex3fmt: exports10._RNvXsu_NtNtCsidipMUxUeKa_4core3fmt3nummNtB7_8LowerHex3fmt,
        _RNvXsu_NtNtNtCs5XY3BH99Eqp_3std3sys2fs4unixNtB5_4ModeNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt: exports10._RNvXsu_NtNtNtCs5XY3BH99Eqp_3std3sys2fs4unixNtB5_4ModeNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt,
        _RNvXsx_NtCs5XY3BH99Eqp_3std2fsNtB5_8FileTypeNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt: exports10._RNvXsx_NtCs5XY3BH99Eqp_3std2fsNtB5_8FileTypeNtNtCsidipMUxUeKa_4core3fmt5Debug3fmt,
        __wasm_apply_data_relocs: exports10.__wasm_apply_data_relocs,
        _initialize: exports10._initialize,
      },
      'libpython3.14.so': {
        PY_TIMEOUT_MAX: exports9.PY_TIMEOUT_MAX,
        PyAsyncGen_Type: exports9.PyAsyncGen_Type,
        PyBaseObject_Type: exports9.PyBaseObject_Type,
        PyBool_Type: exports9.PyBool_Type,
        PyByteArrayIter_Type: exports9.PyByteArrayIter_Type,
        PyByteArray_Concat: exports9.PyByteArray_Concat,
        PyByteArray_Type: exports9.PyByteArray_Type,
        PyBytesIter_Type: exports9.PyBytesIter_Type,
        PyBytes_Type: exports9.PyBytes_Type,
        PyCFunction_Type: exports9.PyCFunction_Type,
        PyCMethod_Type: exports9.PyCMethod_Type,
        PyCallIter_Type: exports9.PyCallIter_Type,
        PyCapsule_Type: exports9.PyCapsule_Type,
        PyCell_Type: exports9.PyCell_Type,
        PyClassMethodDescr_Type: exports9.PyClassMethodDescr_Type,
        PyClassMethod_Type: exports9.PyClassMethod_Type,
        PyCode_Type: exports9.PyCode_Type,
        PyComplex_Type: exports9.PyComplex_Type,
        PyContextToken_Type: exports9.PyContextToken_Type,
        PyContextVar_Type: exports9.PyContextVar_Type,
        PyContext_Type: exports9.PyContext_Type,
        PyCoro_Type: exports9.PyCoro_Type,
        PyDictItems_Type: exports9.PyDictItems_Type,
        PyDictIterItem_Type: exports9.PyDictIterItem_Type,
        PyDictIterKey_Type: exports9.PyDictIterKey_Type,
        PyDictIterValue_Type: exports9.PyDictIterValue_Type,
        PyDictKeys_Type: exports9.PyDictKeys_Type,
        PyDictProxy_Type: exports9.PyDictProxy_Type,
        PyDictRevIterItem_Type: exports9.PyDictRevIterItem_Type,
        PyDictRevIterKey_Type: exports9.PyDictRevIterKey_Type,
        PyDictRevIterValue_Type: exports9.PyDictRevIterValue_Type,
        PyDictValues_Type: exports9.PyDictValues_Type,
        PyDict_Contains: exports9.PyDict_Contains,
        PyDict_Type: exports9.PyDict_Type,
        PyEllipsis_Type: exports9.PyEllipsis_Type,
        PyEnum_Type: exports9.PyEnum_Type,
        PyExc_ArithmeticError: exports9.PyExc_ArithmeticError,
        PyExc_AssertionError: exports9.PyExc_AssertionError,
        PyExc_AttributeError: exports9.PyExc_AttributeError,
        PyExc_BaseException: exports9.PyExc_BaseException,
        PyExc_BaseExceptionGroup: exports9.PyExc_BaseExceptionGroup,
        PyExc_BlockingIOError: exports9.PyExc_BlockingIOError,
        PyExc_BrokenPipeError: exports9.PyExc_BrokenPipeError,
        PyExc_BufferError: exports9.PyExc_BufferError,
        PyExc_BytesWarning: exports9.PyExc_BytesWarning,
        PyExc_ChildProcessError: exports9.PyExc_ChildProcessError,
        PyExc_ConnectionAbortedError: exports9.PyExc_ConnectionAbortedError,
        PyExc_ConnectionRefusedError: exports9.PyExc_ConnectionRefusedError,
        PyExc_ConnectionResetError: exports9.PyExc_ConnectionResetError,
        PyExc_DeprecationWarning: exports9.PyExc_DeprecationWarning,
        PyExc_EOFError: exports9.PyExc_EOFError,
        PyExc_EncodingWarning: exports9.PyExc_EncodingWarning,
        PyExc_EnvironmentError: exports9.PyExc_EnvironmentError,
        PyExc_Exception: exports9.PyExc_Exception,
        PyExc_FileExistsError: exports9.PyExc_FileExistsError,
        PyExc_FileNotFoundError: exports9.PyExc_FileNotFoundError,
        PyExc_GeneratorExit: exports9.PyExc_GeneratorExit,
        PyExc_IOError: exports9.PyExc_IOError,
        PyExc_ImportError: exports9.PyExc_ImportError,
        PyExc_ImportWarning: exports9.PyExc_ImportWarning,
        PyExc_IndentationError: exports9.PyExc_IndentationError,
        PyExc_IndexError: exports9.PyExc_IndexError,
        PyExc_InterpreterError: exports9.PyExc_InterpreterError,
        PyExc_InterpreterNotFoundError: exports9.PyExc_InterpreterNotFoundError,
        PyExc_InterruptedError: exports9.PyExc_InterruptedError,
        PyExc_IsADirectoryError: exports9.PyExc_IsADirectoryError,
        PyExc_KeyError: exports9.PyExc_KeyError,
        PyExc_KeyboardInterrupt: exports9.PyExc_KeyboardInterrupt,
        PyExc_LookupError: exports9.PyExc_LookupError,
        PyExc_MemoryError: exports9.PyExc_MemoryError,
        PyExc_ModuleNotFoundError: exports9.PyExc_ModuleNotFoundError,
        PyExc_NameError: exports9.PyExc_NameError,
        PyExc_NotADirectoryError: exports9.PyExc_NotADirectoryError,
        PyExc_NotImplementedError: exports9.PyExc_NotImplementedError,
        PyExc_OSError: exports9.PyExc_OSError,
        PyExc_OverflowError: exports9.PyExc_OverflowError,
        PyExc_PendingDeprecationWarning: exports9.PyExc_PendingDeprecationWarning,
        PyExc_PermissionError: exports9.PyExc_PermissionError,
        PyExc_ProcessLookupError: exports9.PyExc_ProcessLookupError,
        PyExc_PythonFinalizationError: exports9.PyExc_PythonFinalizationError,
        PyExc_RecursionError: exports9.PyExc_RecursionError,
        PyExc_ReferenceError: exports9.PyExc_ReferenceError,
        PyExc_ResourceWarning: exports9.PyExc_ResourceWarning,
        PyExc_RuntimeError: exports9.PyExc_RuntimeError,
        PyExc_RuntimeWarning: exports9.PyExc_RuntimeWarning,
        PyExc_StopAsyncIteration: exports9.PyExc_StopAsyncIteration,
        PyExc_StopIteration: exports9.PyExc_StopIteration,
        PyExc_SyntaxError: exports9.PyExc_SyntaxError,
        PyExc_SyntaxWarning: exports9.PyExc_SyntaxWarning,
        PyExc_SystemError: exports9.PyExc_SystemError,
        PyExc_SystemExit: exports9.PyExc_SystemExit,
        PyExc_TabError: exports9.PyExc_TabError,
        PyExc_TimeoutError: exports9.PyExc_TimeoutError,
        PyExc_TypeError: exports9.PyExc_TypeError,
        PyExc_UnboundLocalError: exports9.PyExc_UnboundLocalError,
        PyExc_UnicodeDecodeError: exports9.PyExc_UnicodeDecodeError,
        PyExc_UnicodeEncodeError: exports9.PyExc_UnicodeEncodeError,
        PyExc_UnicodeError: exports9.PyExc_UnicodeError,
        PyExc_UnicodeTranslateError: exports9.PyExc_UnicodeTranslateError,
        PyExc_UserWarning: exports9.PyExc_UserWarning,
        PyExc_ValueError: exports9.PyExc_ValueError,
        PyExc_Warning: exports9.PyExc_Warning,
        PyExc_ZeroDivisionError: exports9.PyExc_ZeroDivisionError,
        PyFilter_Type: exports9.PyFilter_Type,
        PyFloat_Type: exports9.PyFloat_Type,
        PyFrameLocalsProxy_Type: exports9.PyFrameLocalsProxy_Type,
        PyFrame_Type: exports9.PyFrame_Type,
        PyFrozenSet_Type: exports9.PyFrozenSet_Type,
        PyFunction_Type: exports9.PyFunction_Type,
        PyGen_Type: exports9.PyGen_Type,
        PyGetSetDescr_Type: exports9.PyGetSetDescr_Type,
        PyImport_FrozenModules: exports9.PyImport_FrozenModules,
        PyImport_Inittab: exports9.PyImport_Inittab,
        PyInit__abc: exports9.PyInit__abc,
        PyInit__ast: exports9.PyInit__ast,
        PyInit__asyncio: exports9.PyInit__asyncio,
        PyInit__bisect: exports9.PyInit__bisect,
        PyInit__blake2: exports9.PyInit__blake2,
        PyInit__codecs: exports9.PyInit__codecs,
        PyInit__codecs_cn: exports9.PyInit__codecs_cn,
        PyInit__codecs_hk: exports9.PyInit__codecs_hk,
        PyInit__codecs_iso2022: exports9.PyInit__codecs_iso2022,
        PyInit__codecs_jp: exports9.PyInit__codecs_jp,
        PyInit__codecs_kr: exports9.PyInit__codecs_kr,
        PyInit__codecs_tw: exports9.PyInit__codecs_tw,
        PyInit__collections: exports9.PyInit__collections,
        PyInit__contextvars: exports9.PyInit__contextvars,
        PyInit__csv: exports9.PyInit__csv,
        PyInit__datetime: exports9.PyInit__datetime,
        PyInit__decimal: exports9.PyInit__decimal,
        PyInit__elementtree: exports9.PyInit__elementtree,
        PyInit__functools: exports9.PyInit__functools,
        PyInit__heapq: exports9.PyInit__heapq,
        PyInit__hmac: exports9.PyInit__hmac,
        PyInit__imp: exports9.PyInit__imp,
        PyInit__io: exports9.PyInit__io,
        PyInit__json: exports9.PyInit__json,
        PyInit__locale: exports9.PyInit__locale,
        PyInit__lsprof: exports9.PyInit__lsprof,
        PyInit__md5: exports9.PyInit__md5,
        PyInit__multibytecodec: exports9.PyInit__multibytecodec,
        PyInit__opcode: exports9.PyInit__opcode,
        PyInit__operator: exports9.PyInit__operator,
        PyInit__pickle: exports9.PyInit__pickle,
        PyInit__queue: exports9.PyInit__queue,
        PyInit__random: exports9.PyInit__random,
        PyInit__sha1: exports9.PyInit__sha1,
        PyInit__sha2: exports9.PyInit__sha2,
        PyInit__sha3: exports9.PyInit__sha3,
        PyInit__signal: exports9.PyInit__signal,
        PyInit__socket: exports9.PyInit__socket,
        PyInit__sqlite3: exports9.PyInit__sqlite3,
        PyInit__sre: exports9.PyInit__sre,
        PyInit__stat: exports9.PyInit__stat,
        PyInit__statistics: exports9.PyInit__statistics,
        PyInit__string: exports9.PyInit__string,
        PyInit__struct: exports9.PyInit__struct,
        PyInit__suggestions: exports9.PyInit__suggestions,
        PyInit__symtable: exports9.PyInit__symtable,
        PyInit__sysconfig: exports9.PyInit__sysconfig,
        PyInit__thread: exports9.PyInit__thread,
        PyInit__tokenize: exports9.PyInit__tokenize,
        PyInit__tracemalloc: exports9.PyInit__tracemalloc,
        PyInit__types: exports9.PyInit__types,
        PyInit__typing: exports9.PyInit__typing,
        PyInit__weakref: exports9.PyInit__weakref,
        PyInit__zoneinfo: exports9.PyInit__zoneinfo,
        PyInit_array: exports9.PyInit_array,
        PyInit_atexit: exports9.PyInit_atexit,
        PyInit_binascii: exports9.PyInit_binascii,
        PyInit_cmath: exports9.PyInit_cmath,
        PyInit_errno: exports9.PyInit_errno,
        PyInit_faulthandler: exports9.PyInit_faulthandler,
        PyInit_gc: exports9.PyInit_gc,
        PyInit_itertools: exports9.PyInit_itertools,
        PyInit_math: exports9.PyInit_math,
        PyInit_posix: exports9.PyInit_posix,
        PyInit_pyexpat: exports9.PyInit_pyexpat,
        PyInit_select: exports9.PyInit_select,
        PyInit_time: exports9.PyInit_time,
        PyInit_unicodedata: exports9.PyInit_unicodedata,
        PyInit_zlib: exports9.PyInit_zlib,
        PyInstanceMethod_Type: exports9.PyInstanceMethod_Type,
        PyListIter_Type: exports9.PyListIter_Type,
        PyListRevIter_Type: exports9.PyListRevIter_Type,
        PyList_Type: exports9.PyList_Type,
        PyLongRangeIter_Type: exports9.PyLongRangeIter_Type,
        PyLong_Type: exports9.PyLong_Type,
        PyMap_Type: exports9.PyMap_Type,
        PyMarshal_Init: exports9.PyMarshal_Init,
        PyMem_Free: exports9.PyMem_Free,
        PyMem_Malloc: exports9.PyMem_Malloc,
        PyMem_RawFree: exports9.PyMem_RawFree,
        PyMem_RawMalloc: exports9.PyMem_RawMalloc,
        PyMem_Realloc: exports9.PyMem_Realloc,
        PyMemberDescr_Type: exports9.PyMemberDescr_Type,
        PyMemoryView_Type: exports9.PyMemoryView_Type,
        PyMethodDescr_Type: exports9.PyMethodDescr_Type,
        PyMethod_Type: exports9.PyMethod_Type,
        PyModuleDef_Type: exports9.PyModuleDef_Type,
        PyModule_Type: exports9.PyModule_Type,
        PyNumber_Add: exports9.PyNumber_Add,
        PyNumber_And: exports9.PyNumber_And,
        PyNumber_FloorDivide: exports9.PyNumber_FloorDivide,
        PyNumber_InPlaceAdd: exports9.PyNumber_InPlaceAdd,
        PyNumber_InPlaceAnd: exports9.PyNumber_InPlaceAnd,
        PyNumber_InPlaceFloorDivide: exports9.PyNumber_InPlaceFloorDivide,
        PyNumber_InPlaceLshift: exports9.PyNumber_InPlaceLshift,
        PyNumber_InPlaceMatrixMultiply: exports9.PyNumber_InPlaceMatrixMultiply,
        PyNumber_InPlaceMultiply: exports9.PyNumber_InPlaceMultiply,
        PyNumber_InPlaceOr: exports9.PyNumber_InPlaceOr,
        PyNumber_InPlaceRemainder: exports9.PyNumber_InPlaceRemainder,
        PyNumber_InPlaceRshift: exports9.PyNumber_InPlaceRshift,
        PyNumber_InPlaceSubtract: exports9.PyNumber_InPlaceSubtract,
        PyNumber_InPlaceTrueDivide: exports9.PyNumber_InPlaceTrueDivide,
        PyNumber_InPlaceXor: exports9.PyNumber_InPlaceXor,
        PyNumber_Lshift: exports9.PyNumber_Lshift,
        PyNumber_MatrixMultiply: exports9.PyNumber_MatrixMultiply,
        PyNumber_Multiply: exports9.PyNumber_Multiply,
        PyNumber_Or: exports9.PyNumber_Or,
        PyNumber_Remainder: exports9.PyNumber_Remainder,
        PyNumber_Rshift: exports9.PyNumber_Rshift,
        PyNumber_Subtract: exports9.PyNumber_Subtract,
        PyNumber_TrueDivide: exports9.PyNumber_TrueDivide,
        PyNumber_Xor: exports9.PyNumber_Xor,
        PyODictItems_Type: exports9.PyODictItems_Type,
        PyODictIter_Type: exports9.PyODictIter_Type,
        PyODictKeys_Type: exports9.PyODictKeys_Type,
        PyODictValues_Type: exports9.PyODictValues_Type,
        PyODict_Type: exports9.PyODict_Type,
        PyOS_InputHook: exports9.PyOS_InputHook,
        PyOS_ReadlineFunctionPointer: exports9.PyOS_ReadlineFunctionPointer,
        PyObject_ASCII: exports9.PyObject_ASCII,
        PyObject_Free: exports9.PyObject_Free,
        PyObject_GC_Del: exports9.PyObject_GC_Del,
        PyObject_GenericGetAttr: exports9.PyObject_GenericGetAttr,
        PyObject_GenericGetDict: exports9.PyObject_GenericGetDict,
        PyObject_GenericHash: exports9.PyObject_GenericHash,
        PyObject_GenericSetAttr: exports9.PyObject_GenericSetAttr,
        PyObject_GenericSetDict: exports9.PyObject_GenericSetDict,
        PyObject_GetItem: exports9.PyObject_GetItem,
        PyObject_HashNotImplemented: exports9.PyObject_HashNotImplemented,
        PyObject_Repr: exports9.PyObject_Repr,
        PyObject_SelfIter: exports9.PyObject_SelfIter,
        PyObject_Str: exports9.PyObject_Str,
        PyPickleBuffer_Type: exports9.PyPickleBuffer_Type,
        PyProperty_Type: exports9.PyProperty_Type,
        PyRangeIter_Type: exports9.PyRangeIter_Type,
        PyRange_Type: exports9.PyRange_Type,
        PyReversed_Type: exports9.PyReversed_Type,
        PySeqIter_Type: exports9.PySeqIter_Type,
        PySetIter_Type: exports9.PySetIter_Type,
        PySet_Type: exports9.PySet_Type,
        PySlice_Type: exports9.PySlice_Type,
        PyStaticMethod_Type: exports9.PyStaticMethod_Type,
        PyStdPrinter_Type: exports9.PyStdPrinter_Type,
        PyStructSequence_UnnamedField: exports9.PyStructSequence_UnnamedField,
        PySuper_Type: exports9.PySuper_Type,
        PyTraceBack_Type: exports9.PyTraceBack_Type,
        PyTupleIter_Type: exports9.PyTupleIter_Type,
        PyTuple_Type: exports9.PyTuple_Type,
        PyType_GenericAlloc: exports9.PyType_GenericAlloc,
        PyType_GenericNew: exports9.PyType_GenericNew,
        PyType_Type: exports9.PyType_Type,
        PyUnicodeIter_Type: exports9.PyUnicodeIter_Type,
        PyUnicode_AsASCIIString: exports9.PyUnicode_AsASCIIString,
        PyUnicode_AsUTF8String: exports9.PyUnicode_AsUTF8String,
        PyUnicode_Concat: exports9.PyUnicode_Concat,
        PyUnicode_Contains: exports9.PyUnicode_Contains,
        PyUnicode_RichCompare: exports9.PyUnicode_RichCompare,
        PyUnicode_Type: exports9.PyUnicode_Type,
        PyVectorcall_Call: exports9.PyVectorcall_Call,
        PyWrapperDescr_Type: exports9.PyWrapperDescr_Type,
        PyZip_Type: exports9.PyZip_Type,
        Py_BytesWarningFlag: exports9.Py_BytesWarningFlag,
        Py_DebugFlag: exports9.Py_DebugFlag,
        Py_DontWriteBytecodeFlag: exports9.Py_DontWriteBytecodeFlag,
        Py_FileSystemDefaultEncodeErrors: exports9.Py_FileSystemDefaultEncodeErrors,
        Py_FileSystemDefaultEncoding: exports9.Py_FileSystemDefaultEncoding,
        Py_FrozenFlag: exports9.Py_FrozenFlag,
        Py_GenericAlias: exports9.Py_GenericAlias,
        Py_GenericAliasType: exports9.Py_GenericAliasType,
        Py_HasFileSystemDefaultEncoding: exports9.Py_HasFileSystemDefaultEncoding,
        Py_HashRandomizationFlag: exports9.Py_HashRandomizationFlag,
        Py_IgnoreEnvironmentFlag: exports9.Py_IgnoreEnvironmentFlag,
        Py_InspectFlag: exports9.Py_InspectFlag,
        Py_InteractiveFlag: exports9.Py_InteractiveFlag,
        Py_IsolatedFlag: exports9.Py_IsolatedFlag,
        Py_NoSiteFlag: exports9.Py_NoSiteFlag,
        Py_NoUserSiteDirectory: exports9.Py_NoUserSiteDirectory,
        Py_OptimizeFlag: exports9.Py_OptimizeFlag,
        Py_QuietFlag: exports9.Py_QuietFlag,
        Py_UTF8Mode: exports9.Py_UTF8Mode,
        Py_UnbufferedStdioFlag: exports9.Py_UnbufferedStdioFlag,
        Py_VerboseFlag: exports9.Py_VerboseFlag,
        Py_hexdigits: exports9.Py_hexdigits,
        _PyAsyncGenASend_Type: exports9._PyAsyncGenASend_Type,
        _PyByteArray_empty_string: exports9._PyByteArray_empty_string,
        _PyBytes_FromXIData: exports9._PyBytes_FromXIData,
        _PyBytes_GetXIData: exports9._PyBytes_GetXIData,
        _PyCode_FromXIData: exports9._PyCode_FromXIData,
        _PyEval_BinaryOps: exports9._PyEval_BinaryOps,
        _PyEval_ConversionFuncs: exports9._PyEval_ConversionFuncs,
        _PyEval_EvalFrameDefault: exports9._PyEval_EvalFrameDefault,
        _PyExc_IncompleteInputError: exports9._PyExc_IncompleteInputError,
        _PyFunction_FromXIData: exports9._PyFunction_FromXIData,
        _PyImport_FrozenBootstrap: exports9._PyImport_FrozenBootstrap,
        _PyImport_FrozenStdlib: exports9._PyImport_FrozenStdlib,
        _PyImport_FrozenTest: exports9._PyImport_FrozenTest,
        _PyIntrinsics_BinaryFunctions: exports9._PyIntrinsics_BinaryFunctions,
        _PyIntrinsics_UnaryFunctions: exports9._PyIntrinsics_UnaryFunctions,
        _PyLong_DigitValue: exports9._PyLong_DigitValue,
        _PyMarshal_ReadObjectFromXIData: exports9._PyMarshal_ReadObjectFromXIData,
        _PyNone_Type: exports9._PyNone_Type,
        _PyNotImplemented_Type: exports9._PyNotImplemented_Type,
        _PyOS_ReadlineTState: exports9._PyOS_ReadlineTState,
        _PyPickle_LoadFromXIData: exports9._PyPickle_LoadFromXIData,
        _PyRuntime: exports9._PyRuntime,
        _PyTime_gmtime: exports9._PyTime_gmtime,
        _PyTime_localtime: exports9._PyTime_localtime,
        _PyUnion_Type: exports9._PyUnion_Type,
        _PyWarnings_Init: exports9._PyWarnings_Init,
        _PyWeakref_CallableProxyType: exports9._PyWeakref_CallableProxyType,
        _PyWeakref_ProxyType: exports9._PyWeakref_ProxyType,
        _PyWeakref_RefType: exports9._PyWeakref_RefType,
        _Py_EllipsisObject: exports9._Py_EllipsisObject,
        _Py_FalseStruct: exports9._Py_FalseStruct,
        _Py_FunctionAttributeOffsets: exports9._Py_FunctionAttributeOffsets,
        _Py_HashSecret: exports9._Py_HashSecret,
        _Py_InitCleanup: exports9._Py_InitCleanup,
        _Py_NoneStruct: exports9._Py_NoneStruct,
        _Py_NotImplementedStruct: exports9._Py_NotImplementedStruct,
        _Py_SpecialMethods: exports9._Py_SpecialMethods,
        _Py_SwappedOp: exports9._Py_SwappedOp,
        _Py_TrueStruct: exports9._Py_TrueStruct,
        _Py_ascii_whitespace: exports9._Py_ascii_whitespace,
        _Py_ctype_table: exports9._Py_ctype_table,
        _Py_ctype_tolower: exports9._Py_ctype_tolower,
        _Py_ctype_toupper: exports9._Py_ctype_toupper,
        _Py_hashtable_compare_direct: exports9._Py_hashtable_compare_direct,
        _Py_hashtable_hash_ptr: exports9._Py_hashtable_hash_ptr,
        _Py_union_type_or: exports9._Py_union_type_or,
        __wasm_apply_data_relocs: exports9.__wasm_apply_data_relocs,
        _initialize: exports9._initialize,
      },
      'libwasi-emulated-getpid.so': {
        _initialize: exports7._initialize,
      },
      'libwasi-emulated-process-clocks.so': {
        _initialize: exports5._initialize,
        clock: exports5.__clock,
      },
      'libwasi-emulated-signal.so': {
        __SIG_ERR: exports6.__SIG_ERR,
        __SIG_IGN: exports6.__SIG_IGN,
        __sysv_signal: exports6.signal,
        __wasm_apply_data_relocs: exports6.__wasm_apply_data_relocs,
        _initialize: exports6._initialize,
        bsd_signal: exports6.signal,
      },
    }));
    callback_0 = exports11['[callback][async-lift]execute'];
    callback_1 = exports11['[callback][async-lift]snapshot-state'];
    callback_2 = exports11['[callback][async-lift]restore-state'];
    callback_3 = exports11['[callback][async-lift]clear-state'];
    postReturn0 = exports11['cabi_post_finalize-preinit'];
    exports11AsyncLiftExecute = exports11['[async-lift]execute'];
    exports11AsyncLiftSnapshotState = exports11['[async-lift]snapshot-state'];
    exports11AsyncLiftRestoreState = exports11['[async-lift]restore-state'];
    exports11AsyncLiftClearState = exports11['[async-lift]clear-state'];
    exports11FinalizePreinit = exports11['finalize-preinit'];
  })();
  let promise, resolve, reject;
  function runNext (value) {
    try {
      let done;
      do {
        ({ value, done } = gen.next(value));
      } while (!(value instanceof Promise) && !done);
      if (done) {
        if (resolve) resolve(value);
        else return value;
      }
      if (!promise) promise = new Promise((_resolve, _reject) => (resolve = _resolve, reject = _reject));
      value.then(runNext, reject);
    }
    catch (e) {
      if (reject) reject(e);
      else throw e;
    }
  }
  const maybeSyncReturn = runNext(null);
  return promise || maybeSyncReturn;
})();

await $init;

export { clearState, execute, finalizePreinit, restoreState, snapshotState,  }