# eryx-wasm-runtime

Custom WASM guest runtime for the eryx sandbox.

## Purpose

This crate replaces `libcomponentize_py_runtime.so` from componentize-py with a
purpose-built runtime that hardcodes the eryx sandbox interface.

## Why?

componentize-py's runtime is generic - it can dispatch any WIT export to any
Python method, but requires a "symbols" structure to know the mapping. This
symbols structure is generated by componentize-py's code generation phase.

We want to link native extensions without running componentize-py for every
combination. By using a custom runtime that knows exactly what exports we have
(execute, snapshot-state, restore-state, clear-state), we can:

1. Link extensions with wit-component::Linker
2. Use our runtime instead of componentize-py's
3. Skip the symbols/code generation entirely

## Architecture

```
wit-dylib bindings (generated from runtime.wit)
       ↓
liberyx_runtime.so (this crate, compiled to wasm32-wasip1 core module)
       ↓
libpython3.14.so + native extensions
       ↓
wit-component link → final Component (WASI Preview 2)
```

Note: We compile to `wasm32-wasip1` to produce a core WASM module with dynamic
linking support (`@dylink.0`). The final component uses WASI Preview 2 interfaces,
but that's handled by `wit-component` when linking everything together. There is
no `wasm32-wasip2` clang target - Preview 2 is about the Component Model wrapper,
not a different core module ABI.

## Interface

This crate must implement wit-dylib's interpreter interface:

- `wit_dylib_initialize` - Called once at startup
- `wit_dylib_export_call` - Called for sync exports  
- `wit_dylib_export_async_call` - Called for async exports
- Various other functions for memory management, imports, etc.

## Exports implemented

- `execute(code: string) -> result<string, string>` - Run Python code
- `snapshot-state() -> result<list<u8>, string>` - Pickle globals
- `restore-state(data: list<u8>) -> result<_, string>` - Restore globals
- `clear-state()` - Clear globals

## Imports used

- `invoke(name, args) -> result<string, string>` - Call host callback (async)
- `list-callbacks() -> list<callback-info>` - List available callbacks
- `report-trace(lineno, event, context)` - Report execution trace

## Async Runtime

This crate includes an embedded async runtime (`_eryx_async`) that provides a minimal
asyncio event loop for the Component Model's async callback protocol.

### What works

- `await` on host callbacks (`await get_time()`, `await echo(message="hi")`)
- `asyncio.gather()` for parallel callback execution
- `asyncio.create_task()` for concurrent tasks
- `asyncio.Future` for basic promise patterns
- Nested coroutines

### Limitations

The async runtime is intentionally minimal. The following do **not** work:

- `asyncio.sleep()` - No timer support (use a host `sleep` callback instead)
- `asyncio.wait_for()` with timeout - Requires timers
- `loop.run_in_executor()` - No thread pool in WASI
- `loop.time()` - Not implemented
- Network/socket operations - Not available in WASI sandbox
- Subprocess operations - Not available in WASI sandbox

These limitations are acceptable because the WASI sandbox doesn't have filesystem
or network access anyway. If you need delays, have the host provide a `sleep` callback.
