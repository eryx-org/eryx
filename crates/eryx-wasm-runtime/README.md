# eryx-wasm-runtime

Custom WASM guest runtime for the eryx sandbox.

## Purpose

This crate replaces `libcomponentize_py_runtime.so` from componentize-py with a
purpose-built runtime that hardcodes the eryx sandbox interface.

## Why?

componentize-py's runtime is generic - it can dispatch any WIT export to any
Python method, but requires a "symbols" structure to know the mapping. This
symbols structure is generated by componentize-py's code generation phase.

We want to link native extensions without running componentize-py for every
combination. By using a custom runtime that knows exactly what exports we have
(execute, snapshot-state, restore-state, clear-state), we can:

1. Link extensions with wit-component::Linker
2. Use our runtime instead of componentize-py's
3. Skip the symbols/code generation entirely

## Architecture

```
wit-dylib bindings (generated from runtime.wit)
       ↓
liberyx_runtime.so (this crate, compiled to wasm32-wasip1 core module)
       ↓
libpython3.14.so + native extensions
       ↓
wit-component link → final Component (WASI Preview 2)
```

Note: We compile to `wasm32-wasip1` to produce a core WASM module with dynamic
linking support (`@dylink.0`). The final component uses WASI Preview 2 interfaces,
but that's handled by `wit-component` when linking everything together. There is
no `wasm32-wasip2` clang target - Preview 2 is about the Component Model wrapper,
not a different core module ABI.

## Interface

This crate must implement wit-dylib's interpreter interface:

- `wit_dylib_initialize` - Called once at startup
- `wit_dylib_export_call` - Called for sync exports  
- `wit_dylib_export_async_call` - Called for async exports
- Various other functions for memory management, imports, etc.

## Exports implemented

- `execute(code: string) -> result<string, string>` - Run Python code
- `snapshot-state() -> result<list<u8>, string>` - Pickle globals
- `restore-state(data: list<u8>) -> result<_, string>` - Restore globals
- `clear-state()` - Clear globals

## Imports used

- `invoke(name, args) -> result<string, string>` - Call host callback (async)
- `list-callbacks() -> list<callback-info>` - List available callbacks
- `report-trace(lineno, event, context)` - Report execution trace
