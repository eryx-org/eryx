package eryx:sandbox@0.1.0;

/// TLS networking interface for the eryx sandbox.
///
/// Provides secure network connections for Python code running in the sandbox.
/// All connections use TLS - no plaintext TCP is exposed.
interface tls {
    /// Errors that can occur during network operations.
    variant tls-error {
        /// Connection was refused by the remote host.
        connection-refused,
        /// Connection was reset by the remote host.
        connection-reset,
        /// Operation timed out.
        timed-out,
        /// DNS lookup failed.
        host-not-found,
        /// TLS handshake or certificate verification failed.
        tls-handshake-failed(string),
        /// Generic I/O error.
        io-error(string),
        /// Network access not permitted by sandbox policy.
        not-permitted(string),
        /// Invalid handle (connection was closed).
        invalid-handle,
    }

    /// Opaque handle to a TLS connection (managed by host).
    type tls-handle = u32;

    /// Connect to a host:port with TLS.
    ///
    /// The hostname is used for DNS resolution, TLS SNI, and certificate
    /// hostname verification. The host controls which connections are
    /// allowed via its network policy configuration.
    ///
    /// This is an async function - Python code can await it:
    ///   handle = await tls_connect("api.example.com", 443)
    connect: async func(host: string, port: u16) -> result<tls-handle, tls-error>;

    /// Read up to `len` bytes from a TLS connection.
    ///
    /// Returns the bytes read. May return fewer than `len` bytes if less
    /// data is available. Returns empty list on EOF (connection closed
    /// gracefully by peer).
    ///
    /// This is an async function that suspends until data is available:
    ///   data = await tls_read(handle, 4096)
    read: async func(handle: tls-handle, len: u32) -> result<list<u8>, tls-error>;

    /// Write bytes to a TLS connection.
    ///
    /// Returns the number of bytes written. May be less than the input
    /// length if the connection buffer is full.
    ///
    /// This is an async function:
    ///   written = await tls_write(handle, data)
    write: async func(handle: tls-handle, data: list<u8>) -> result<u32, tls-error>;

    /// Close a TLS connection.
    ///
    /// Performs a graceful TLS shutdown and closes the underlying TCP
    /// connection. After this call, the handle is invalid.
    close: func(handle: tls-handle);
}

/// The eryx sandbox runtime world.
///
/// This defines the interface between the host (Rust) and the guest (Python WASM).
/// The guest can invoke callbacks on the host, list available callbacks, and report
/// trace events. The host calls the guest's execute function to run Python code.
world sandbox {
    /// TLS networking for secure connections.
    import tls;

    /// Invoke a callback by name with JSON arguments.
    ///
    /// This is an async function that Python code can await:
    ///   result = await invoke("callback_name", '{"arg": "value"}')
    ///
    /// Multiple invocations can run in parallel via asyncio.gather():
    ///   results = await asyncio.gather(
    ///       invoke("query", '{"q": "a"}'),
    ///       invoke("query", '{"q": "b"}'),
    ///   )
    ///
    /// Returns the callback result as a JSON string on success,
    /// or an error message on failure.
    import invoke: async func(name: string, arguments-json: string) -> result<string, string>;

    /// List all available callbacks for introspection.
    ///
    /// Python code can discover what callbacks are available:
    ///   callbacks = list_callbacks()
    ///   for cb in callbacks:
    ///       print(f"{cb['name']}: {cb['description']}")
    import list-callbacks: func() -> list<callback-info>;

    /// Report a trace event to the host.
    ///
    /// Called by the Python runtime's sys.settrace hook to report
    /// execution progress. The host can use this for visualization,
    /// debugging, or progress tracking.
    ///
    /// - lineno: Line number in the source code
    /// - event: Event type as JSON (e.g., {"type": "line"} or {"type": "call", "function": "foo"})
    /// - context-json: Optional context data (e.g., local variables snapshot)
    import report-trace: func(lineno: u32, event-json: string, context-json: string);

    /// Callback metadata returned by list-callbacks.
    record callback-info {
        /// Unique name for this callback (e.g., "http.get", "grafana.prometheus").
        name: string,
        /// Human-readable description of what this callback does.
        description: string,
        /// JSON Schema for expected arguments.
        parameters-schema-json: string,
    }

    /// Execute Python code in the sandbox.
    ///
    /// The code can use top-level await directly:
    ///   result = await invoke("get_time", "{}")
    ///   print(result)
    ///
    /// Returns captured stdout on success, or an error message on failure.
    export execute: async func(code: string) -> result<string, string>;

    /// Capture a snapshot of the current Python session state.
    ///
    /// Returns the serialized state as bytes (using pickle internally).
    /// This captures all user-defined variables from previous execute() calls.
    ///
    /// The snapshot can be restored later using restore-state to continue
    /// execution with the same variables available.
    ///
    /// Returns an error if serialization fails (e.g., unpicklable objects).
    export snapshot-state: async func() -> result<list<u8>, string>;

    /// Restore Python session state from a previously captured snapshot.
    ///
    /// After restore, subsequent execute() calls will have access to all
    /// variables that were present when the snapshot was taken.
    ///
    /// Returns an error if deserialization fails (e.g., corrupted data).
    export restore-state: async func(data: list<u8>) -> result<_, string>;

    /// Clear all persistent state from the session.
    ///
    /// After clear, subsequent execute() calls will start with a fresh
    /// namespace (no user-defined variables from previous calls).
    export clear-state: async func();

    /// Finalize pre-initialization by resetting WASI state.
    ///
    /// This MUST be called at the end of pre-initialization, after all
    /// imports are done but before the memory snapshot is captured.
    /// It clears file handles from the WASI adapter and wasi-libc so they
    /// don't get captured in the snapshot (which would cause "unknown handle
    /// index" errors at runtime).
    ///
    /// This is only meant to be called during component-init-transform
    /// pre-initialization. Calling it at runtime has no useful effect.
    export finalize-preinit: func();
}
